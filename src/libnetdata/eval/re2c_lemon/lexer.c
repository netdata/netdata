/* Generated by re2c 4.1 on Fri Apr 18 11:41:39 2025 */
#line 1 "lexer.re"
/**
 * re2c lexer for Netdata's expression evaluator
 *
 * This implementation uses re2c for lexical analysis and lemon for parsing.
 * It is fully integrated with Netdata's existing EVAL_NODE structure.
 */

#include "../eval-internal.h"
#include "parser_internal.h"

// Scanner functions implementation
void scanner_init(Scanner *s, const char *input) {
    if (!input) {
        // Handle NULL input safely
        s->cursor = "";
        s->marker = s->cursor;
        s->token = s->cursor;
        s->limit = s->cursor;
        s->line = 1;
        s->error = 1;  // Set error flag for NULL input
        s->in_assignment = 0; // Initialize assignment context flag
        return;
    }
    
    s->cursor = input;
    s->marker = s->cursor;
    s->token = s->cursor;
    s->limit = s->cursor + strlen(s->cursor);
    s->line = 1;
    s->error = 0;  // Initialize error flag
    s->in_assignment = 0; // Initialize assignment context flag
}

int scan(Scanner *s, YYSTYPE *lval) {
    const char *YYMARKER;
    const char *YYCURSOR = s->cursor;
    char variable_buffer[EVAL_MAX_VARIABLE_NAME_LENGTH + 1] = {0};
    
    // Skip whitespace
    while (1) {
        s->token = YYCURSOR;
        

#line 47 "lexer.c"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
		case 0x00: goto yy1;
		case '\t':
		case ' ': goto yy4;
		case '\n':
		case '\r': goto yy6;
		case '!': goto yy8;
		case '$': goto yy10;
		case '%': goto yy11;
		case '&': goto yy12;
		case '(': goto yy13;
		case ')': goto yy14;
		case '*': goto yy15;
		case '+': goto yy16;
		case ',': goto yy17;
		case '-': goto yy18;
		case '.': goto yy19;
		case '/': goto yy20;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy21;
		case ':': goto yy23;
		case ';': goto yy24;
		case '<': goto yy25;
		case '=': goto yy27;
		case '>': goto yy29;
		case '?': goto yy31;
		case 'A':
		case 'a': goto yy32;
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy33;
		case 'I':
		case 'i': goto yy34;
		case 'N':
		case 'n': goto yy35;
		case 'O':
		case 'o': goto yy36;
		case '|': goto yy37;
		default: goto yy2;
	}
yy1:
	++YYCURSOR;
#line 221 "lexer.re"
	{ s->cursor = YYCURSOR; return 0; }
#line 146 "lexer.c"
yy2:
	++YYCURSOR;
yy3:
#line 224 "lexer.re"
	{ 
        s->cursor = YYCURSOR; 
        s->error = 1;  // Set error flag
        return 0;      // Return 0 to stop parsing
    }
#line 156 "lexer.c"
yy4:
	yych = *++YYCURSOR;
	switch (yych) {
		case '\t':
		case ' ': goto yy4;
		default: goto yy5;
	}
yy5:
#line 48 "lexer.re"
	{ continue; }
#line 167 "lexer.c"
yy6:
	yych = *++YYCURSOR;
	switch (yych) {
		case '\n':
		case '\r': goto yy6;
		default: goto yy7;
	}
yy7:
#line 51 "lexer.re"
	{ 
        s->cursor = YYCURSOR; 
        s->in_assignment = 0; 
        return TOK_SEMICOLON; 
    }
#line 182 "lexer.c"
yy8:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy38;
		default: goto yy9;
	}
yy9:
#line 156 "lexer.re"
	{
        s->cursor = YYCURSOR; 
        return TOK_NOT; 
    }
#line 195 "lexer.c"
yy10:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00:
		case '\t':
		case '\n':
		case '\r':
		case ' ':
		case '!':
		case '%':
		case '&':
		case '(':
		case ')':
		case '*':
		case '+':
		case ',':
		case '-':
		case '/':
		case ';':
		case '<':
		case '=':
		case '>':
		case '?':
		case '|':
		case '}': goto yy3;
		case '{': goto yy41;
		default: goto yy39;
	}
yy11:
	++YYCURSOR;
#line 129 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_MODULO; }
#line 228 "lexer.c"
yy12:
	yych = *++YYCURSOR;
	switch (yych) {
		case '&': goto yy43;
		default: goto yy3;
	}
yy13:
	++YYCURSOR;
#line 187 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LPAREN; }
#line 239 "lexer.c"
yy14:
	++YYCURSOR;
#line 188 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_RPAREN; }
#line 244 "lexer.c"
yy15:
	++YYCURSOR;
#line 127 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_MULTIPLY; }
#line 249 "lexer.c"
yy16:
	++YYCURSOR;
#line 125 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_PLUS; }
#line 254 "lexer.c"
yy17:
	++YYCURSOR;
#line 189 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_COMMA; }
#line 259 "lexer.c"
yy18:
	++YYCURSOR;
#line 126 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_MINUS; }
#line 264 "lexer.c"
yy19:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy45;
		default: goto yy3;
	}
yy20:
	++YYCURSOR;
#line 128 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_DIVIDE; }
#line 284 "lexer.c"
yy21:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '.': goto yy45;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy21;
		case 'E':
		case 'e': goto yy46;
		default: goto yy22;
	}
yy22:
#line 82 "lexer.re"
	{
        char *endptr;
        lval->dval = str2ndd(s->token, &endptr);
        s->cursor = YYCURSOR;
        s->in_assignment = 0; // Reset assignment context
        return TOK_NUMBER;
    }
#line 313 "lexer.c"
yy23:
	++YYCURSOR;
#line 184 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_COLON; }
#line 318 "lexer.c"
yy24:
	++YYCURSOR;
#line 130 "lexer.re"
	{ s->cursor = YYCURSOR; s->in_assignment = 0; return TOK_SEMICOLON; }
#line 323 "lexer.c"
yy25:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy48;
		case '>': goto yy38;
		default: goto yy26;
	}
yy26:
#line 177 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LT; }
#line 334 "lexer.c"
yy27:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy49;
		default: goto yy28;
	}
yy28:
#line 169 "lexer.re"
	{ 
        s->cursor = YYCURSOR;
        // If we're after a variable, it's an assignment, otherwise it's equality
        int token = s->in_assignment ? TOK_ASSIGN : TOK_EQ;
        s->in_assignment = 0; // Reset assignment context
        return token;
    }
#line 350 "lexer.c"
yy29:
	yych = *++YYCURSOR;
	switch (yych) {
		case '=': goto yy50;
		default: goto yy30;
	}
yy30:
#line 179 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_GT; }
#line 360 "lexer.c"
yy31:
	++YYCURSOR;
#line 183 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_QMARK; }
#line 365 "lexer.c"
yy32:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		case 'N':
		case 'n': goto yy54;
		default: goto yy3;
	}
yy33:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		default: goto yy3;
	}
yy34:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		case 'N':
		case 'n': goto yy55;
		default: goto yy3;
	}
yy35:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		case 'A':
		case 'a': goto yy56;
		case 'O':
		case 'o': goto yy57;
		case 'U':
		case 'u': goto yy58;
		default: goto yy3;
	}
yy36:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		case 'R':
		case 'r': goto yy59;
		default: goto yy3;
	}
yy37:
	yych = *++YYCURSOR;
	switch (yych) {
		case '|': goto yy61;
		default: goto yy3;
	}
yy38:
	++YYCURSOR;
#line 176 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_NE; }
#line 726 "lexer.c"
yy39:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00:
		case '\t':
		case '\n':
		case '\r':
		case ' ':
		case '!':
		case '%':
		case '&':
		case '(':
		case ')':
		case '*':
		case '+':
		case ',':
		case '-':
		case '/':
		case ';':
		case '<':
		case '=':
		case '>':
		case '?':
		case '{':
		case '|':
		case '}': goto yy40;
		default: goto yy39;
	}
yy40:
#line 93 "lexer.re"
	{
        size_t len = YYCURSOR - s->token - 1; // -1 to skip the $
        if (len >= EVAL_MAX_VARIABLE_NAME_LENGTH) {
            len = EVAL_MAX_VARIABLE_NAME_LENGTH - 1;
        }
        memcpy(variable_buffer, s->token + 1, len);
        variable_buffer[len] = '\0';
        lval->strval = strdupz(variable_buffer);
        s->cursor = YYCURSOR;
        s->in_assignment = 1; // Mark that we just saw a variable, potential assignment context
        return TOK_VARIABLE;
    }
#line 769 "lexer.c"
yy41:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 0x00: goto yy42;
		case '}': goto yy63;
		default: goto yy62;
	}
yy42:
#line 218 "lexer.re"
	{ s->cursor = YYCURSOR; s->error = 1; return 0; }
#line 781 "lexer.c"
yy43:
	++YYCURSOR;
yy44:
#line 134 "lexer.re"
	{
        s->cursor = YYCURSOR; 
        return TOK_AND; 
    }
#line 790 "lexer.c"
yy45:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy45;
		case 'E':
		case 'e': goto yy46;
		default: goto yy22;
	}
yy46:
	yych = *++YYCURSOR;
	switch (yych) {
		case '+':
		case '-': goto yy64;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy65;
		default: goto yy47;
	}
yy47:
	YYCURSOR = YYMARKER;
	switch (yyaccept) {
		case 0: goto yy22;
		case 1: goto yy3;
		case 2: goto yy42;
		case 3: goto yy60;
		case 4: goto yy44;
		case 5: goto yy68;
		case 6: goto yy70;
		default: goto yy9;
	}
yy48:
	++YYCURSOR;
#line 178 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_LE; }
#line 842 "lexer.c"
yy49:
	++YYCURSOR;
#line 168 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_EQ; }
#line 847 "lexer.c"
yy50:
	++YYCURSOR;
#line 180 "lexer.re"
	{ s->cursor = YYCURSOR; return TOK_GE; }
#line 852 "lexer.c"
yy51:
	++YYCURSOR;
#line 192 "lexer.re"
	{
        // Get the function name (excluding the trailing parenthesis)
        size_t len = YYCURSOR - s->token - 1; // -1 to exclude the "("
        char func_name[256] = {0};
        if(len >= sizeof(func_name) - 1) {
            len = sizeof(func_name) - 1;
        }
        memcpy(func_name, s->token, len);
        func_name[len] = '\0';
        
        // Check if this is a registered function
        EVAL_DYNAMIC_FUNCTION *func = eval_function_lookup(func_name);
        if(func) {
            // It's a registered function
            lval->op = func->operator;
            s->cursor = YYCURSOR;
            return TOK_FUNCTION;
        }
        
        // Not a registered function - report error
        s->cursor = YYCURSOR;
        s->error = 1;
        return 0;
    }
#line 880 "lexer.c"
yy52:
	yych = *++YYCURSOR;
yy53:
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		default: goto yy47;
	}
yy54:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'D':
		case 'd': goto yy66;
		default: goto yy53;
	}
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'F':
		case 'f': goto yy67;
		default: goto yy53;
	}
yy56:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy69;
		default: goto yy53;
	}
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T':
		case 't': goto yy71;
		default: goto yy53;
	}
yy58:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'L':
		case 'l': goto yy72;
		default: goto yy53;
	}
yy59:
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy75;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		default: goto yy74;
	}
yy60:
#line 145 "lexer.re"
	{
        s->cursor = YYCURSOR; 
        return TOK_OR; 
    }
#line 1062 "lexer.c"
yy61:
	++YYCURSOR;
	goto yy60;
yy62:
	yych = *++YYCURSOR;
	switch (yych) {
		case 0x00: goto yy47;
		case '}': goto yy76;
		default: goto yy62;
	}
yy63:
	++YYCURSOR;
#line 107 "lexer.re"
	{ s->cursor = YYCURSOR; s->error = 1; return 0; }
#line 1077 "lexer.c"
yy64:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy65;
		default: goto yy47;
	}
yy65:
	yych = *++YYCURSOR;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy65;
		default: goto yy22;
	}
yy66:
	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy79;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		default: goto yy78;
	}
yy67:
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		case 'I':
		case 'i': goto yy80;
		default: goto yy68;
	}
yy68:
#line 69 "lexer.re"
	{
        lval->dval = INFINITY;
        s->cursor = YYCURSOR;
        s->in_assignment = 0; // Reset assignment context
        return TOK_NUMBER;
    }
#line 1256 "lexer.c"
yy69:
	yyaccept = 6;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		default: goto yy70;
	}
yy70:
#line 60 "lexer.re"
	{
        lval->dval = NAN;
        s->cursor = YYCURSOR;
        s->in_assignment = 0; // Reset assignment context
        return TOK_NUMBER;
    }
#line 1335 "lexer.c"
yy71:
	yyaccept = 7;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy83;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		default: goto yy82;
	}
yy72:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'L':
		case 'l': goto yy69;
		default: goto yy53;
	}
yy73:
	yych = *++YYCURSOR;
yy74:
	switch (yych) {
		case '\t':
		case ' ': goto yy73;
		default: goto yy60;
	}
yy75:
	++YYCURSOR;
#line 150 "lexer.re"
	{ 
        // Move cursor back to just before the '('
        s->cursor = YYCURSOR - 1; 
        return TOK_OR; 
    }
#line 1429 "lexer.c"
yy76:
	++YYCURSOR;
#line 110 "lexer.re"
	{
        // Calculate length, excluding the ${ prefix and the } suffix
        size_t len = YYCURSOR - s->token - 3; // -3 to skip ${ and }
        if (len >= EVAL_MAX_VARIABLE_NAME_LENGTH) {
            len = EVAL_MAX_VARIABLE_NAME_LENGTH - 1;
        }
        memcpy(variable_buffer, s->token + 2, len);
        variable_buffer[len] = '\0';
        lval->strval = strdupz(variable_buffer);
        s->cursor = YYCURSOR;
        s->in_assignment = 1; // Mark that we just saw a variable, potential assignment context
        return TOK_VARIABLE;
    }
#line 1446 "lexer.c"
yy77:
	yych = *++YYCURSOR;
yy78:
	switch (yych) {
		case '\t':
		case ' ': goto yy77;
		default: goto yy44;
	}
yy79:
	++YYCURSOR;
#line 139 "lexer.re"
	{ 
        // Move cursor back to just before the '('
        s->cursor = YYCURSOR - 1; 
        return TOK_AND; 
    }
#line 1463 "lexer.c"
yy80:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'N':
		case 'n': goto yy84;
		default: goto yy53;
	}
yy81:
	yych = *++YYCURSOR;
yy82:
	switch (yych) {
		case '\t':
		case ' ': goto yy81;
		default: goto yy9;
	}
yy83:
	++YYCURSOR;
#line 161 "lexer.re"
	{ 
        // Move cursor back to just before the '('
        s->cursor = YYCURSOR - 1; 
        return TOK_NOT; 
    }
#line 1487 "lexer.c"
yy84:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'I':
		case 'i': goto yy85;
		default: goto yy53;
	}
yy85:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'T':
		case 't': goto yy86;
		default: goto yy53;
	}
yy86:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'Y':
		case 'y': goto yy87;
		default: goto yy53;
	}
yy87:
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case '(': goto yy51;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy52;
		default: goto yy68;
	}
}
#line 229 "lexer.re"

    }
}

// Function to parse an expression with re2c/lemon
EVAL_NODE *parse_expression_with_re2c_lemon(const char *string, const char **failed_at, EVAL_ERROR *error) {
    Scanner scanner;
    scanner_init(&scanner, string);

    if(failed_at)
        *failed_at = NULL;
    
    // Use ParseAlloc with mallocz instead of malloc - mallocz will handle allocation failures
    void *parser = ParseAlloc(mallocz);
    
    EVAL_NODE *result = NULL;
    
    YYSTYPE token_value;
    int token_type;
    
    // Initialize error code
    if (error) *error = EVAL_ERROR_OK;
    
    // Save the token start position for error reporting
    const char *error_pos = scanner.cursor;
    
    // Variable to track if we need to free token_value.strval
    int free_strval = 0;
    
    while ((token_type = scan(&scanner, &token_value)) > 0) {
        // If the token is a variable, remember to free it if there's an error
        free_strval = (token_type == TOK_VARIABLE);
        
        Parse(parser, token_type, token_value, &result);
        
        // Save position before potential error
        error_pos = scanner.token;
        
        // Check for syntax errors after each token
        if (result && result->operator == EVAL_OPERATOR_NOP && result->count == 0) {
            // This is an error marker
            if (error) *error = EVAL_ERROR_SYNTAX;
            if (failed_at) {
                *failed_at = error_pos;
            }
            
            // Clean up
            eval_node_free(result);
            ParseFree(parser, freez);
            
            // If we just scanned a variable, free its strval
            if (free_strval && token_value.strval) {
                freez(token_value.strval);
            }
            
            return NULL;
        }
        
        // Reset free_strval since the parser has taken ownership of the string
        free_strval = 0;
    }
    
    // If the last token was a variable and scanning stopped due to an error,
    // we need to free the token_value.strval
    if (free_strval && token_value.strval) {
        freez(token_value.strval);
        token_value.strval = NULL;
    }
    
    // Finish parsing
    Parse(parser, 0, token_value, &result);
    
    // Clean up the parser
    ParseFree(parser, freez);
    
    // Check for lexer errors
    if (scanner.error) {
        if (error) *error = EVAL_ERROR_UNKNOWN_OPERAND;
        if (failed_at) {
            *failed_at = error_pos;
        }
        
        // Clean up result if it was created
        if (result) {
            eval_node_free(result);
        }
        
        return NULL;
    }
    
    if (!result) {
        if (error) *error = EVAL_ERROR_SYNTAX;
        if (failed_at) {
            *failed_at = error_pos;
        }
        return NULL;
    }
    
    if (failed_at)
        *failed_at = NULL;
    
    return result;
}