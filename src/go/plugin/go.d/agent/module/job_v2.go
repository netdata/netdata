// SPDX-License-Identifier: GPL-3.0-or-later

package module

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"log/slog"
	"runtime/debug"
	"sync"
	"sync/atomic"
	"time"

	"github.com/netdata/netdata/go/plugins/logger"
	"github.com/netdata/netdata/go/plugins/pkg/metrix"
	"github.com/netdata/netdata/go/plugins/pkg/netdataapi"
	"github.com/netdata/netdata/go/plugins/plugin/go.d/agent/chartemit"
	"github.com/netdata/netdata/go/plugins/plugin/go.d/agent/chartengine"
	"github.com/netdata/netdata/go/plugins/plugin/go.d/agent/runtimecomp"
	"github.com/netdata/netdata/go/plugins/plugin/go.d/agent/vnodes"
)

type JobV2Config struct {
	PluginName      string
	Name            string
	ModuleName      string
	FullName        string
	Module          ModuleV2
	Labels          map[string]string
	Out             io.Writer
	UpdateEvery     int
	AutoDetectEvery int
	Vnode           vnodes.VirtualNode
	FunctionOnly    bool
	RuntimeService  runtimecomp.Service
}

func NewJobV2(cfg JobV2Config) *JobV2 {
	var buf bytes.Buffer
	if cfg.UpdateEvery <= 0 {
		cfg.UpdateEvery = 1
	}

	j := &JobV2{
		pluginName:      cfg.PluginName,
		name:            cfg.Name,
		moduleName:      cfg.ModuleName,
		fullName:        cfg.FullName,
		updateEvery:     cfg.UpdateEvery,
		autoDetectEvery: cfg.AutoDetectEvery,
		functionOnly:    cfg.FunctionOnly,
		module:          cfg.Module,
		labels:          cloneLabels(cfg.Labels),
		out:             cfg.Out,
		stop:            make(chan struct{}),
		tick:            make(chan int),
		updVnode:        make(chan *vnodes.VirtualNode, 1),
		buf:             &buf,
		api:             netdataapi.New(&buf),
		vnode:           cfg.Vnode,
		runtimeService:  cfg.RuntimeService,
	}
	if j.out == nil {
		j.out = io.Discard
	}

	log := logger.New().With(
		slog.String("collector", j.ModuleName()),
		slog.String("job", j.Name()),
	)
	j.Logger = log
	if j.module != nil {
		j.module.GetBase().Logger = log
		if vnode := j.module.VirtualNode(); vnode != nil {
			*vnode = *cfg.Vnode.Copy()
		}
	}
	return j
}

type JobV2 struct {
	pluginName      string
	name            string
	moduleName      string
	fullName        string
	updateEvery     int
	autoDetectEvery int
	functionOnly    bool
	labels          map[string]string

	*logger.Logger

	module ModuleV2

	running atomic.Bool

	initialized bool
	panicked    bool

	store  metrix.CollectorStore
	cycle  metrix.CycleController
	engine *chartengine.Engine

	prevRun time.Time
	retries int

	vnodeMu  sync.RWMutex
	vnode    vnodes.VirtualNode
	updVnode chan *vnodes.VirtualNode

	ctxMu     sync.RWMutex
	runCtx    context.Context
	cancelRun context.CancelFunc

	tick chan int
	out  io.Writer
	buf  *bytes.Buffer
	api  *netdataapi.API

	stop chan struct{}

	runtimeService             runtimecomp.Service
	runtimeComponentName       string
	runtimeComponentRegistered bool
}

func (j *JobV2) FullName() string   { return j.fullName }
func (j *JobV2) ModuleName() string { return j.moduleName }
func (j *JobV2) Name() string       { return j.name }
func (j *JobV2) Panicked() bool     { return j.panicked }
func (j *JobV2) IsRunning() bool    { return j.running.Load() }
func (j *JobV2) Module() ModuleV2   { return j.module }
func (j *JobV2) Collector() any     { return j.module }
func (j *JobV2) AutoDetectionEvery() int {
	return j.autoDetectEvery
}
func (j *JobV2) RetryAutoDetection() bool {
	return j.autoDetectEvery > 0
}
func (j *JobV2) Configuration() any {
	if j.module == nil {
		return nil
	}
	return j.module.Configuration()
}
func (j *JobV2) IsFunctionOnly() bool { return j.functionOnly }
func (j *JobV2) Vnode() vnodes.VirtualNode {
	j.vnodeMu.RLock()
	defer j.vnodeMu.RUnlock()
	return *j.vnode.Copy()
}
func (j *JobV2) UpdateVnode(vnode *vnodes.VirtualNode) {
	if vnode == nil {
		return
	}
	select {
	case <-j.updVnode:
	default:
	}
	j.updVnode <- vnode
}
func (j *JobV2) Cleanup() {
	j.unregisterRuntimeComponent()
	if j.module != nil {
		j.module.Cleanup(context.Background())
	}
}

func (j *JobV2) AutoDetection() (err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("panic %v", r)
			j.panicked = true
			j.Errorf("PANIC %v", r)
			if logger.Level.Enabled(slog.LevelDebug) {
				j.Errorf("STACK: %s", debug.Stack())
			}
		}
		if err != nil {
			j.Cleanup()
		}
	}()

	if err = j.init(); err != nil {
		j.Errorf("init failed: %v", err)
		return err
	}
	if err = j.check(); err != nil {
		j.Errorf("check failed: %v", err)
		return err
	}
	if err = j.postCheck(); err != nil {
		j.Errorf("postCheck failed: %v", err)
		return err
	}
	return nil
}

func (j *JobV2) Start() {
	j.running.Store(true)
	runCtx, cancel := context.WithCancel(context.Background())
	j.setRunContext(runCtx, cancel)
	j.Infof("started (v2), data collection interval %ds", j.updateEvery)
	defer func() {
		cancel()
		j.setRunContext(nil, nil)
		j.running.Store(false)
		j.Info("stopped")
	}()

LOOP:
	for {
		select {
		case <-j.stop:
			break LOOP
		case t := <-j.tick:
			if j.shouldCollect(t) {
				j.runOnce()
			}
		}
	}
	j.Cleanup()
	j.stop <- struct{}{}
}

func (j *JobV2) Stop() {
	j.cancelRunContext()
	j.stop <- struct{}{}
	<-j.stop
}

func (j *JobV2) Tick(clock int) {
	select {
	case j.tick <- clock:
	default:
	}
}

func (j *JobV2) shouldCollect(clock int) bool {
	return clock%(j.updateEvery+j.penalty()) == 0
}

func (j *JobV2) init() error {
	if j.initialized {
		return nil
	}
	if err := j.module.Init(j.moduleContext()); err != nil {
		return err
	}
	j.initialized = true
	return nil
}

func (j *JobV2) check() error {
	return j.module.Check(j.moduleContext())
}

func (j *JobV2) postCheck() error {
	store := j.module.MetricStore()
	if store == nil {
		return fmt.Errorf("nil metric store")
	}
	managed, ok := metrix.AsCycleManagedStore(store)
	if !ok {
		return fmt.Errorf("metric store is not cycle-managed")
	}

	opts := []chartengine.Option{
		chartengine.WithLogger(j.Logger.With(slog.String("component", "chartengine"))),
	}
	if v, ok := j.module.(ModuleV2EnginePolicy); ok {
		opts = append(opts, chartengine.WithEnginePolicy(v.EnginePolicy()))
	}

	engine, err := chartengine.New(opts...)
	if err != nil {
		return err
	}
	if err := engine.LoadYAML([]byte(j.module.ChartTemplateYAML()), 1); err != nil {
		return err
	}

	j.store = store
	j.cycle = managed.CycleController()
	j.engine = engine
	if err := j.registerRuntimeComponent(); err != nil {
		j.Warningf("runtime metrics registration failed: %v", err)
	}
	return nil
}

func (j *JobV2) runOnce() {
	j.applyPendingVnodeUpdate()

	curTime := time.Now()
	sinceLastRun := calcSinceLastRun(curTime, j.prevRun)
	j.prevRun = curTime

	ok := j.collectAndEmit(sinceLastRun)
	if ok {
		j.retries = 0
	} else {
		j.retries++
	}

	// Never flush buffered output from failed or panicked cycles:
	// a panic can leave partial protocol lines in the buffer.
	if ok && !j.panicked {
		_, _ = io.Copy(j.out, j.buf)
	}
	j.buf.Reset()
}

func (j *JobV2) applyPendingVnodeUpdate() {
	select {
	case vnode := <-j.updVnode:
		if vnode == nil {
			return
		}

		next := vnode.Copy()

		j.vnodeMu.Lock()
		j.vnode = *next
		j.vnodeMu.Unlock()

		if j.module != nil {
			if mv := j.module.VirtualNode(); mv != nil {
				*mv = *next
			}
		}
	default:
	}
}

func (j *JobV2) collectAndEmit(sinceLastRun int) bool {
	j.panicked = false
	cycleOpen := false

	defer func() {
		if r := recover(); r != nil {
			if cycleOpen {
				// Recover path must close staged frame to keep subsequent cycles valid.
				func() {
					defer func() { _ = recover() }()
					j.cycle.AbortCycle()
				}()
			}
			j.panicked = true
			j.Errorf("PANIC: %v", r)
			if logger.Level.Enabled(slog.LevelDebug) {
				j.Errorf("STACK: %s", debug.Stack())
			}
		}
	}()

	j.cycle.BeginCycle()
	cycleOpen = true
	if err := j.module.Collect(j.moduleContext()); err != nil {
		j.cycle.AbortCycle()
		cycleOpen = false
		j.Warningf("collect failed: %v", err)
		return false
	}
	j.cycle.CommitCycleSuccess()
	cycleOpen = false

	plan, err := j.engine.BuildPlan(j.store.Read(metrix.ReadRaw(), metrix.ReadFlatten()))
	if err != nil {
		j.Warningf("build plan failed: %v", err)
		return false
	}

	if err := chartemit.ApplyPlan(j.api, plan, chartemit.EmitEnv{
		TypeID:      j.fullName,
		UpdateEvery: j.updateEvery,
		Plugin:      j.pluginName,
		Module:      j.moduleName,
		JobName:     j.name,
		JobLabels:   j.labels,
		MSSinceLast: sinceLastRun,
	}); err != nil {
		j.Warningf("apply plan failed: %v", err)
		return false
	}
	return true
}

func (j *JobV2) penalty() int {
	v := j.retries / penaltyStep * penaltyStep * j.updateEvery / 2
	if v > maxPenalty {
		return maxPenalty
	}
	return v
}

func cloneLabels(in map[string]string) map[string]string {
	if len(in) == 0 {
		return nil
	}
	out := make(map[string]string, len(in))
	for k, v := range in {
		out[k] = v
	}
	return out
}

func (j *JobV2) moduleContext() context.Context {
	j.ctxMu.RLock()
	ctx := j.runCtx
	j.ctxMu.RUnlock()
	if ctx == nil {
		return context.Background()
	}
	return ctx
}

func (j *JobV2) cancelRunContext() {
	j.ctxMu.RLock()
	cancel := j.cancelRun
	j.ctxMu.RUnlock()
	if cancel != nil {
		cancel()
	}
}

func (j *JobV2) setRunContext(ctx context.Context, cancel context.CancelFunc) {
	j.ctxMu.Lock()
	j.runCtx = ctx
	j.cancelRun = cancel
	j.ctxMu.Unlock()
}
