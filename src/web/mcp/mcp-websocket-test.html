<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netdata MCP WebSocket Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            line-height: 1.6;
            color: #333;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        h1 {
            color: #0088cc;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .connection-panel {
            background-color: #e2f4ff;
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }
        .four-column-layout {
            display: grid;
            grid-template-columns: 195px 260px 1fr 2fr;
            gap: 10px;
            height: calc(100vh - 120px);
            min-height: 500px;
        }
        .column {
            background-color: #f5f5f5;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative; /* Added for absolute positioning of buttons */
        }
        .column-header {
            margin-top: 0;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #ddd;
            font-size: 1.2em;
            color: #0088cc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .column-content {
            overflow-y: auto;
            flex: 1;
        }
        .flow-item, .method-item {
            padding: 8px;
            margin-bottom: 6px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .flow-item:hover, .method-item:hover {
            background-color: #e0e0e0;
        }
        .flow-item.active, .method-item.active {
            background-color: #d0e8f2;
            font-weight: bold;
        }
        #jsonEditor {
            width: 100%;
            height: 100%;
            font-family: monospace;
            font-size: 14px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            resize: none;
            box-sizing: border-box;
        }
        /* JSON syntax highlighting */
        .json-string { 
            color: #008800; 
            font-weight: bold;
            display: inline-block; /* Allow multiline strings to format properly */
        }
        .json-number { color: #0055aa; font-weight: bold; }
        .json-boolean-true { color: #008800; font-weight: bold; }
        .json-boolean-false { color: #dd0000; font-weight: bold; }
        .json-null { color: #666666; font-weight: bold; }
        .json-key { color: #555555; }
        .json-bracket { color: #aaaaaa; }
        .json-comma { color: #aaaaaa; }
        .json-colon { color: #aaaaaa; }
        #requestData {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow: auto;
            white-space: pre-wrap;
            max-height: 100px;
        }
        button {
            background-color: #0088cc;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #006699;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .status {
            font-weight: bold;
        }
        .connected {
            color: green;
        }
        .disconnected {
            color: red;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #555;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Ensure JSON content wraps properly */
        pre, #responseViewer, #requestData {
            white-space: pre-wrap !important;
            word-break: break-word !important;
            overflow-x: auto !important;
        }
    </style>
</head>
<body>
    <h1>Netdata MCP WebSocket Test</h1>
    
    <div class="connection-panel">
        <label for="serverUrl">WebSocket Server URL:</label>
        <input type="text" id="serverUrl" value="ws://localhost:19999/mcp" style="width: 300px;">
        <button id="connectBtn">Connect</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
        <span id="status" class="status disconnected">Disconnected</span>
    </div>
    
    <div class="four-column-layout">
        <!-- First Column - Flows -->
        <div class="column">
            <h3 class="column-header">Flows</h3>
            <div class="column-content" id="flowsContainer">
                <div class="flow-item active" data-flow="initialize-flow">Initialize</div>
                <div class="flow-item" data-flow="tools-flow">Tools</div>
                <div class="flow-item" data-flow="resources-flow">Resources</div>
                <div class="flow-item" data-flow="prompts-flow">Prompts</div>
                <div class="flow-item" data-flow="notifications-flow">Notifications</div>
                <div class="flow-item" data-flow="context-flow">Context</div>
                <div class="flow-item" data-flow="system-flow">System</div>
            </div>
        </div>
        
        <!-- Second Column - Methods -->
        <div class="column">
            <h3 class="column-header">Methods</h3>
            <div class="column-content" id="methodsContainer">
                <!-- Methods will be loaded here -->
            </div>
        </div>
        
        <!-- Third Column - Request Editor -->
        <div class="column">
            <h3 class="column-header">
                Request
                <span class="tooltip">â“˜
                    <span class="tooltiptext">
                        JSON-RPC 2.0 request format requires "jsonrpc": "2.0", "method" and an optional "id".
                    </span>
                </span>
            </h3>
            <div style="display: flex; flex-direction: column; height: 100%;">
                <!-- 50% height for JSON editor -->
                <textarea id="jsonEditor" style="height: 50%; min-height: 200px; margin-bottom: 8px; resize: none;"></textarea>
                
                <!-- Log container with remaining height minus buttons -->
                <div style="display: flex; flex-direction: column; height: calc(50% - 60px); margin-bottom: 50px;">
                    <div id="requestData" style="background-color: #f0f0f0; padding: 6px; border-radius: 4px; margin-bottom: 4px; font-family: monospace; font-size: 12px; white-space: pre-wrap; word-break: break-word; height: 60px; overflow: auto;"></div>
                    <pre id="commLog" style="flex: 1; background-color: #f8f8f8; border: 1px solid #ddd; border-radius: 4px; padding: 6px; font-family: monospace; font-size: 12px; overflow: auto; margin: 0;"></pre>
                </div>
                
                <!-- Fixed position buttons at the bottom -->
                <div class="button-row" style="position: absolute; bottom: 10px; left: 10px; right: 10px; background: #f5f5f5; padding: 5px 0;">
                    <button id="sendBtn" disabled>Send</button>
                    <button id="resetBtn">Reset</button>
                    <button id="clearLogBtn">Clear Log</button>
                </div>
            </div>
        </div>
        
        <!-- Fourth Column - Response Viewer -->
        <div class="column">
            <h3 class="column-header">Response</h3>
            <div style="display: flex; flex-direction: column; height: calc(100% - 35px);">
                <pre id="responseViewer" style="flex: 1; overflow: auto; margin: 0; padding: 6px; background-color: #f8f8f8; border: 1px solid #ddd; border-radius: 4px; white-space: pre-wrap; word-break: break-word;"><span class="json-null">No response yet.</span></pre>
            </div>
        </div>
    </div>

    <script>
        // DOM elements
        const serverUrlInput = document.getElementById('serverUrl');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusSpan = document.getElementById('status');
        const jsonEditor = document.getElementById('jsonEditor');
        const sendBtn = document.getElementById('sendBtn');
        const resetBtn = document.getElementById('resetBtn');
        const clearLogBtn = document.getElementById('clearLogBtn');
        const responseViewer = document.getElementById('responseViewer');
        const requestData = document.getElementById('requestData');
        const commLog = document.getElementById('commLog');
        const flowsContainer = document.getElementById('flowsContainer');
        const methodsContainer = document.getElementById('methodsContainer');
        
        // WebSocket connection
        let socket = null;
        let requestId = 1;
        let isConnected = false;
        let requestTimestamp = null;
        
        // Function to highlight JSON syntax with colors
        function syntaxHighlightJson(json) {
            // Use more space for indentation to make it easier to read
            const jsonStr = JSON.stringify(json, null, 4);
            
            // A more direct approach for syntax highlighting
            let result = '';
            let inString = false;
            let isKey = false;
            let currentStr = '';
            let lastChar = '';
            
            // Process each character individually to maintain proper context
            for (let i = 0; i < jsonStr.length; i++) {
                const char = jsonStr[i];
                
                // Handle string delimiters
                if (char === '"' && lastChar !== '\\') {
                    if (!inString) {
                        // Start of a new string
                        inString = true;
                        currentStr = char;
                        
                        // Check if this might be a key by looking ahead for a colon
                        isKey = false;
                        for (let j = i + 1; j < jsonStr.length; j++) {
                            if (jsonStr[j] === '"' && jsonStr[j-1] !== '\\') {
                                // End of string found, now look for colon
                                for (let k = j + 1; k < jsonStr.length; k++) {
                                    if (jsonStr[k] === ':') {
                                        isKey = true;
                                        break;
                                    } else if (jsonStr[k] !== ' ' && jsonStr[k] !== '\t' && jsonStr[k] !== '\n') {
                                        break;
                                    }
                                }
                                break;
                            }
                        }
                    } else {
                        // End of a string
                        currentStr += char;
                        inString = false;
                        
                        // Apply the appropriate class for string formatting
                        if (isKey) {
                            result += '<span class="json-key">' + escapeHtml(currentStr) + '</span>';
                        } else {
                            result += '<span class="json-string">' + escapeHtml(currentStr) + '</span>';
                        }
                        currentStr = '';
                    }
                } 
                else if (inString) {
                    // Inside a string, collect characters
                    currentStr += char;
                }
                else if (char === ':') {
                    result += '<span class="json-colon">:</span>';
                }
                else if (char === ',') {
                    result += '<span class="json-comma">,</span>';
                }
                else if (char === '{' || char === '}' || char === '[' || char === ']') {
                    result += '<span class="json-bracket">' + char + '</span>';
                }
                else if (char === 't' && jsonStr.substring(i, i+4) === 'true') {
                    result += '<span class="json-boolean-true">true</span>';
                    i += 3; // Skip the rest of "true"
                }
                else if (char === 'f' && jsonStr.substring(i, i+5) === 'false') {
                    result += '<span class="json-boolean-false">false</span>';
                    i += 4; // Skip the rest of "false"
                }
                else if (char === 'n' && jsonStr.substring(i, i+4) === 'null') {
                    result += '<span class="json-null">null</span>';
                    i += 3; // Skip the rest of "null"
                }
                else if (/[0-9]/.test(char) || char === '-') {
                    // Start of a number
                    let numberStr = char;
                    for (let j = i + 1; j < jsonStr.length; j++) {
                        if (/[0-9.eE+-]/.test(jsonStr[j])) {
                            numberStr += jsonStr[j];
                            i++;
                        } else {
                            break;
                        }
                    }
                    result += '<span class="json-number">' + numberStr + '</span>';
                }
                else {
                    // Whitespace and other characters
                    result += char;
                }
                
                lastChar = char;
            }
            
            return result;
        }
        
        // Helper function to escape HTML entities
        function escapeHtml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                // Replace literal \n with actual line breaks for display
                .replace(/\\n/g, '<br>');
        }
        
        // State storage for method requests and responses
        const methodState = new Map();
        let currentFlow = 'initialize-flow';
        let currentMethod = null;
        
        // Method definitions by flow
        const flows = {
            'initialize-flow': {
                name: 'Initialize',
                methods: {
                    'initialize': {
                        name: 'initialize',
                        description: 'Get information about available resources and methods',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'initialize',
                            params: {
                                protocolVersion: '2024-11-05',
                                capabilities: {
                                    textDocument: {
                                        synchronization: {
                                            incremental: true
                                        }
                                    },
                                    completion: {
                                        contextSupport: true
                                    }
                                },
                                clientInfo: {
                                    name: 'netdata-mcp-test',
                                    version: '1.0.0',
                                    description: 'Netdata MCP Protocol Test Client'
                                }
                            },
                            id: 1
                        }
                    }
                }
            },
            'tools-flow': {
                name: 'Tools',
                methods: {
                    'tools/list': {
                        name: 'tools/list',
                        description: 'Get list of available tools with their schemas',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/list',
                            params: {},
                            id: 1
                        }
                    },
                    'tools/execute': {
                        name: 'tools/execute',
                        description: 'Execute a tool with parameters',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/execute',
                            params: {
                                name: 'explore_metrics',
                                input: {
                                    context: 'system.cpu'
                                }
                            },
                            id: 1
                        }
                    },
                    'tools/cancel': {
                        name: 'tools/cancel',
                        description: 'Cancel a running tool execution',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/cancel',
                            params: {
                                executionId: '12345'
                            },
                            id: 1
                        }
                    },
                    'tools/status': {
                        name: 'tools/status',
                        description: 'Get status of a tool execution',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/status',
                            params: {
                                executionId: '12345'
                            },
                            id: 1
                        }
                    },
                    'tools/validate': {
                        name: 'tools/validate',
                        description: 'Validate parameters for a tool',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/validate',
                            params: {
                                name: 'explore_metrics',
                                input: {
                                    context: 'system.cpu'
                                }
                            },
                            id: 1
                        }
                    },
                    'tools/describe': {
                        name: 'tools/describe',
                        description: 'Get detailed documentation for a tool',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/describe',
                            params: {
                                name: 'explore_metrics'
                            },
                            id: 1
                        }
                    },
                    'tools/getCapabilities': {
                        name: 'tools/getCapabilities',
                        description: 'Get capabilities of the tools subsystem',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'tools/getCapabilities',
                            params: {},
                            id: 1
                        }
                    }
                }
            },
            'resources-flow': {
                name: 'Resources',
                methods: {
                    'resources/list': {
                        name: 'resources/list',
                        description: 'Get list of available resources',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/list',
                            params: {
                                // Optional pagination cursor
                                // cursor: "pagination_token"
                            },
                            id: 1
                        }
                    },
                    'resources/read': {
                        name: 'resources/read',
                        description: 'Read a specific resource by URI',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/read',
                            params: {
                                uri: 'nd://contexts'
                            },
                            id: 1
                        }
                    },
                    'resources/templates/list': {
                        name: 'resources/templates/list',
                        description: 'Get list of resource templates for URI construction',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/templates/list',
                            params: {
                                // Optional pagination cursor
                                // cursor: "pagination_token"
                            },
                            id: 1
                        }
                    },
                    'resources/subscribe': {
                        name: 'resources/subscribe',
                        description: 'Subscribe to changes in a resource',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/subscribe',
                            params: {
                                uri: 'nd://contexts'
                            },
                            id: 1
                        }
                    },
                    'resources/unsubscribe': {
                        name: 'resources/unsubscribe',
                        description: 'Unsubscribe from a resource',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'resources/unsubscribe',
                            params: {
                                uri: 'nd://contexts'
                            },
                            id: 1
                        }
                    }
                }
            },
            'prompts-flow': {
                name: 'Prompts',
                methods: {
                    'prompts/list': {
                        name: 'prompts/list',
                        description: 'Get list of available prompts',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/list',
                            params: {},
                            id: 1
                        }
                    },
                    'prompts/execute': {
                        name: 'prompts/execute',
                        description: 'Execute a prompt',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/execute',
                            params: {
                                name: 'analyze_metrics',
                                input: {
                                    context: 'system.cpu',
                                    timeframe: '1h'
                                }
                            },
                            id: 1
                        }
                    },
                    'prompts/get': {
                        name: 'prompts/get',
                        description: 'Get a specific prompt',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/get',
                            params: {
                                name: 'analyze_metrics'
                            },
                            id: 1
                        }
                    },
                    'prompts/save': {
                        name: 'prompts/save',
                        description: 'Save a prompt',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/save',
                            params: {
                                name: 'my_custom_prompt',
                                description: 'A custom prompt for analysis',
                                template: 'Analyze the following metrics: {{context}}'
                            },
                            id: 1
                        }
                    },
                    'prompts/delete': {
                        name: 'prompts/delete',
                        description: 'Delete a prompt',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/delete',
                            params: {
                                name: 'my_custom_prompt'
                            },
                            id: 1
                        }
                    },
                    'prompts/getCategories': {
                        name: 'prompts/getCategories',
                        description: 'Get categories of prompts',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/getCategories',
                            params: {},
                            id: 1
                        }
                    },
                    'prompts/getHistory': {
                        name: 'prompts/getHistory',
                        description: 'Get history of prompt executions',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'prompts/getHistory',
                            params: {
                                limit: 10
                            },
                            id: 1
                        }
                    }
                }
            },
            'notifications-flow': {
                name: 'Notifications',
                methods: {
                    'notifications/initialized': {
                        name: 'notifications/initialized',
                        description: 'Notify server that client is initialized',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'notifications/initialized'
                            // No id for notifications
                        }
                    },
                    'notifications/subscribe': {
                        name: 'notifications/subscribe',
                        description: 'Subscribe to notifications',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'notifications/subscribe',
                            params: {
                                type: 'alerts'
                            },
                            id: 1
                        }
                    },
                    'notifications/unsubscribe': {
                        name: 'notifications/unsubscribe',
                        description: 'Unsubscribe from notifications',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'notifications/unsubscribe',
                            params: {
                                subscriptionId: '12345'
                            },
                            id: 1
                        }
                    },
                    'notifications/acknowledge': {
                        name: 'notifications/acknowledge',
                        description: 'Acknowledge a notification',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'notifications/acknowledge',
                            params: {
                                notificationId: '12345'
                            },
                            id: 1
                        }
                    },
                    'notifications/getHistory': {
                        name: 'notifications/getHistory',
                        description: 'Get history of notifications',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'notifications/getHistory',
                            params: {
                                limit: 10
                            },
                            id: 1
                        }
                    },
                    'notifications/send': {
                        name: 'notifications/send',
                        description: 'Send a notification',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'notifications/send',
                            params: {
                                type: 'message',
                                content: 'Test notification from client'
                            },
                            id: 1
                        }
                    },
                    'notifications/getSettings': {
                        name: 'notifications/getSettings',
                        description: 'Get notification settings',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'notifications/getSettings',
                            params: {},
                            id: 1
                        }
                    }
                }
            },
            'context-flow': {
                name: 'Context',
                methods: {
                    'context/provide': {
                        name: 'context/provide',
                        description: 'Provide context to the server',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'context/provide',
                            params: {
                                context: {
                                    user: 'admin',
                                    preferences: {
                                        theme: 'dark'
                                    }
                                }
                            },
                            id: 1
                        }
                    },
                    'context/clear': {
                        name: 'context/clear',
                        description: 'Clear context',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'context/clear',
                            params: {
                                keys: ['preferences']
                            },
                            id: 1
                        }
                    },
                    'context/status': {
                        name: 'context/status',
                        description: 'Get context status',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'context/status',
                            params: {},
                            id: 1
                        }
                    },
                    'context/save': {
                        name: 'context/save',
                        description: 'Save context for future use',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'context/save',
                            params: {
                                name: 'my_saved_context'
                            },
                            id: 1
                        }
                    },
                    'context/load': {
                        name: 'context/load',
                        description: 'Load a saved context',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'context/load',
                            params: {
                                name: 'my_saved_context'
                            },
                            id: 1
                        }
                    }
                }
            },
            'system-flow': {
                name: 'System',
                methods: {
                    'system/health': {
                        name: 'system/health',
                        description: 'Get system health information',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'system/health',
                            params: {},
                            id: 1
                        }
                    },
                    'system/version': {
                        name: 'system/version',
                        description: 'Get detailed version information',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'system/version',
                            params: {},
                            id: 1
                        }
                    },
                    'system/metrics': {
                        name: 'system/metrics',
                        description: 'Get system performance metrics',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'system/metrics',
                            params: {},
                            id: 1
                        }
                    },
                    'system/restart': {
                        name: 'system/restart',
                        description: 'Request system restart',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'system/restart',
                            params: {
                                force: false
                            },
                            id: 1
                        }
                    },
                    'system/status': {
                        name: 'system/status',
                        description: 'Get system status',
                        defaultRequest: {
                            jsonrpc: '2.0',
                            method: 'system/status',
                            params: {},
                            id: 1
                        }
                    }
                }
            }
            // Additional flows can be added here later
        };
        
        // Initialize UI
        function initializeUI() {
            // Populate flow items
            flowsContainer.innerHTML = '';
            Object.keys(flows).forEach(flowId => {
                const flow = flows[flowId];
                const flowElement = document.createElement('div');
                flowElement.className = `flow-item ${flowId === currentFlow ? 'active' : ''}`;
                flowElement.dataset.flow = flowId;
                flowElement.textContent = flow.name;
                flowElement.addEventListener('click', () => selectFlow(flowId));
                flowsContainer.appendChild(flowElement);
            });
            
            // Load methods for current flow
            loadMethodsForFlow(currentFlow);
        }
        
        // Load methods for a specific flow
        function loadMethodsForFlow(flowId) {
            methodsContainer.innerHTML = '';
            const flow = flows[flowId];
            
            if (!flow) return;
            
            Object.keys(flow.methods).forEach(methodId => {
                const method = flow.methods[methodId];
                const methodElement = document.createElement('div');
                methodElement.className = 'method-item';
                methodElement.dataset.method = methodId;
                methodElement.dataset.flow = flowId;
                
                const methodName = document.createElement('div');
                methodName.textContent = method.name;
                methodName.style.fontWeight = 'bold';
                
                const methodDesc = document.createElement('div');
                methodDesc.textContent = method.description;
                methodDesc.style.fontSize = '0.9em';
                methodDesc.style.color = '#666';
                
                methodElement.appendChild(methodName);
                methodElement.appendChild(methodDesc);
                
                methodElement.addEventListener('click', () => selectMethod(flowId, methodId));
                methodsContainer.appendChild(methodElement);
            });
            
            // Select the first method by default, or restore the previously selected method
            const savedMethod = localStorage.getItem(`selected-method-${flowId}`);
            if (savedMethod && flows[flowId].methods[savedMethod]) {
                selectMethod(flowId, savedMethod);
            } else {
                const firstMethod = Object.keys(flow.methods)[0];
                selectMethod(flowId, firstMethod);
            }
        }
        
        // Select a flow
        function selectFlow(flowId) {
            // Update UI
            document.querySelectorAll('.flow-item').forEach(item => {
                item.classList.toggle('active', item.dataset.flow === flowId);
            });
            
            // Save current request if a method is selected
            if (currentMethod) {
                saveCurrentRequest();
            }
            
            // Update state
            currentFlow = flowId;
            localStorage.setItem('selected-flow', flowId);
            
            // Load methods for this flow
            loadMethodsForFlow(flowId);
        }
        
        // Select a method
        function selectMethod(flowId, methodId) {
            // Save current request if a method is already selected
            if (currentMethod) {
                saveCurrentRequest();
            }
            
            // Update UI
            document.querySelectorAll('.method-item').forEach(item => {
                item.classList.toggle('active', item.dataset.method === methodId);
            });
            
            // Update state
            currentFlow = flowId;
            currentMethod = methodId;
            localStorage.setItem('selected-flow', flowId);
            localStorage.setItem(`selected-method-${flowId}`, methodId);
            
            // Load saved or default request for this method
            loadRequestForMethod(flowId, methodId);
            
            // Load saved response for this method if exists
            loadResponseForMethod(flowId, methodId);
        }
        
        // Save the current request in the editor
        function saveCurrentRequest() {
            if (!currentFlow || !currentMethod) return;
            
            try {
                const requestObj = JSON.parse(jsonEditor.value);
                const key = `${currentFlow}:${currentMethod}`;
                
                if (!methodState.has(key)) {
                    methodState.set(key, {});
                }
                
                methodState.get(key).request = requestObj;
                localStorage.setItem(`request:${key}`, jsonEditor.value);
            } catch (error) {
                console.error('Failed to save request:', error);
            }
        }
        
        // Load a request for the selected method
        function loadRequestForMethod(flowId, methodId) {
            const key = `${flowId}:${methodId}`;
            const defaultRequest = flows[flowId].methods[methodId].defaultRequest;
            
            // Try to load from session storage
            let savedRequest = localStorage.getItem(`request:${key}`);
            
            if (savedRequest) {
                jsonEditor.value = savedRequest;
            } else if (methodState.has(key) && methodState.get(key).request) {
                jsonEditor.value = JSON.stringify(methodState.get(key).request, null, 4);
            } else {
                // Use default
                jsonEditor.value = JSON.stringify(defaultRequest, null, 4);
            }
        }
        
        // Load a saved response for the selected method
        function loadResponseForMethod(flowId, methodId) {
            const key = `${flowId}:${methodId}`;
            
            if (methodState.has(key) && methodState.get(key).response) {
                responseViewer.innerHTML = syntaxHighlightJson(methodState.get(key).response);
                if (methodState.get(key).requestSent) {
                    requestData.textContent = 'Request: ' + JSON.stringify(methodState.get(key).requestSent, null, 2);
                } else {
                    requestData.textContent = '';
                }
                
                // Show communication log if available
                if (methodState.get(key).commLog) {
                    commLog.innerHTML = methodState.get(key).commLog;
                } else {
                    commLog.innerHTML = '';
                }
            } else {
                responseViewer.innerHTML = '<span class="json-null">No response yet.</span>';
                requestData.textContent = '';
                commLog.innerHTML = '';
            }
        }
        
        // Reset request to default
        resetBtn.addEventListener('click', () => {
            if (!currentFlow || !currentMethod) return;
            
            const defaultRequest = flows[currentFlow].methods[currentMethod].defaultRequest;
            jsonEditor.value = JSON.stringify(defaultRequest, null, 4);
            
            // Update the next request ID
            if (defaultRequest.id) {
                defaultRequest.id = requestId++;
                jsonEditor.value = JSON.stringify(defaultRequest, null, 4);
            }
        });
        
        // Clear communication log
        clearLogBtn.addEventListener('click', () => {
            commLog.innerHTML = '';
            
            // Clear the log in the current method state
            if (currentFlow && currentMethod) {
                const key = `${currentFlow}:${currentMethod}`;
                if (methodState.has(key)) {
                    methodState.get(key).commLog = '';
                }
            }
        });
        
        // Connect to WebSocket server
        connectBtn.addEventListener('click', () => {
            const url = serverUrlInput.value.trim();
            
            if (!url) {
                alert('Please enter a WebSocket server URL');
                return;
            }
            
            try {
                socket = new WebSocket(url);
                
                socket.onopen = () => {
                    isConnected = true;
                    statusSpan.textContent = 'Connected';
                    statusSpan.classList.remove('disconnected');
                    statusSpan.classList.add('connected');
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    sendBtn.disabled = false;
                };
                
                socket.onclose = (event) => {
                    isConnected = false;
                    statusSpan.textContent = 'Disconnected';
                    statusSpan.classList.remove('connected');
                    statusSpan.classList.add('disconnected');
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    sendBtn.disabled = true;
                };
                
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
                
                socket.onmessage = (event) => {
                    try {
                        // Calculate response time
                        const responseTimestamp = new Date();
                        const responseTimeStr = responseTimestamp.toLocaleTimeString() + '.' + 
                                               String(responseTimestamp.getMilliseconds()).padStart(3, '0');
                        
                        // Calculate response size
                        const responseSize = new Blob([event.data]).size;
                        
                        const response = JSON.parse(event.data);
                        
                        // Display the response with syntax highlighting
                        responseViewer.innerHTML = syntaxHighlightJson(response);
                        
                        // Update communication log
                        let logEntry = '';
                        if (requestTimestamp) {
                            const elapsed = responseTimestamp - requestTimestamp;
                            logEntry = `[${responseTimeStr}] received response (${responseSize} bytes), latency ${elapsed}ms\n`;
                            commLog.innerHTML += logEntry;
                            
                            // Auto-scroll the log to the bottom
                            commLog.scrollTop = commLog.scrollHeight;
                        }
                        
                        // Save the response and log for the current method
                        if (currentFlow && currentMethod) {
                            const key = `${currentFlow}:${currentMethod}`;
                            
                            if (!methodState.has(key)) {
                                methodState.set(key, {});
                            }
                            
                            methodState.get(key).response = response;
                            methodState.get(key).responseTimestamp = responseTimestamp;
                            methodState.get(key).commLog = commLog.innerHTML;
                        }
                    } catch (error) {
                        // If parse fails, display the raw data
                        responseViewer.innerHTML = `<span class="json-string">${escapeHtml(event.data)}</span>`;
                        console.error('Error parsing JSON response:', error);
                    }
                };
                
            } catch (error) {
                alert(`Failed to connect: ${error.message}`);
                console.error('Connection error:', error);
            }
        });
        
        // Disconnect from WebSocket server
        disconnectBtn.addEventListener('click', () => {
            if (socket) {
                socket.close(1000, 'User initiated disconnect');
                socket = null;
            }
        });
        
        // Send request
        sendBtn.addEventListener('click', () => {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                alert('Not connected to the WebSocket server');
                return;
            }
            
            try {
                const requestJson = jsonEditor.value.trim();
                const requestObj = JSON.parse(requestJson);
                
                // Add an ID if not present and it's not a notification
                if (requestObj.method && requestObj.method !== 'notification' && !requestObj.id) {
                    requestObj.id = requestId++;
                    jsonEditor.value = JSON.stringify(requestObj, null, 4);
                }
                
                // Ensure jsonrpc version is set
                if (!requestObj.jsonrpc) {
                    requestObj.jsonrpc = '2.0';
                    jsonEditor.value = JSON.stringify(requestObj, null, 4);
                }
                
                const request = JSON.stringify(requestObj);
                const requestSize = new Blob([request]).size;
                
                // Record request timestamp
                requestTimestamp = new Date();
                const requestTimeStr = requestTimestamp.toLocaleTimeString() + '.' + 
                                       String(requestTimestamp.getMilliseconds()).padStart(3, '0');
                
                // Add to the communication log
                const logEntry = `[${requestTimeStr}] sending request (${requestSize} bytes)\n`;
                commLog.innerHTML += logEntry;
                
                // Auto-scroll the log to the bottom
                commLog.scrollTop = commLog.scrollHeight;
                
                // Send the request
                socket.send(request);
                
                // Update request display
                requestData.textContent = 'Request: ' + request;
                
                // Save the sent request and timestamp
                if (currentFlow && currentMethod) {
                    const key = `${currentFlow}:${currentMethod}`;
                    
                    if (!methodState.has(key)) {
                        methodState.set(key, {});
                    }
                    
                    methodState.get(key).requestSent = requestObj;
                    methodState.get(key).requestTimestamp = requestTimestamp;
                    methodState.get(key).commLog = commLog.innerHTML;
                }
                
            } catch (error) {
                alert(`Error sending request: ${error.message}`);
                console.error('Send error:', error);
            }
        });
        
        // Load saved state from localStorage
        function loadSavedState() {
            const savedFlow = localStorage.getItem('selected-flow');
            if (savedFlow && flows[savedFlow]) {
                currentFlow = savedFlow;
            }
            
            // For each flow, load saved requests
            Object.keys(flows).forEach(flowId => {
                const flow = flows[flowId];
                Object.keys(flow.methods).forEach(methodId => {
                    const key = `${flowId}:${methodId}`;
                    const savedRequest = localStorage.getItem(`request:${key}`);
                    
                    if (savedRequest) {
                        try {
                            const requestObj = JSON.parse(savedRequest);
                            if (!methodState.has(key)) {
                                methodState.set(key, {});
                            }
                            methodState.get(key).request = requestObj;
                        } catch (error) {
                            console.error(`Failed to parse saved request for ${key}:`, error);
                        }
                    }
                });
            });
        }
        
        // Initialize the UI
        loadSavedState();
        initializeUI();
    </script>
</body>
</html>