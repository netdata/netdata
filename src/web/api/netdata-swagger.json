{
  "openapi": "3.0.0",
  "info": {
    "title": "Netdata API",
    "description": "Real-time performance and health monitoring.\n\n## API Versions\n\nNetdata provides three API versions:\n- **v1**: The original API, focused on single-node operations\n- **v2**: Multi-node API with advanced grouping and aggregation capabilities\n- **v3**: The latest API version that combines v1 and v2 endpoints and may include additional features\n\n### v3 API Endpoints\n\nThe v3 API provides the current, actively maintained endpoints:\n- `/api/v3/data` - Multi-dimensional data queries\n- `/api/v3/weights` - Metric scoring/correlation\n- `/api/v3/contexts` - Context metadata\n- `/api/v3/nodes` - Node information\n- `/api/v3/q` - Full-text search\n- `/api/v3/alerts` - Alert information\n- `/api/v3/alert_transitions` - Alert state transitions\n- `/api/v3/alert_config` - Alert configuration\n- `/api/v3/functions` - Available functions\n- `/api/v3/function` - Execute functions\n- `/api/v3/info` - Agent information\n- `/api/v3/node_instances` - Node instance information\n- `/api/v3/stream_path` - Streaming topology\n- `/api/v3/versions` - Version information\n- `/api/v3/badge.svg` - Dynamic badges\n- `/api/v3/allmetrics` - Export metrics\n- `/api/v3/context` - Single context info\n- `/api/v3/variable` - Variable information\n- `/api/v3/config` - Dynamic configuration\n- `/api/v3/settings` - Agent settings\n- `/api/v3/me` - Current user information\n- `/api/v3/claim` - Agent claiming\n- Additional management and streaming endpoints\n\n**Note:** V1 and V2 APIs are deprecated and maintained for backwards compatibility only. New integrations should use V3 exclusively.\n",
    "version": "v1-rolling",
    "contact": {
      "name": "Netdata Agent API",
      "email": "info@netdata.cloud",
      "url": "https://netdata.cloud"
    },
    "license": {
      "name": "GPL v3+",
      "url": "https://github.com/netdata/netdata/blob/master/LICENSE"
    }
  },
  "servers": [
    {
      "url": "https://registry.my-netdata.io"
    },
    {
      "url": "http://registry.my-netdata.io"
    },
    {
      "url": "http://localhost:19999"
    }
  ],
  "tags": [
    {
      "name": "nodes",
      "description": "Everything related to monitored nodes"
    },
    {
      "name": "charts",
      "description": "Everything related to chart instances - DO NOT USE IN NEW CODE - use contexts instead"
    },
    {
      "name": "contexts",
      "description": "Everything related contexts - in new code, use this instead of charts"
    },
    {
      "name": "data",
      "description": "Everything related to data queries"
    },
    {
      "name": "badges",
      "description": "Everything related to dynamic badges based on metric data"
    },
    {
      "name": "weights",
      "description": "Everything related to scoring / weighting metrics"
    },
    {
      "name": "functions",
      "description": "Everything related to functions"
    },
    {
      "name": "alerts",
      "description": "Everything related to alerts"
    },
    {
      "name": "management",
      "description": "Everything related to managing netdata Agents"
    }
  ],
  "paths": {
    "/api/v2/nodes": {
      "get": {
        "deprecated": true,
        "operationId": "getNodes2",
        "tags": [
          "nodes"
        ],
        "summary": "Nodes Info v2",
        "description": "Get a list of all nodes hosted by this Netdata Agent.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/contextsQueryOptions"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "description": "`/api/v2/nodes` response for all nodes hosted by a Netdata Agent.\n",
                  "type": "object",
                  "properties": {
                    "api": {
                      "$ref": "#/components/schemas/api"
                    },
                    "agents": {
                      "$ref": "#/components/schemas/agents"
                    },
                    "versions": {
                      "$ref": "#/components/schemas/versions"
                    },
                    "nodes": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/nodeFull"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/v3/nodes": {
      "get": {
        "operationId": "getNodes3",
        "tags": [
          "nodes"
        ],
        "summary": "Nodes Info v3",
        "description": "Get a list of all nodes hosted by this Netdata Agent.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/contextsQueryOptions"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "description": "`/api/v3/nodes` response for all nodes hosted by a Netdata Agent.\n",
                  "type": "object",
                  "properties": {
                    "api": {
                      "$ref": "#/components/schemas/api"
                    },
                    "agents": {
                      "$ref": "#/components/schemas/agents"
                    },
                    "versions": {
                      "$ref": "#/components/schemas/versions"
                    },
                    "nodes": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/nodeFull"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/v2/contexts": {
      "get": {
        "deprecated": true,
        "operationId": "getContexts2",
        "tags": [
          "contexts"
        ],
        "summary": "Contexts Info v2",
        "description": "Get a list of all contexts, across all nodes, hosted by this Netdata Agent.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/contextsQueryOptions"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contexts2"
                }
              }
            }
          }
        }
      }
    },
    "/api/v3/contexts": {
      "get": {
        "operationId": "getContexts3",
        "tags": [
          "contexts"
        ],
        "summary": "Contexts Info v3",
        "description": "Get a list of all contexts, across all nodes, hosted by this Netdata Agent.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/contextsQueryOptions"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contexts2"
                }
              }
            }
          }
        }
      }
    },
    "/api/v2/q": {
      "get": {
        "deprecated": true,
        "operationId": "q2",
        "tags": [
          "contexts"
        ],
        "summary": "Full Text Search v2",
        "description": "Get a list of contexts, across all nodes, hosted by this Netdata Agent, matching a string expression\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "q",
            "in": "query",
            "description": "The strings to search for, formatted as a simple pattern",
            "required": true,
            "schema": {
              "type": "string",
              "format": "simple pattern"
            }
          },
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/contextsQueryOptions"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contexts2"
                }
              }
            }
          }
        }
      }
    },
    "/api/v3/q": {
      "get": {
        "operationId": "q3",
        "tags": [
          "contexts"
        ],
        "summary": "Full Text Search v3",
        "description": "Get a list of contexts, across all nodes, hosted by this Netdata Agent, matching a string expression.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "q",
            "in": "query",
            "description": "The strings to search for, formatted as a simple pattern",
            "required": true,
            "schema": {
              "type": "string",
              "format": "simple pattern"
            }
          },
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/contextsQueryOptions"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contexts2"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/info": {
      "get": {
        "deprecated": true,
        "operationId": "getNodeInfo1",
        "tags": [
          "nodes"
        ],
        "summary": "Node Info v1",
        "description": "The info endpoint returns basic information about netdata. It provides:\n* netdata version\n* netdata unique id\n* list of hosts mirrored (includes itself)\n* Operating System, Virtualization, K8s nodes and Container technology information\n* List of active collector plugins and modules\n* Streaming information\n* number of alarms in the host\n  * number of alarms in normal state\n  * number of alarms in warning state\n  * number of alarms in critical state\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "netdata basic information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/info"
                }
              }
            }
          },
          "503": {
            "description": "netdata daemon not ready (used for health checks)."
          }
        }
      }
    },
    "/api/v1/charts": {
      "get": {
        "deprecated": true,
        "operationId": "getNodeCharts1",
        "tags": [
          "charts"
        ],
        "summary": "List all charts v1 - EOL",
        "description": "The charts endpoint returns a summary about all charts stored in the netdata server.\n**Security & Access Control:** - 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply - **Default Access:** Public (no authentication required) - **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token - **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf - **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "An array of charts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/chart_summary"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/chart": {
      "get": {
        "deprecated": true,
        "operationId": "getNodeChart1",
        "tags": [
          "charts"
        ],
        "summary": "Get one chart v1 - EOL",
        "description": "The chart endpoint returns detailed information about a chart.\n**Security & Access Control:** - 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply - **Default Access:** Public (no authentication required) - **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token - **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf - **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/chart"
          }
        ],
        "responses": {
          "200": {
            "description": "A javascript object with detailed information about the chart.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/chart"
                }
              }
            }
          },
          "400": {
            "description": "No chart id was supplied in the request."
          },
          "404": {
            "description": "No chart with the given id is found."
          }
        }
      }
    },
    "/api/v1/contexts": {
      "get": {
        "deprecated": true,
        "operationId": "getNodeContexts1",
        "tags": [
          "contexts"
        ],
        "summary": "Get a list of all node contexts available v1",
        "description": "The contexts endpoint returns a summary about all contexts stored in the netdata server.\n**Security & Access Control:** - 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply - **Default Access:** Public (no authentication required) - **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token - **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf - **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/dimensions"
          },
          {
            "$ref": "#/components/parameters/chart_label_key"
          },
          {
            "$ref": "#/components/parameters/chart_labels_filter"
          },
          {
            "$ref": "#/components/parameters/contextOptions1"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          }
        ],
        "responses": {
          "200": {
            "description": "An array of contexts.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/context_summary"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/context": {
      "get": {
        "deprecated": true,
        "operationId": "getNodeContext1",
        "tags": [
          "contexts"
        ],
        "summary": "Get info about a specific context",
        "description": "The context endpoint returns detailed information about a given context.\nThe `context` parameter is required for this call.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/context"
          },
          {
            "$ref": "#/components/parameters/dimensions"
          },
          {
            "$ref": "#/components/parameters/chart_label_key"
          },
          {
            "$ref": "#/components/parameters/chart_labels_filter"
          },
          {
            "$ref": "#/components/parameters/contextOptions1"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          }
        ],
        "responses": {
          "200": {
            "description": "A javascript object with detailed information about the context.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/context"
                }
              }
            }
          },
          "400": {
            "description": "No context id was supplied in the request."
          },
          "404": {
            "description": "No context with the given id is found."
          }
        }
      }
    },
    "/api/v3/context": {
      "get": {
        "operationId": "getNodeContext3",
        "tags": [
          "contexts"
        ],
        "summary": "Get info about a specific context - Latest API",
        "description": "The context endpoint returns detailed information about a specific monitoring context across all nodes.\n\nThis is the latest version (v3) of the context API. It provides the same functionality as v1 but may include additional features in the future.\n\n**What is a Context?**\nA context is a grouping of charts that monitor the same type of metric across different instances. For example:\n- `system.cpu` - CPU usage (one chart per node)\n- `disk.io` - Disk I/O operations (one chart per disk)\n- `net.packets` - Network packets (one chart per network interface)\n\n**Use Cases:**\n- Get metadata about a specific metric type across all instances and nodes\n- Discover which charts belong to a context\n- Filter charts by labels or dimensions\n- Understand metric families, units, and chart types\n- Build dynamic dashboards that adapt to available instances\n\nThe response includes all charts that belong to the specified context, with their metadata, dimensions, labels, and current availability status.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "context",
            "in": "query",
            "description": "The context identifier to query. This is a required parameter.\n\nA context represents a type of metric collected across multiple instances. Each context groups charts that measure the same thing but for different entities.\n\n**Common Context Examples:**\n- `system.cpu` - CPU utilization metrics\n- `system.ram` - RAM usage metrics\n- `disk.io` - Disk I/O operations\n- `disk.ops` - Disk operation counts\n- `net.packets` - Network packet statistics\n- `net.drops` - Network packet drops\n- `cgroup.cpu` - Container CPU usage\n- `nginx.requests` - Nginx request rates\n\n**Finding Available Contexts:**\nUse the `/api/v3/contexts` endpoint to get a list of all available contexts.\n\n**Alias:** Can also be specified as `ctx` for brevity.\n",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "system.cpu"
          },
          {
            "$ref": "#/components/parameters/dimensions"
          },
          {
            "$ref": "#/components/parameters/chart_label_key"
          },
          {
            "$ref": "#/components/parameters/chart_labels_filter"
          },
          {
            "name": "options",
            "in": "query",
            "description": "Comma or pipe-separated list of options to control the response content and format.\n\n**Available Options:**\n- `full` or `all` - Include all possible information (equivalent to enabling all options below)\n- `charts` - Include the list of charts belonging to this context\n- `dimensions` - Include dimension information for each chart\n- `queue` - Include data collection queue statistics\n- `flags` - Include internal flags and states\n- `labels` - Include chart labels\n- `alerts` - Include alert configurations and states for this context\n\n**Option Combinations:**\nOptions can be combined. For example: `options=charts,dimensions,labels` will include charts with their dimensions and labels.\n\n**Default Behavior:**\nWhen not specified, returns basic context information without detailed chart data.\n\n**Examples:**\n- `options=full` - Complete information\n- `options=charts,dimensions` - Charts with dimension details\n- `options=charts|labels` - Charts with labels (pipe separator)\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "examples": {
              "minimal": {
                "value": "",
                "summary": "Basic context info only"
              },
              "standard": {
                "value": "charts,dimensions",
                "summary": "Charts with dimensions"
              },
              "complete": {
                "value": "full",
                "summary": "All available information"
              }
            }
          },
          {
            "name": "after",
            "in": "query",
            "description": "Return only charts that have collected data after this timestamp.\n\nThis filters charts based on their data collection activity, excluding charts that haven't collected data since the specified time.\n\n**Format:** Unix timestamp in seconds\n\n**Use Cases:**\n- Find recently active charts\n- Exclude stale or obsolete charts\n- Filter charts by collection timeframe\n\n**Example:** `after=1609459200` (charts active after January 1, 2021)\n\nWhen not specified, all charts are included regardless of their last update time.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64"
            },
            "example": 1609459200
          },
          {
            "name": "before",
            "in": "query",
            "description": "Return only charts that have collected data before this timestamp.\n\nThis filters charts based on their data collection activity, excluding charts that only have data after the specified time.\n\n**Format:** Unix timestamp in seconds\n\n**Use Cases:**\n- Historical analysis of chart availability\n- Find charts that were active during a specific time period\n- Exclude newer charts from results\n\n**Example:** `before=1640995200` (charts active before January 1, 2022)\n\nWhen combined with `after`, you can specify an exact time window:\n`after=1609459200&before=1640995200` (charts active during 2021)\n\nWhen not specified, all charts are included regardless of their collection timeline.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64"
            },
            "example": 1640995200
          }
        ],
        "responses": {
          "200": {
            "description": "Success. Returns detailed information about the requested context.\n\nThe response is a JSON object containing:\n- Context metadata (name, title, family, units, chart type)\n- List of charts belonging to this context (when options=charts)\n- Dimension information (when options=dimensions)\n- Chart labels (when options=labels)\n- Alert configurations (when options=alerts)\n- Collection statistics (when options=queue)\n\n**Response Structure:**\nThe exact structure depends on the options parameter. With `options=full`, you get complete information including all charts, their dimensions, labels, and current states.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/context"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Missing required 'context' parameter\n- Invalid parameter values\n- Malformed filter patterns\n"
          },
          "404": {
            "description": "Not found. The specified context does not exist on this Netdata agent.\n\nThis can occur when:\n- The context name is misspelled\n- The context is not being collected on this agent\n- The context was available but is now obsolete\n"
          },
          "500": {
            "description": "Internal server error. Usually indicates the server is out of memory."
          }
        }
      }
    },
    "/api/v1/config": {
      "get": {
        "deprecated": true,
        "operationId": "getConfig",
        "tags": [
          "dyncfg"
        ],
        "description": "Get dynamic configuration information.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "description": "The type of information required",
            "schema": {
              "type": "string",
              "enum": [
                "tree",
                "schema",
                "get",
                "enable",
                "disable",
                "restart"
              ],
              "default": "tree"
            }
          },
          {
            "name": "id",
            "in": "query",
            "description": "The ID of the dynamic configuration entity",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "path",
            "in": "query",
            "description": "Top level path of the configuration entities, used with action 'tree'",
            "schema": {
              "type": "string",
              "default": "/"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "The timeout in seconds",
            "schema": {
              "type": "number",
              "default": 120
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The call was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/config_default_response"
                    },
                    {
                      "$ref": "#/components/schemas/config_tree"
                    },
                    {
                      "$ref": "#/components/schemas/config_schema"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "Something is wrong with the request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_default_response"
                }
              }
            }
          },
          "404": {
            "description": "The configurable entity requests is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_default_response"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "postConfig",
        "tags": [
          "dyncfg"
        ],
        "description": "Post dynamic configuration to Netdata.\n",
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "description": "The type of action required.",
            "schema": {
              "type": "string",
              "enum": [
                "add",
                "test",
                "update"
              ]
            }
          },
          {
            "name": "id",
            "in": "query",
            "description": "The ID of the dynamic configuration entity to configure.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Name of the dynamic configuration entity, used with action 'add'",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "The timeout in seconds",
            "schema": {
              "type": "number",
              "default": 120
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The call was successful. This also means the configuration is currently running.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_default_response"
                }
              }
            }
          },
          "202": {
            "description": "The call was successful. The configuration has been accepted, but its status is not yet known.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_default_response"
                }
              }
            }
          },
          "299": {
            "description": "The call was successful. The configuration has been accepted, but a restart is required to apply it.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_default_response"
                }
              }
            }
          },
          "400": {
            "description": "Something is wrong with the request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_default_response"
                }
              }
            }
          },
          "404": {
            "description": "The configurable entity requests is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/config_default_response"
                }
              }
            }
          }
        }
      }
    },
    "/api/v2/data": {
      "get": {
        "deprecated": true,
        "operationId": "dataQuery2",
        "tags": [
          "data"
        ],
        "summary": "Data Query v2",
        "description": "Multi-node, multi-context, multi-instance, multi-dimension data queries, with time and metric aggregation.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "group_by",
            "in": "query",
            "description": "A comma separated list of the groupings required.\nAll possible values can be combined together, except `selected`. If `selected` is given in the list, all others are ignored.\nThe order they are placed in the list is currently ignored.\nThis parameter is also accepted as `group_by[0]` and `group_by[1]` when multiple grouping passes are required.\n",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "dimension",
                  "instance",
                  "percentage-of-instance",
                  "label",
                  "node",
                  "context",
                  "units",
                  "selected"
                ]
              },
              "default": [
                "dimension"
              ]
            }
          },
          {
            "name": "group_by_label",
            "in": "query",
            "description": "A comma separated list of the label keys to group by their values. The order of the labels in the list is respected.\nThis parameter is also accepted as `group_by_label[0]` and `group_by_label[1]` when multiple grouping passes are required.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "comma separated list of label keys to group by",
              "default": ""
            }
          },
          {
            "name": "aggregation",
            "in": "query",
            "description": "The aggregation function to apply when grouping metrics together.\nWhen option `raw` is given, `average` and `avg` behave like `sum` and the caller is expected to calculate the average.\nThis parameter is also accepted as `aggregation[0]` and `aggregation[1]` when multiple grouping passes are required.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "min",
                "max",
                "avg",
                "average",
                "sum",
                "percentage",
                "extremes"
              ],
              "default": "average"
            }
          },
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/scopeInstances"
          },
          {
            "$ref": "#/components/parameters/scopeLabels"
          },
          {
            "$ref": "#/components/parameters/scopeDimensions"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/filterInstances"
          },
          {
            "$ref": "#/components/parameters/filterLabels"
          },
          {
            "$ref": "#/components/parameters/filterAlerts"
          },
          {
            "$ref": "#/components/parameters/filterDimensions"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/points"
          },
          {
            "$ref": "#/components/parameters/tier"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup2"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroupOptions2"
          },
          {
            "$ref": "#/components/parameters/dataTimeResampling2"
          },
          {
            "$ref": "#/components/parameters/dataFormat2"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/callback"
          },
          {
            "$ref": "#/components/parameters/filename"
          },
          {
            "$ref": "#/components/parameters/tqx"
          }
        ],
        "responses": {
          "200": {
            "description": "The call was successful. The response includes the data in the format requested.\n",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/jsonwrap2"
                    },
                    {
                      "$ref": "#/components/schemas/data_json_formats2"
                    }
                  ]
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "according to the format requested."
                }
              },
              "text/html": {
                "schema": {
                  "type": "string",
                  "format": "html"
                }
              },
              "application/x-javascript": {
                "schema": {
                  "type": "string",
                  "format": "javascript"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - the body will include a message stating what is wrong.\n"
          },
          "500": {
            "description": "Internal server error. This usually means the server is out of memory.\n"
          }
        }
      }
    },
    "/api/v3/data": {
      "get": {
        "operationId": "dataQuery3",
        "tags": [
          "data"
        ],
        "summary": "Data Query v3",
        "description": "Multi-node, multi-context, multi-instance, multi-dimension data queries, with time and metric aggregation.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "group_by",
            "in": "query",
            "description": "A comma separated list of the groupings required.\nAll possible values can be combined together, except `selected`. If `selected` is given in the list, all others are ignored.\nThe order they are placed in the list is currently ignored.\nThis parameter is also accepted as `group_by[0]` and `group_by[1]` when multiple grouping passes are required.\n",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "dimension",
                  "instance",
                  "percentage-of-instance",
                  "label",
                  "node",
                  "context",
                  "units",
                  "selected"
                ]
              },
              "default": [
                "dimension"
              ]
            }
          },
          {
            "name": "group_by_label",
            "in": "query",
            "description": "A comma separated list of the label keys to group by their values. The order of the labels in the list is respected.\nThis parameter is also accepted as `group_by_label[0]` and `group_by_label[1]` when multiple grouping passes are required.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "comma separated list of label keys to group by",
              "default": ""
            }
          },
          {
            "name": "aggregation",
            "in": "query",
            "description": "The aggregation function to apply when grouping metrics together.\nWhen option `raw` is given, `average` and `avg` behave like `sum` and the caller is expected to calculate the average.\nThis parameter is also accepted as `aggregation[0]` and `aggregation[1]` when multiple grouping passes are required.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "min",
                "max",
                "avg",
                "average",
                "sum",
                "percentage",
                "extremes"
              ],
              "default": "average"
            }
          },
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/scopeInstances"
          },
          {
            "$ref": "#/components/parameters/scopeLabels"
          },
          {
            "$ref": "#/components/parameters/scopeDimensions"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/filterInstances"
          },
          {
            "$ref": "#/components/parameters/filterLabels"
          },
          {
            "$ref": "#/components/parameters/filterAlerts"
          },
          {
            "$ref": "#/components/parameters/filterDimensions"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/points"
          },
          {
            "$ref": "#/components/parameters/tier"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup2"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroupOptions2"
          },
          {
            "$ref": "#/components/parameters/dataTimeResampling2"
          },
          {
            "$ref": "#/components/parameters/dataFormat2"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/callback"
          },
          {
            "$ref": "#/components/parameters/filename"
          },
          {
            "$ref": "#/components/parameters/tqx"
          }
        ],
        "responses": {
          "200": {
            "description": "The call was successful. The response includes the data in the format requested.\n",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/jsonwrap2"
                    },
                    {
                      "$ref": "#/components/schemas/data_json_formats2"
                    }
                  ]
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "according to the format requested."
                }
              },
              "text/html": {
                "schema": {
                  "type": "string",
                  "format": "html"
                }
              },
              "application/x-javascript": {
                "schema": {
                  "type": "string",
                  "format": "javascript"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - the body will include a message stating what is wrong.\n"
          },
          "500": {
            "description": "Internal server error. This usually means the server is out of memory.\n"
          }
        }
      }
    },
    "/api/v1/data": {
      "get": {
        "deprecated": true,
        "operationId": "dataQuery1",
        "tags": [
          "data"
        ],
        "summary": "Data Query v1 - Single node, single chart or context queries. without group-by.",
        "description": "Query metric data of a chart or context of a node and return a dataset having time-series data for all dimensions available.\nFor group-by functionality, use `/api/v2/data`.\nAt least a `chart` or a `context` have to be given for the data query to be executed.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/chart"
          },
          {
            "$ref": "#/components/parameters/context"
          },
          {
            "$ref": "#/components/parameters/dimension"
          },
          {
            "$ref": "#/components/parameters/chart_label_key"
          },
          {
            "$ref": "#/components/parameters/chart_labels_filter"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/points"
          },
          {
            "$ref": "#/components/parameters/tier"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/dataFormat1"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup1"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroupOptions1"
          },
          {
            "$ref": "#/components/parameters/dataTimeResampling1"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/callback"
          },
          {
            "$ref": "#/components/parameters/filename"
          },
          {
            "$ref": "#/components/parameters/tqx"
          }
        ],
        "responses": {
          "200": {
            "description": "The call was successful. The response includes the data in the format requested.\n",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/jsonwrap1"
                    },
                    {
                      "$ref": "#/components/schemas/data_json_formats1"
                    }
                  ]
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "according to the format requested."
                }
              },
              "text/html": {
                "schema": {
                  "type": "string",
                  "format": "html"
                }
              },
              "application/x-javascript": {
                "schema": {
                  "type": "string",
                  "format": "javascript"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - the body will include a message stating what is wrong."
          },
          "404": {
            "description": "Chart or context is not found. The supplied chart or context will be reported."
          },
          "500": {
            "description": "Internal server error. This usually means the server is out of memory."
          }
        }
      }
    },
    "/api/v1/allmetrics": {
      "get": {
        "deprecated": true,
        "operationId": "allMetrics1",
        "tags": [
          "data"
        ],
        "summary": "All Metrics v1 - Fetch latest value for all metrics",
        "description": "The `allmetrics` endpoint returns the latest value of all metrics maintained for a netdata node.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "format",
            "in": "query",
            "description": "The format of the response to be returned.",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "shell",
                "prometheus",
                "prometheus_all_hosts",
                "json"
              ],
              "default": "shell"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "Allows to filter charts out using simple patterns.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "any text"
            }
          },
          {
            "name": "variables",
            "in": "query",
            "description": "When enabled, netdata will expose various system configuration variables.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no"
              ],
              "default": "no"
            }
          },
          {
            "name": "timestamps",
            "in": "query",
            "description": "Enable or disable timestamps in prometheus output.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no"
              ],
              "default": "yes"
            }
          },
          {
            "name": "names",
            "in": "query",
            "description": "When enabled netdata will report dimension names. When disabled netdata will report dimension IDs. The default is controlled in netdata.conf.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no"
              ],
              "default": "yes"
            }
          },
          {
            "name": "oldunits",
            "in": "query",
            "description": "When enabled, netdata will show metric names for the default `source=average` as they appeared before 1.12, by using the legacy unit naming conventions.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no"
              ],
              "default": "yes"
            }
          },
          {
            "name": "hideunits",
            "in": "query",
            "description": "When enabled, netdata will not include the units in the metric names, for the default `source=average`.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no"
              ],
              "default": "yes"
            }
          },
          {
            "name": "server",
            "in": "query",
            "description": "Set a distinct name of the client querying prometheus metrics. Netdata will use the client IP if this is not set.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "any text"
            }
          },
          {
            "name": "prefix",
            "in": "query",
            "description": "Prefix all prometheus metrics with this string.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "any text"
            }
          },
          {
            "name": "data",
            "in": "query",
            "description": "Select the prometheus response data source. There is a setting in netdata.conf for the default.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "as-collected",
                "average",
                "sum"
              ],
              "default": "average"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "All the metrics returned in the format requested."
          },
          "400": {
            "description": "The format requested is not supported."
          }
        }
      }
    },
    "/api/v1/badge.svg": {
      "get": {
        "deprecated": true,
        "operationId": "badge1",
        "tags": [
          "badges"
        ],
        "summary": "Generate a badge in form of SVG image for a chart (or dimension)",
        "description": "Successful responses are SVG images.\n**Security & Access Control:** - 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply - **Default Access:** Public (no authentication required) - **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token - **IP Restrictions:** Subject to `allow badges from` in netdata.conf - **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/chart"
          },
          {
            "$ref": "#/components/parameters/dimension"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup1"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "name": "alarm",
            "in": "query",
            "description": "The name of an alarm linked to the chart.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string",
              "format": "any text"
            }
          },
          {
            "name": "label",
            "in": "query",
            "description": "A text to be used as the label.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string",
              "format": "any text"
            }
          },
          {
            "name": "units",
            "in": "query",
            "description": "A text to be used as the units.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string",
              "format": "any text"
            }
          },
          {
            "name": "label_color",
            "in": "query",
            "description": "A color to be used for the background of the label side(left side) of the badge. One of predefined colors or specific color in hex `RGB` or `RRGGBB` format (without preceding `#` character). If value wrong or not given default color will be used.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "green",
                    "brightgreen",
                    "yellow",
                    "yellowgreen",
                    "orange",
                    "red",
                    "blue",
                    "grey",
                    "gray",
                    "lightgrey",
                    "lightgray"
                  ]
                },
                {
                  "type": "string",
                  "format": "^([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$"
                }
              ]
            }
          },
          {
            "name": "value_color",
            "in": "query",
            "description": "A color to be used for the background of the value *(right)* part of badge. You can set multiple using a pipe with a condition each, like this: `color<value|color:null` The following operators are supported: >, <, >=, <=, =, :null (to check if no value exists). Each color can be specified in same manner as for `label_color` parameter. Currently only integers are supported as values.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string",
              "format": "any text"
            }
          },
          {
            "name": "text_color_lbl",
            "in": "query",
            "description": "Font color for label *(left)* part of the badge. One of predefined colors or as HTML hexadecimal color without preceding `#` character. Formats allowed `RGB` or `RRGGBB`. If no or wrong value given default color will be used.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "green",
                    "brightgreen",
                    "yellow",
                    "yellowgreen",
                    "orange",
                    "red",
                    "blue",
                    "grey",
                    "gray",
                    "lightgrey",
                    "lightgray"
                  ]
                },
                {
                  "type": "string",
                  "format": "^([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$"
                }
              ]
            }
          },
          {
            "name": "text_color_val",
            "in": "query",
            "description": "Font color for value *(right)* part of the badge. One of predefined colors or as HTML hexadecimal color without preceding `#` character. Formats allowed `RGB` or `RRGGBB`. If no or wrong value given default color will be used.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "green",
                    "brightgreen",
                    "yellow",
                    "yellowgreen",
                    "orange",
                    "red",
                    "blue",
                    "grey",
                    "gray",
                    "lightgrey",
                    "lightgray"
                  ]
                },
                {
                  "type": "string",
                  "format": "^([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$"
                }
              ]
            }
          },
          {
            "name": "multiply",
            "in": "query",
            "description": "Multiply the value with this number for rendering it at the image (integer value required).",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "number",
              "format": "integer"
            }
          },
          {
            "name": "divide",
            "in": "query",
            "description": "Divide the value with this number for rendering it at the image (integer value required).",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "number",
              "format": "integer"
            }
          },
          {
            "name": "scale",
            "in": "query",
            "description": "Set the scale of the badge (greater or equal to 100).",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "number",
              "format": "integer"
            }
          },
          {
            "name": "fixed_width_lbl",
            "in": "query",
            "description": "This parameter overrides auto-sizing of badge and creates it with fixed width. This parameter determines the size of the label's left side *(label/name)*. You must set this parameter together with `fixed_width_val` otherwise it will be ignored. You should set the label/value widths wide enough to provide space for all the possible values/contents of the badge you're requesting. In case the text cannot fit the space given it will be clipped. The `scale` parameter still applies on the values you give to `fixed_width_lbl` and `fixed_width_val`.\n",
            "required": false,
            "allowEmptyValue": false,
            "schema": {
              "type": "number",
              "format": "integer"
            }
          },
          {
            "name": "fixed_width_val",
            "in": "query",
            "description": "This parameter overrides auto-sizing of badge and creates it with fixed width. This parameter determines the size of the label's right side *(value)*. You must set this parameter together with `fixed_width_lbl` otherwise it will be ignored. You should set the label/value widths wide enough to provide space for all the possible values/contents of the badge you're requesting. In case the text cannot fit the space given it will be clipped. The `scale` parameter still applies on the values you give to `fixed_width_lbl` and `fixed_width_val`.\n",
            "required": false,
            "allowEmptyValue": false,
            "schema": {
              "type": "number",
              "format": "integer"
            }
          },
          {
            "name": "points",
            "in": "query",
            "description": "The number of points to use for the calculation. Default is 1.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "group_options",
            "in": "query",
            "description": "Additional options for the grouping function.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "precision",
            "in": "query",
            "description": "Number of decimal places to show in the value. Default is -1 (automatic).",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "integer",
              "default": -1
            }
          },
          {
            "name": "refresh",
            "in": "query",
            "description": "Auto-refresh interval in seconds. Use \"auto\" to automatically determine refresh interval based on the time range or alarm update frequency. For alarms, defaults to the alarm's update_every. For charts with RRDR_OPTION_NOT_ALIGNED, defaults to the chart's update_every. Otherwise calculated from the time range (before - after).\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "auto"
                  ]
                },
                {
                  "type": "integer",
                  "minimum": 0
                }
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The call was successful. The response should be an SVG image."
          },
          "400": {
            "description": "Bad request - the body will include a message stating what is wrong."
          },
          "404": {
            "description": "No chart with the given id is found."
          },
          "500": {
            "description": "Internal server error. This usually means the server is out of memory."
          }
        }
      }
    },
    "/api/v3/badge.svg": {
      "get": {
        "operationId": "badge3",
        "tags": [
          "badges"
        ],
        "summary": "Generate a badge in form of SVG image for a chart (or dimension) - Latest API",
        "description": "Generates an SVG badge displaying real-time metric values from Netdata charts or alarms.\nThis is the latest version (v3) of the badge API. It provides the same functionality as v1 but may include additional features in the future.\n\nThe badge can display:\n- Current value of a chart dimension\n- Current status and value of an alarm\n- Custom labels and units\n- Dynamic colors based on value thresholds or alarm status\n\nSuccessful responses are SVG images that can be embedded in web pages or documentation.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow badges from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/chart"
          },
          {
            "$ref": "#/components/parameters/dimension"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup1"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "name": "alarm",
            "in": "query",
            "description": "The name of an alarm linked to the chart. When specified, the badge will display the alarm's current value and use alarm status for color selection.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "label",
            "in": "query",
            "description": "Custom text to use as the badge label (left side). If not specified:\n- For alarms: uses the alarm name (with underscores replaced by spaces)\n- For dimensions: uses the dimension name\n- Otherwise: uses the chart name\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "units",
            "in": "query",
            "description": "Custom text to use as the units suffix. If not specified:\n- For alarms: uses the alarm's configured units or empty string\n- For percentage queries: uses \"%\"\n- Otherwise: uses the chart's units\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "label_color",
            "in": "query",
            "description": "Background color for the label (left) side of the badge. Can be:\n- One of the predefined color names\n- Hex RGB format (3 digits): e.g., \"f00\" for red\n- Hex RRGGBB format (6 digits): e.g., \"ff0000\" for red\nNote: Do not include the '#' character. If value is invalid, default color will be used.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "green",
                    "brightgreen",
                    "yellow",
                    "yellowgreen",
                    "orange",
                    "red",
                    "blue",
                    "grey",
                    "gray",
                    "lightgrey",
                    "lightgray"
                  ]
                },
                {
                  "type": "string",
                  "format": "^([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$"
                }
              ]
            }
          },
          {
            "name": "value_color",
            "in": "query",
            "description": "Background color for the value (right) side of the badge. Supports conditional coloring based on the value.\n\nCan be specified as:\n- Simple color: Same format as label_color\n- Conditional: Multiple color rules separated by pipe (|), each with format: `color<operator>value`\n\nSupported operators:\n- `>`: greater than\n- `<`: less than\n- `>=`: greater than or equal\n- `<=`: less than or equal\n- `=`: equal to\n- `:null`: true when no value exists\n\nExample: `green<80|yellow<95|red` (green if value < 80, yellow if < 95, otherwise red)\n\nNote: Currently only integers are supported as values. Colors follow same format as label_color.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "text_color_lbl",
            "in": "query",
            "description": "Font color for the label (left) side text. Can be:\n- One of the predefined color names\n- Hex RGB or RRGGBB format without '#' character\nIf not specified or invalid, default color will be used.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "green",
                    "brightgreen",
                    "yellow",
                    "yellowgreen",
                    "orange",
                    "red",
                    "blue",
                    "grey",
                    "gray",
                    "lightgrey",
                    "lightgray"
                  ]
                },
                {
                  "type": "string",
                  "format": "^([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$"
                }
              ]
            }
          },
          {
            "name": "text_color_val",
            "in": "query",
            "description": "Font color for the value (right) side text. Can be:\n- One of the predefined color names\n- Hex RGB or RRGGBB format without '#' character\nIf not specified or invalid, default color will be used.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "green",
                    "brightgreen",
                    "yellow",
                    "yellowgreen",
                    "orange",
                    "red",
                    "blue",
                    "grey",
                    "gray",
                    "lightgrey",
                    "lightgray"
                  ]
                },
                {
                  "type": "string",
                  "format": "^([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$"
                }
              ]
            }
          },
          {
            "name": "multiply",
            "in": "query",
            "description": "Multiply the displayed value by this number before rendering. Integer value required.\nUseful for unit conversions or scaling. Default is 1.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "divide",
            "in": "query",
            "description": "Divide the displayed value by this number before rendering. Integer value required.\nUseful for unit conversions or scaling. Default is 1.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "scale",
            "in": "query",
            "description": "Scale factor for the badge size as a percentage. Must be >= 100.\n- 100 = normal size (default)\n- 150 = 1.5x larger\n- 200 = 2x larger\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "integer",
              "minimum": 100,
              "default": 100
            }
          },
          {
            "name": "fixed_width_lbl",
            "in": "query",
            "description": "Fixed width for the label (left) side in pixels. Must be used together with `fixed_width_val`.\n\nThis overrides automatic sizing and creates a badge with fixed dimensions. Ensure the width is sufficient for your content - text that doesn't fit will be clipped.\n\nThe `scale` parameter still applies to these fixed width values.\n",
            "required": false,
            "allowEmptyValue": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "fixed_width_val",
            "in": "query",
            "description": "Fixed width for the value (right) side in pixels. Must be used together with `fixed_width_lbl`.\n\nThis overrides automatic sizing and creates a badge with fixed dimensions. Ensure the width is sufficient for your content - text that doesn't fit will be clipped.\n\nThe `scale` parameter still applies to these fixed width values.\n",
            "required": false,
            "allowEmptyValue": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "name": "points",
            "in": "query",
            "description": "Number of data points to use for the calculation. Default is 1.\nHigher values provide averaging over more samples.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "integer",
              "default": 1
            }
          },
          {
            "name": "group_options",
            "in": "query",
            "description": "Additional options for the time-series grouping function. Format depends on the selected group method.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "precision",
            "in": "query",
            "description": "Number of decimal places to display in the value.\n- Positive number: exact decimal places (e.g., 2 = \"12.34\")\n- -1 (default): automatic precision based on value magnitude\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "integer",
              "default": -1
            }
          },
          {
            "name": "refresh",
            "in": "query",
            "description": "Auto-refresh interval for the badge. Can be:\n- \"auto\": Automatically determine refresh based on context\n  - For alarms: uses the alarm's update_every interval\n  - For non-aligned charts: uses the chart's update_every\n  - For time-range queries: uses the query time span\n- Integer: Specific refresh interval in seconds\n\nWhen refresh is set, the response includes a Refresh HTTP header.\n",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "oneOf": [
                {
                  "type": "string",
                  "enum": [
                    "auto"
                  ]
                },
                {
                  "type": "integer",
                  "minimum": 0
                }
              ]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success. The response is an SVG image that can be embedded in HTML or Markdown.\n\nWhen refresh parameter is set, the response includes:\n- Refresh header with the interval\n- Appropriate Cache-Control headers\n",
            "content": {
              "image/svg+xml": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The response body contains an error message explaining what is wrong.\nCommon causes:\n- Missing required 'chart' parameter\n- Invalid parameter values\n"
          },
          "404": {
            "description": "Not found. Possible causes:\n- Chart with the specified ID does not exist\n- Specified alarm does not exist on the chart\n"
          },
          "500": {
            "description": "Internal server error. Usually indicates the server is out of memory."
          }
        }
      }
    },
    "/api/v3/allmetrics": {
      "get": {
        "operationId": "allMetrics3",
        "tags": [
          "data"
        ],
        "summary": "All Metrics v3 - Export all metrics in various formats - Latest API",
        "description": "The `allmetrics` endpoint exports the latest values of all metrics collected by Netdata in various formats suitable for integration with external monitoring systems, shell scripts, or APIs.\n\nThis is the latest version (v3) of the allmetrics API. It provides the same functionality as v1 but may include additional features in the future.\n\n**Supported Export Formats:**\n- **shell**: Bash-compatible variable assignments for scripting (NETDATA_CHARTNAME_DIMENSIONNAME=\"value\")\n- **prometheus**: Prometheus exposition format for a single host\n- **prometheus_all_hosts**: Prometheus format including metrics from all child nodes\n- **json**: JSON format with full chart and dimension metadata\n\n**Use Cases:**\n- Integration with Prometheus or other metric collectors\n- Shell script automation and monitoring\n- Custom metric exporters\n- Multi-host metric aggregation\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "format",
            "in": "query",
            "description": "The export format for the metrics. Required parameter.\n\n**Formats:**\n- `shell`: Bash variables (default) - Exports as NETDATA_CHARTNAME_DIMENSIONNAME=\"value\"\n- `prometheus`: Prometheus format (single host) - Compatible with Prometheus scraping\n- `prometheus_all_hosts`: Prometheus format (all hosts) - Includes metrics from child nodes with host labels\n- `json`: JSON format - Full metadata including chart names, families, contexts, units, and timestamps\n\n**Format Details:**\n- Shell format includes alarm status variables (NETDATA_ALARM_CHART_ALARM_STATUS, NETDATA_ALARM_CHART_ALARM_VALUE)\n- Prometheus formats respect Prometheus metric naming conventions\n- JSON format provides complete chart and dimension information\n",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "shell",
                "prometheus",
                "prometheus_all_hosts",
                "json"
              ],
              "default": "shell"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "Simple pattern filter to include only specific charts. Uses Netdata simple pattern matching.\n\n**Pattern Syntax:**\n- Exact match: `system.cpu`\n- Wildcard: `system.*` (all system charts)\n- Multiple patterns: `system.* disk.*` (space-separated)\n- Negation: `!system.cpu` (exclude specific chart)\n\nWhen not specified, all charts are exported.\n\n**Examples:**\n- `system.*` - Export only system charts\n- `disk.* net.*` - Export disk and network charts\n- `* !*.mdstat` - Export all except mdstat charts\n",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "variables",
            "in": "query",
            "description": "**Prometheus format only**: Include or exclude system configuration variables in the output.\n\nWhen enabled (yes/1/true), Netdata exposes various system configuration variables as Prometheus metrics. This includes:\n- Netdata configuration parameters\n- System environment information\n- Collection plugin states\n\nNote: Only affects Prometheus format output. Ignored for shell and json formats.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no",
                "1",
                "0",
                "true",
                "false"
              ],
              "default": "no"
            }
          },
          {
            "name": "timestamps",
            "in": "query",
            "description": "**Prometheus format only**: Include or exclude timestamps in Prometheus metrics.\n\nWhen enabled (default), each metric includes a timestamp of when it was collected.\nWhen disabled, metrics are exported without timestamps (Prometheus will use scrape time).\n\nNote: Only affects Prometheus format output. Ignored for shell and json formats.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no",
                "1",
                "0",
                "true",
                "false"
              ],
              "default": "yes"
            }
          },
          {
            "name": "names",
            "in": "query",
            "description": "**Prometheus format only**: Use dimension names vs IDs in metric names.\n\nWhen enabled (default), Prometheus metrics use human-readable dimension names.\nWhen disabled, metrics use dimension IDs (which never change).\n\n**Example:**\n- names=yes: `netdata_system_cpu_percentage_average{dimension=\"user\"}`\n- names=no: `netdata_system_cpu_percentage_average{dimension=\"user\"}`\n\nThe default is controlled by the global Netdata configuration. This parameter allows per-request override.\n\nNote: Only affects Prometheus format output.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no",
                "1",
                "0",
                "true",
                "false"
              ]
            }
          },
          {
            "name": "oldunits",
            "in": "query",
            "description": "**Prometheus format only**: Use legacy unit naming conventions (pre-1.12 format).\n\nWhen enabled, metric names for `source=average` use the old unit naming conventions as they appeared before Netdata version 1.12.\n\nThis is provided for backward compatibility with existing Prometheus configurations.\n\nNote: Only affects Prometheus format with source=average.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no",
                "1",
                "0",
                "true",
                "false"
              ],
              "default": "no"
            }
          },
          {
            "name": "hideunits",
            "in": "query",
            "description": "**Prometheus format only**: Exclude units from metric names for source=average.\n\nWhen enabled, units are not included in the Prometheus metric names for the default `source=average` data.\n\n**Example:**\n- hideunits=no: `netdata_system_cpu_percentage_average`\n- hideunits=yes: `netdata_system_cpu_average`\n\nNote: Only affects Prometheus format with source=average.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "yes",
                "no",
                "1",
                "0",
                "true",
                "false"
              ],
              "default": "no"
            }
          },
          {
            "name": "server",
            "in": "query",
            "description": "**Prometheus format only**: Set a custom identifier for the client scraping the metrics.\n\nThis parameter is used to identify the client in Prometheus metric labels. If not specified, Netdata uses the client's IP address.\n\nUseful when multiple Prometheus instances scrape the same Netdata agent, or when scraping through a proxy.\n\n**Example:** `server=prometheus-prod-1`\n\nNote: Only affects Prometheus format output. This value appears in metric labels to distinguish scraping sources.\n",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "prefix",
            "in": "query",
            "description": "**Prometheus format only**: Prefix all Prometheus metric names with a custom string.\n\nUseful for namespacing metrics when aggregating from multiple sources or to comply with organizational metric naming conventions.\n\n**Example:** `prefix=mycompany_` produces metrics like `mycompany_system_cpu_percentage_average`\n\nThe default prefix is controlled by the global Netdata configuration. This parameter allows per-request override.\n\nNote: Only affects Prometheus format output.\n",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "data",
            "in": "query",
            "description": "**Prometheus format only**: Select the data source/aggregation method for Prometheus metrics.\n\n**Options:**\n- `as-collected`: Raw values as collected by data collection plugins (no aggregation)\n- `average`: Average values over the collection interval (default)\n- `sum`: Sum of values over the collection interval\n\nThe `as-collected` source provides the most recent raw sample, while `average` and `sum` provide values aggregated over the chart's update interval.\n\nThe default is controlled by the global Netdata exporting configuration. This parameter allows per-request override.\n\n**Use Cases:**\n- `as-collected`: For counter metrics that Prometheus will rate()\n- `average`: For gauge metrics showing typical values\n- `sum`: For accumulating metrics\n\nAliases: `source`, `data source`, `data-source`, `data_source`, `datasource`\n\nNote: Only affects Prometheus format output.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "as-collected",
                "average",
                "sum"
              ],
              "default": "average"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success. Metrics exported in the requested format.\n\n**Content Types:**\n- shell: text/plain\n- json: application/json\n- prometheus/prometheus_all_hosts: application/openmetrics-text (Prometheus format)\n\n**Response Characteristics:**\n- Shell format: Variables ready for sourcing in bash scripts\n- JSON format: Complete chart metadata with current values\n- Prometheus format: Ready for Prometheus scraping\n\nThe response is not cacheable as it contains current metric values.\n",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "description": "Shell format output (when format=shell)"
                }
              },
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "JSON format output (when format=json)"
                }
              },
              "application/openmetrics-text": {
                "schema": {
                  "type": "string",
                  "description": "Prometheus format output (when format=prometheus or prometheus_all_hosts)"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The response body contains an error message.\n\nCommon causes:\n- Invalid or missing 'format' parameter\n- Unsupported format value\n- Invalid filter pattern syntax\n"
          },
          "500": {
            "description": "Internal server error. Usually indicates the server is out of memory or a collection plugin has crashed."
          }
        }
      }
    },
    "/api/v3/alerts": {
      "get": {
        "operationId": "alerts3",
        "tags": [
          "alerts"
        ],
        "summary": "Current Alert Status - Multi-node Alert Information - Latest API",
        "description": "Returns the current status of all alerts across all nodes monitored by this Netdata agent.\n\nThis is the latest version (v3) of the alerts API. It provides the same functionality as v2 but may include additional features in the future.\n\n**What This API Provides:**\n- Current state of all active, warning, and critical alerts\n- Alert values and thresholds\n- Alert configuration summaries\n- Multi-node alert aggregation\n- Filtering by alert name, context, node, or status\n\n**Use Cases:**\n- Dashboard alert widgets showing current system health\n- Alert management interfaces\n- Integration with external alerting systems\n- Monitoring alert coverage across infrastructure\n- Finding all alerts in specific states (warning/critical)\n\n**Response Content:**\nThe response includes comprehensive information about alerts including their current values, configured thresholds, time in current state, and associated context/chart information.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "name": "alert",
            "in": "query",
            "description": "Filter alerts by alert name pattern. Uses Netdata simple pattern matching.\n\n**Pattern Syntax:**\n- Exact match: `cpu_usage`\n- Wildcard: `cpu_*` (all CPU-related alerts)\n- Multiple patterns: `cpu_* ram_*` (space-separated)\n- Negation: `!cpu_usage` (all except this alert)\n\n**Common Alert Names:**\n- `ram_in_use` - RAM utilization\n- `disk_space_usage` - Disk space\n- `10min_cpu_usage` - CPU usage over 10 minutes\n- `tcp_listen_overflows` - TCP connection queue overflows\n- `disk_backlog` - Disk I/O backlog\n\nWhen not specified, all alerts are included.\n\n**Examples:**\n- `alert=ram_in_use` - Only RAM usage alert\n- `alert=*cpu*` - All CPU-related alerts\n- `alert=* !*_critical` - All alerts except those ending with _critical\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "examples": {
              "single": {
                "value": "ram_in_use",
                "summary": "Single alert"
              },
              "pattern": {
                "value": "*cpu*",
                "summary": "All CPU alerts"
              }
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter alerts by their current status. Can specify multiple statuses.\n\n**Alert Statuses:**\n- `CRITICAL` - Alert is in critical state (highest severity)\n- `WARNING` - Alert is in warning state\n- `CLEAR` - Alert is in normal state (not triggered)\n- `UNDEFINED` - Alert could not be evaluated (e.g., division by zero, missing data)\n- `UNINITIALIZED` - Alert has not been evaluated yet (no data collected)\n\n**Multiple Statuses:**\nTo show multiple statuses, separate them with commas: `status=CRITICAL,WARNING`\n\n**Use Cases:**\n- `status=CRITICAL` - Show only critical alerts requiring immediate attention\n- `status=CRITICAL,WARNING` - Show all alerts that need attention\n- `status=CLEAR` - Show alerts that are currently in normal state\n- Not specified - Show alerts in all states\n\n**Default:** When not specified, typically returns only alerts in WARNING or CRITICAL state (this depends on options parameter).\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "examples": {
              "critical_only": {
                "value": "CRITICAL",
                "summary": "Only critical alerts"
              },
              "needs_attention": {
                "value": "CRITICAL,WARNING",
                "summary": "All alerts needing attention"
              },
              "all_states": {
                "value": "CRITICAL,WARNING,CLEAR,UNDEFINED,UNINITIALIZED",
                "summary": "All alert states"
              }
            }
          },
          {
            "name": "options",
            "in": "query",
            "description": "Comma or pipe-separated list of options to control response content.\n\n**Alert-Specific Options:**\n- `summary` - Include summary counters (total alerts, by status, by type)\n\n**General Options:**\n- `contexts` - Include context information\n- `instances` - Include alert instance details\n- `values` - Include current alert values\n- `configurations` - Include alert configuration details\n\n**Examples:**\n- `options=summary` - Include alert count summaries\n- `options=summary,values` - Summaries and current values\n- `options=summary|configurations` - Summaries and configs (pipe separator)\n\nWhen not specified, returns basic alert information without detailed configs or summaries.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "examples": {
              "basic": {
                "value": "summary",
                "summary": "With summary counters"
              },
              "detailed": {
                "value": "summary,values,configurations",
                "summary": "Complete alert information"
              }
            }
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Maximum time in milliseconds to wait for the query to complete.\n\nThis is useful for preventing long-running queries from blocking when querying large infrastructures with many nodes and alerts.\n\n**Format:** Integer (milliseconds)\n\n**Default:** Server default timeout (typically 30000ms = 30 seconds)\n\n**Examples:**\n- `timeout=5000` - 5 second timeout\n- `timeout=60000` - 60 second timeout\n\nWhen the timeout is exceeded, the server returns a partial result with whatever data was collected before the timeout.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 1000
            },
            "example": 30000
          },
          {
            "name": "cardinality",
            "in": "query",
            "description": "Limit the number of alert instances returned to prevent response explosion.\n\nWhen monitoring large infrastructures, some alert types may have hundreds or thousands of instances (e.g., disk space alerts for every disk on every node).\n\nThis parameter limits the number of unique alert instances in the response.\n\n**Format:** Integer (maximum number of alert instances)\n\n**Default:** No limit\n\n**Use Cases:**\n- Preventing huge responses when there are many alert instances\n- Getting a sample of alerts rather than complete list\n- Dashboard widgets with limited display space\n\n**Example:**\n- `cardinality=100` - Return at most 100 alert instances\n\n**Alias:** Can also be specified as `cardinality_limit`\n\nWhen the limit is exceeded, the response may indicate how many alerts were omitted.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "example": 100
          }
        ],
        "responses": {
          "200": {
            "description": "Success. Returns current alert status information.\n\n**Response Structure:**\n- Summary counters (when options=summary): counts by status, type, classification\n- Alert instances with their current states\n- Alert values and thresholds (when options=values)\n- Alert configurations (when options=configurations)\n- Node and context associations\n\nThe response is grouped by contexts and includes metadata about each alert including its current status, value, time in current state, and associated chart/dimension.\n\n**Response Characteristics:**\n- JSON format\n- Not cacheable (alerts change frequently)\n- May include partial results if timeout is exceeded\n- Cardinality-limited if specified\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Multi-node alert status information"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Invalid parameter values\n- Malformed filter patterns\n- Invalid status values\n- Invalid timeout or cardinality values\n"
          },
          "500": {
            "description": "Internal server error. Usually indicates the server is out of memory."
          }
        }
      }
    },
    "/api/v3/alert_transitions": {
      "get": {
        "operationId": "alert_transitions_v3",
        "tags": [
          "alerts"
        ],
        "summary": "Retrieve alert state transition history across all nodes with advanced filtering",
        "description": "Returns the historical record of alert state changes (transitions) across the monitored infrastructure. This endpoint provides detailed information about when alerts changed state (e.g., from CLEAR to WARNING to CRITICAL), allowing you to analyze alert patterns, investigate incidents, and understand system behavior over time.\n\n**What is an Alert Transition?**\nAn alert transition is a record of an alert changing from one state to another. Each transition includes:\n- Previous and new alert status (CLEAR, WARNING, CRITICAL, etc.)\n- When the transition occurred\n- How long the alert stayed in the previous state (duration)\n- Alert value at the time of transition\n- Complete alert metadata (name, context, node, etc.)\n\n**Key Features:**\n- **Multi-Node Support:** Query transitions across entire infrastructure\n- **Advanced Filtering:** Filter by status, type, component, role, node, alert name, context\n- **Faceted Search:** Use multiple filter facets simultaneously (e.g., \"CRITICAL status on database nodes\")\n- **Pagination:** Navigate through large result sets using anchor_gi\n- **Time Range:** Specify exact time windows for historical analysis\n\n**Use Cases:**\n- Incident investigation: \"What alerts fired during the outage?\"\n- Alert pattern analysis: \"How often does this alert transition to CRITICAL?\"\n- Alert tuning: \"Which alerts flap between states most frequently?\"\n- Compliance reporting: \"Show all CRITICAL alerts in the last 30 days\"\n- Root cause analysis: \"What changed before this alert fired?\"\n\n**Faceted Filtering:**\nThis endpoint supports 9 different facets for precise filtering:\n- f_status: Filter by alert status (CRITICAL, WARNING, etc.)\n- f_type: Filter by alert type (e.g., \"System\", \"Database\", \"Network\")\n- f_role: Filter by recipient role (who should be notified)\n- f_class: Filter by alert classification\n- f_component: Filter by system component\n- f_node: Filter by specific node hostname\n- f_alert: Filter by alert name\n- f_instance: Filter by chart instance name\n- f_context: Filter by metric context\n\n**Examples:**\n1. Recent critical transitions: `?last=100&f_status=CRITICAL`\n2. Database alerts: `?f_component=Database&after=-86400`\n3. Specific alert history: `?f_alert=disk_space_usage&last=50`\n4. Node-specific transitions: `?f_node=web-server-01&after=-604800`\n\n**Response Format:**\nReturns a JSON array of transition records, ordered by time (newest first by default). Each record includes complete transition metadata, alert details, and timing information.\n\n**Performance Considerations:**\n- Use time ranges (after/before) to limit query scope\n- Use cardinality limits for large result sets\n- Timeout parameter prevents long-running queries\n- Pagination via anchor_gi for processing large datasets\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "scope_nodes",
            "in": "query",
            "description": "Filter transitions to only include specific nodes using simple pattern matching.\n\nThis parameter defines which nodes to include in the search using Netdata's simple pattern syntax (not regex).\n\n**Pattern Syntax:**\n- `*` matches any number of characters (including none)\n- `node1 node2` space-separated list matches any of the nodes\n- `!node3` exclude specific nodes (prefix with !)\n- Can combine inclusion and exclusion: `web* !web-test*`\n\n**Examples:**\n- `scope_nodes=web*` - All nodes starting with \"web\"\n- `scope_nodes=web* db*` - All web and database nodes\n- `scope_nodes=* !test*` - All nodes except test nodes\n- `scope_nodes=prod-web-01` - Specific node only\n\n**Use Cases:**\n- Focus on specific node groups (production vs staging)\n- Exclude test/development nodes from analysis\n- Investigate issues on specific infrastructure tiers\n\nWhen not specified, transitions from all nodes are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "examples": {
              "all_web_nodes": {
                "value": "web*",
                "summary": "All web servers"
              },
              "prod_only": {
                "value": "* !test* !dev*",
                "summary": "Production nodes only"
              }
            }
          },
          {
            "name": "nodes",
            "in": "query",
            "description": "Filter transitions to specific nodes by their exact names.\n\nUnlike `scope_nodes` which supports patterns, this parameter requires exact node names. Multiple nodes are separated by comma or pipe.\n\n**Format:** Comma or pipe-separated list of exact node names\n\n**Examples:**\n- `nodes=web-server-01` - Single specific node\n- `nodes=web-server-01,web-server-02,db-server-01` - Multiple specific nodes\n- `nodes=web-server-01|web-server-02` - Pipe separator also works\n\n**Difference from scope_nodes:**\n- `scope_nodes`: Pattern matching, filters at query time\n- `nodes`: Exact names, more efficient for known node names\n\n**Best Practice:** Use `nodes` when you know exact node names, use `scope_nodes` for pattern-based filtering.\n\nWhen not specified, transitions from all nodes matching scope_nodes (or all nodes if scope_nodes is also not specified) are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "web-server-01,db-server-01"
          },
          {
            "name": "scope_contexts",
            "in": "query",
            "description": "Filter transitions to only include alerts from specific metric contexts using pattern matching.\n\nContexts group similar metrics across instances (e.g., `system.cpu` groups CPU metrics from all nodes, `disk.io` groups disk I/O from all disks).\n\n**Pattern Syntax:**\n- `*` matches any number of characters\n- `context1 context2` space-separated list matches any of the contexts\n- `!context3` exclude specific contexts\n- Can combine: `system.* !system.io*`\n\n**Common Context Patterns:**\n- `system.*` - All system-level metrics\n- `disk.*` - All disk-related metrics\n- `net.*` - All network-related metrics\n- `mysql.*` - All MySQL metrics\n- `nginx.*` - All Nginx metrics\n\n**Examples:**\n- `scope_contexts=system.cpu` - Only CPU alerts\n- `scope_contexts=disk.* net.*` - All disk and network alerts\n- `scope_contexts=* !system.ip*` - All contexts except IP-related\n\n**Use Cases:**\n- Focus on specific subsystem (e.g., storage, network)\n- Exclude noisy alert types\n- Component-specific incident investigation\n\nWhen not specified, transitions from all contexts are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "examples": {
              "disk_alerts": {
                "value": "disk.*",
                "summary": "All disk-related alerts"
              },
              "critical_systems": {
                "value": "system.* disk.* net.*",
                "summary": "System, disk, and network alerts"
              }
            }
          },
          {
            "name": "contexts",
            "in": "query",
            "description": "Filter transitions to specific contexts by their exact names.\n\nUnlike `scope_contexts` which supports patterns, this parameter requires exact context names.\n\n**Format:** Comma or pipe-separated list of exact context names\n\n**Examples:**\n- `contexts=system.cpu` - Single specific context\n- `contexts=system.cpu,system.load,system.ram` - Multiple contexts\n- `contexts=disk.space|disk.inodes` - Pipe separator\n\n**Difference from scope_contexts:**\n- `scope_contexts`: Pattern matching for flexible filtering\n- `contexts`: Exact names for precise filtering\n\nWhen not specified, transitions from all contexts matching scope_contexts are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "system.cpu,system.ram,disk.space"
          },
          {
            "name": "alert",
            "in": "query",
            "description": "Filter transitions to a specific alert by its exact name.\n\nAlert names are unique identifiers for specific alert configurations.\n\n**Format:** Exact alert name (case-sensitive)\n\n**Examples:**\n- `alert=disk_space_usage` - Transitions for disk space alert\n- `alert=cpu_usage` - Transitions for CPU usage alert\n- `alert=ram_in_use` - Transitions for RAM usage alert\n\n**Use Cases:**\n- Analyze history of a specific alert\n- Tune alert thresholds based on historical behavior\n- Investigate alert flapping (rapid state changes)\n- Track alert effectiveness\n\n**Tip:** To find available alert names, query `/api/v3/alerts` first or use the `/api/v3/alert_config` endpoint.\n\nWhen not specified, transitions for all alerts are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "disk_space_usage"
          },
          {
            "name": "transition",
            "in": "query",
            "description": "Filter to a specific transition by its unique identifier.\n\nEach transition has a unique ID (UUID). This parameter is rarely used but can retrieve exact transition records.\n\n**Format:** UUID string\n\n**Use Case:** Retrieve exact transition details when you have the transition ID from another query or notification.\n\nWhen not specified, all transitions matching other filters are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "550e8400-e29b-41d4-a716-446655440000"
          },
          {
            "name": "last",
            "in": "query",
            "description": "Limit the number of transition records returned.\n\nThis controls how many transition records to include in the response, ordered by time (most recent first).\n\n**Format:** Positive integer\n\n**Default:** 1 (returns only the most recent transition)\n\n**Examples:**\n- `last=1` - Most recent transition only (default)\n- `last=100` - Last 100 transitions\n- `last=1000` - Last 1000 transitions\n\n**Use Cases:**\n- Dashboard widgets showing recent N alerts\n- API clients with pagination\n- Limiting response size for performance\n\n**Pagination:**\nFor datasets larger than `last`, use the `anchor_gi` parameter to navigate to the next page:\n1. Make request with `last=100`\n2. Note the `global_id` of the last transition in response\n3. Make next request with `last=100&anchor_gi=<global_id>`\n\n**Performance Note:** Smaller values of `last` result in faster queries and smaller responses.\n\n**IMPORTANT:** This parameter is required. If not specified, defaults to 1.\n",
            "required": true,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "default": 1
            },
            "example": 100
          },
          {
            "name": "anchor_gi",
            "in": "query",
            "description": "Global ID anchor for pagination through large result sets.\n\nEach transition has a unique global_id (an incrementing number). Use this parameter to paginate through results by specifying the global_id of the last transition from the previous page.\n\n**How Pagination Works:**\n1. First request: `?last=100` - Returns first 100 transitions\n2. Extract `global_id` of the 100th (last) transition from response\n3. Next request: `?last=100&anchor_gi=<global_id>` - Returns next 100 transitions\n\n**Format:** Positive integer (global_id from previous response)\n\n**Examples:**\n- `anchor_gi=12345` - Start from transition with global_id 12345\n- Combined with last: `last=100&anchor_gi=12345` - Get 100 transitions starting after global_id 12345\n\n**Use Cases:**\n- Processing large alert history datasets\n- Implementing \"load more\" in UIs\n- Batch processing of transition records\n- Exporting complete alert history\n\n**Direction:**\n- Results are ordered by global_id (which correlates with time)\n- Anchor specifies \"start after this ID\"\n- Each page contains `last` number of records\n\nWhen not specified, pagination starts from the most recent transition.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            },
            "example": 12345678
          },
          {
            "name": "f_status",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by their NEW status (the status the alert transitioned TO).\n\n**Available Status Values:**\n- `CRITICAL` - Alert in critical state (highest severity)\n- `WARNING` - Alert in warning state\n- `CLEAR` - Alert returned to normal state\n- `UNDEFINED` - Alert evaluation failed (e.g., metric missing, division by zero)\n- `UNINITIALIZED` - Alert not yet evaluated (no data yet)\n- `REMOVED` - Alert was removed (plugin stopped, configuration changed)\n\n**Format:** Comma-separated list of status values\n\n**Examples:**\n- `f_status=CRITICAL` - Only transitions TO critical state\n- `f_status=CRITICAL,WARNING` - Transitions to critical or warning\n- `f_status=CLEAR` - When alerts cleared (returned to normal)\n\n**Use Cases:**\n- Find when alerts became critical: `f_status=CRITICAL`\n- Track alert recovery: `f_status=CLEAR`\n- Find alert failures: `f_status=UNDEFINED`\n- Incident timeline: `f_status=CRITICAL,WARNING`\n\n**Note:** This filters by the NEW status. To see transitions FROM a status to another, you'll need to examine the old_status field in the response.\n\nWhen not specified, transitions to all statuses are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "examples": {
              "critical_only": {
                "value": "CRITICAL",
                "summary": "Only critical transitions"
              },
              "problems": {
                "value": "CRITICAL,WARNING",
                "summary": "Problem states"
              },
              "recoveries": {
                "value": "CLEAR",
                "summary": "Alert recoveries"
              }
            }
          },
          {
            "name": "f_type",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by alert type.\n\nAlert types categorize alerts by what they monitor (e.g., \"System\", \"Database\", \"Web Server\").\n\n**Format:** Comma-separated list of alert type names\n\n**Common Alert Types:**\n- `System` - System-level alerts (CPU, RAM, load)\n- `Database` - Database monitoring alerts\n- `Web Server` - Web server alerts (Nginx, Apache)\n- `Network` - Network-related alerts\n- `Storage` - Storage and disk alerts\n\n**Examples:**\n- `f_type=System` - Only system alerts\n- `f_type=Database,Web Server` - Database and web server alerts\n\n**Use Cases:**\n- Focus on specific infrastructure component types\n- Filter by technology stack (databases, web servers, etc.)\n- Team-specific alert filtering\n\n**Note:** The exact type values depend on your alert configurations. Query `/api/v3/alerts` to see available types in your installation.\n\nWhen not specified, transitions of all types are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "System,Database"
          },
          {
            "name": "f_role",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by recipient role.\n\nRoles define who should be notified about alerts (e.g., \"sysadmin\", \"dba\", \"webmaster\").\n\n**Format:** Comma-separated list of role names\n\n**Common Roles:**\n- `sysadmin` - System administrators\n- `dba` - Database administrators\n- `webmaster` - Web server administrators\n- `devops` - DevOps team\n- `security` - Security team\n\n**Examples:**\n- `f_role=sysadmin` - Alerts for sysadmin role\n- `f_role=sysadmin,dba` - Alerts for sysadmins and DBAs\n\n**Use Cases:**\n- Team-specific alert filtering\n- Role-based alert analysis\n- Notification audit trails\n\n**Note:** Roles are defined in your alert configurations. The exact role values depend on your Netdata setup.\n\nWhen not specified, transitions for all roles are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "sysadmin,dba"
          },
          {
            "name": "f_class",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by alert classification.\n\nAlert classifications categorize alerts by their nature (e.g., \"Errors\", \"Latency\", \"Utilization\").\n\n**Format:** Comma-separated list of classification names\n\n**Common Classifications:**\n- `Errors` - Error-related alerts\n- `Latency` - Performance/latency alerts\n- `Utilization` - Resource utilization alerts\n- `Availability` - Availability/uptime alerts\n- `Workload` - Workload-related alerts\n\n**Examples:**\n- `f_class=Errors` - Only error-related transitions\n- `f_class=Latency,Utilization` - Performance and utilization alerts\n\n**Use Cases:**\n- Focus on specific problem categories\n- SLA/SLO tracking by classification\n- Alert categorization analysis\n\nWhen not specified, transitions of all classifications are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "Errors,Latency"
          },
          {
            "name": "f_component",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by system component.\n\nComponents identify which part of the system the alert relates to (e.g., \"Network\", \"Disk\", \"Memory\").\n\n**Format:** Comma-separated list of component names\n\n**Common Components:**\n- `Network` - Network-related alerts\n- `Disk` - Disk/storage alerts\n- `Memory` - Memory alerts\n- `CPU` - CPU alerts\n- `Database` - Database component alerts\n\n**Examples:**\n- `f_component=Disk` - Only disk-related transitions\n- `f_component=Network,Disk` - Network and disk alerts\n\n**Use Cases:**\n- Component-specific incident investigation\n- Infrastructure subsystem analysis\n- Capacity planning by component\n\nWhen not specified, transitions for all components are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "Disk,Network"
          },
          {
            "name": "f_node",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by exact node hostname.\n\nThis is a facet filter alternative to the `nodes` parameter, typically used when you want to combine it with other facets.\n\n**Format:** Comma-separated list of exact node hostnames\n\n**Examples:**\n- `f_node=web-server-01` - Single specific node\n- `f_node=web-server-01,db-server-01` - Multiple nodes\n\n**Difference from `nodes` parameter:**\n- Both accept exact node names\n- `f_node` is a facet filter (can be combined with other f_* filters)\n- `nodes` is a direct filter parameter\n\n**Best Practice:** Use `nodes` for simple node filtering, use `f_node` when combining with other facets in complex queries.\n\nWhen not specified, all nodes are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "web-server-01"
          },
          {
            "name": "f_alert",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by exact alert name.\n\nThis is a facet filter alternative to the `alert` parameter.\n\n**Format:** Comma-separated list of exact alert names\n\n**Examples:**\n- `f_alert=disk_space_usage` - Single alert\n- `f_alert=cpu_usage,ram_in_use` - Multiple alerts\n\n**Difference from `alert` parameter:**\n- `alert`: Single alert name\n- `f_alert`: Multiple alert names, facet filter\n\nWhen not specified, all alerts are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "disk_space_usage,ram_in_use"
          },
          {
            "name": "f_instance",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by chart instance name.\n\nChart instances are specific monitored entities (e.g., \"disk_sda\", \"eth0\", \"mysql_localhost\").\n\n**Format:** Comma-separated list of instance names\n\n**Examples:**\n- `f_instance=sda` - Alerts for disk sda\n- `f_instance=eth0,eth1` - Alerts for network interfaces eth0 and eth1\n\n**Use Cases:**\n- Device-specific alert history (specific disk, NIC, etc.)\n- Instance-level troubleshooting\n- Resource-specific analysis\n\n**Note:** Instance names depend on your system configuration and what's being monitored.\n\nWhen not specified, all instances are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "sda,sdb"
          },
          {
            "name": "f_context",
            "in": "query",
            "description": "**Facet Filter:** Filter transitions by exact metric context.\n\nThis is a facet filter alternative to the `contexts` parameter.\n\n**Format:** Comma-separated list of exact context names\n\n**Examples:**\n- `f_context=system.cpu` - CPU context only\n- `f_context=disk.space,disk.inodes` - Disk space and inodes\n\n**Difference from `contexts` parameter:**\n- Both accept exact context names\n- `f_context` is a facet filter (can be combined with other f_* filters)\n- `contexts` is a direct filter parameter\n\nWhen not specified, all contexts are included.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "system.cpu,system.ram"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Maximum time in milliseconds to wait for the query to complete.\n\nAlert transition queries can be expensive when searching large time ranges or across many nodes.\n\n**Format:** Integer (milliseconds)\n\n**Default:** Server default timeout (typically 30000ms = 30 seconds)\n\n**Examples:**\n- `timeout=5000` - 5 second timeout\n- `timeout=60000` - 60 second timeout (for large queries)\n\n**Use Cases:**\n- Prevent long-running queries from blocking\n- API clients with strict latency requirements\n- Dashboard widgets needing fast responses\n\nWhen timeout is exceeded, the server returns a partial result with whatever transitions were collected before timeout, or an error if no results were ready.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 1000
            },
            "example": 30000
          },
          {
            "name": "cardinality",
            "in": "query",
            "description": "Limit the number of transition records returned to prevent response explosion.\n\n**Format:** Integer (maximum number of transitions)\n\n**Default:** No limit (but respects `last` parameter)\n\n**Relationship with `last`:**\n- `last`: Controls result set size (pagination)\n- `cardinality`: Hard limit on response size\n\n**Use Cases:**\n- Ensure responses stay within size limits\n- Protect against accidentally requesting huge result sets\n- API clients with memory constraints\n\n**Example:**\n- `cardinality=1000` - Never return more than 1000 transitions\n\n**Alias:** Can also be specified as `cardinality_limit`\n\n**Best Practice:** Use `last` for normal pagination, use `cardinality` as a safety limit.\n\nWhen the limit is exceeded, the response may indicate how many transitions were omitted.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "example": 1000
          }
        ],
        "responses": {
          "200": {
            "description": "Success. Returns alert transition history records.\n\n**Response Structure:**\n- Array of transition records, ordered by time (newest first by default)\n- Each record includes:\n  - `global_id`: Unique transition ID for pagination\n  - `transition_id`: UUID of this specific transition\n  - `alert_name`: Name of the alert\n  - `chart`, `chart_context`: What metric triggered the alert\n  - `old_status`, `new_status`: Status change (e.g., WARNING → CRITICAL)\n  - `old_value`, `new_value`: Metric values at transition\n  - `when_key`: When the transition occurred (timestamp)\n  - `duration`: How long the alert was in old_status\n  - `non_clear_duration`: Time spent in non-CLEAR states\n  - Alert metadata: type, classification, component, role, recipient\n  - Execution details: exec, exec_code, exec_run_timestamp\n  - Node information: machine_guid, hostname\n\n**Facets:**\nWhen not in MCP mode, the response includes facet information showing all available values for each facet filter (f_status, f_type, etc.) with counts.\n\n**Pagination:**\n- Use the `global_id` from the last record with `anchor_gi` parameter for next page\n- Response indicates if more results are available\n\n**Response Characteristics:**\n- JSON format\n- Not cacheable (new transitions constantly added)\n- May be cardinality-limited if specified\n- May be timeout-limited (partial results)\n\n**Example Usage:**\n```\nGET /api/v3/alert_transitions?last=100&f_status=CRITICAL&after=-86400\n```\nReturns last 100 transitions to CRITICAL state in the past 24 hours.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Alert transition history with pagination support"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Invalid parameter values\n- Malformed filter patterns\n- Invalid facet values\n- Invalid timeout or cardinality values\n- Invalid global_id for anchor_gi\n"
          },
          "500": {
            "description": "Internal server error during transition query execution."
          }
        }
      }
    },
    "/api/v3/alert_config": {
      "get": {
        "operationId": "alert_config_v3",
        "tags": [
          "alerts"
        ],
        "summary": "Retrieve the configuration of a specific alert by its config hash ID",
        "description": "Returns the complete configuration of an alert identified by its unique configuration hash ID (UUID). This endpoint provides detailed information about how an alert is configured, including its thresholds, evaluation logic, notification settings, and metadata.\n\n**What is an Alert Configuration?**\nEach alert in Netdata has a unique configuration that defines:\n- Threshold values (warning and critical)\n- The metric expression being evaluated\n- Evaluation frequency and hysteresis\n- Who to notify (recipients and roles)\n- Notification settings and delays\n- Alert metadata (name, info, summary, classification)\n\n**Configuration Hash ID:**\nThe `config` parameter is a UUID that uniquely identifies an alert configuration. Multiple alert instances may share the same configuration hash if they use identical alert rules.\n\n**How to Get Config Hash IDs:**\n- From `/api/v3/alerts` response - each alert includes its `config_hash_id`\n- From `/api/v3/alert_transitions` response - transitions include `config_hash_id`\n- From alert notifications - config hash is often included in alert payloads\n\n**Use Cases:**\n- **Alert Investigation:** Understand exactly what thresholds triggered an alert\n- **Alert Tuning:** Review current configuration before making changes\n- **Documentation:** Generate documentation of alert configurations\n- **Audit Trails:** Track what alert configurations were in effect at specific times\n- **Troubleshooting:** Verify alert logic when investigating false positives/negatives\n- **Configuration Management:** Compare configurations across environments\n\n**Response Content:**\nThe endpoint returns the complete alert configuration in the format it was defined (typically the Netdata health configuration syntax), including:\n- Alert name and type\n- The metric expression (`on` clause)\n- Warning and critical threshold expressions\n- Calculation method and dimensions\n- Lookup parameters (duration, method)\n- Notification recipients and roles\n- Alert metadata (info, summary, classification, component)\n- Delay settings and hysteresis rules\n\n**Example Workflow:**\n1. Query alerts: `GET /api/v3/alerts?alert=disk_space_usage`\n2. Extract `config_hash_id` from response\n3. Get config: `GET /api/v3/alert_config?config=<uuid>`\n4. Review/analyze the alert configuration details\n\n**Note:** This endpoint requires the exact config hash UUID. Invalid or non-existent UUIDs will return a 400 Bad Request error.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "config",
            "in": "query",
            "description": "The unique configuration hash ID (UUID) of the alert whose configuration to retrieve.\n\n**Format:** UUID string (with or without hyphens)\n\n**Where to Find Config Hash IDs:**\n1. **From /api/v3/alerts Response:**\n   Each alert in the response includes a `config_hash_id` field containing the UUID\n\n2. **From /api/v3/alert_transitions Response:**\n   Transition records include `config_hash_id` showing which config was active\n\n3. **From Alert Notifications:**\n   Alert notifications (email, Slack, etc.) often include the config hash\n\n4. **From Logs:**\n   Netdata logs may reference config hashes when loading alert configurations\n\n**UUID Format Examples:**\n- With hyphens: `550e8400-e29b-41d4-a716-446655440000`\n- Without hyphens: `550e8400e29b41d4a716446655440000`\n- Both formats are accepted\n\n**Important Notes:**\n- This parameter is **REQUIRED**\n- Must be a valid UUID format\n- Must reference an existing alert configuration\n- Case-insensitive\n\n**Common Errors:**\n- Missing config parameter → 400 Bad Request with message \"A config hash ID is required\"\n- Invalid UUID format → 400 Bad Request\n- Non-existent UUID → 404 or empty result\n\n**Example Usage:**\n```\nGET /api/v3/alert_config?config=550e8400-e29b-41d4-a716-446655440000\n```\n\n**Tip:** To find all config hash IDs for a specific alert name, query the alerts endpoint first:\n```\nGET /api/v3/alerts?alert=disk_space_usage\n```\nThen extract the `config_hash_id` from the response.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "example": "550e8400-e29b-41d4-a716-446655440000"
          }
        ],
        "responses": {
          "200": {
            "description": "Success. Returns the complete alert configuration.\n\n**Response Format:**\nThe response contains the alert configuration in a structured format, typically including:\n\n**Core Configuration:**\n- `name`: Alert name/identifier\n- `type`: Alert classification type\n- `on`: Metric expression being monitored\n- `class`: Alert classification category\n- `component`: System component being monitored\n- `lookup`: Metric lookup parameters (method, duration, dimensions)\n\n**Thresholds:**\n- `warn`: Warning threshold expression\n- `crit`: Critical threshold expression\n- `units`: Unit of measurement for values\n\n**Evaluation:**\n- `every`: How often the alert is evaluated\n- `green` / `red`: Hysteresis settings (when to clear/trigger)\n- `calc`: Calculation expression (if any)\n\n**Notifications:**\n- `to`: Notification recipients\n- `exec`: Script to execute on alert\n- `delay`: Notification delay settings\n- `repeat`: Repeat notification settings\n\n**Metadata:**\n- `info`: Detailed alert description\n- `summary`: Brief alert summary\n- `host_labels`: Labels for host filtering\n\n**Response Characteristics:**\n- Content-Type: Typically `text/plain` or `application/json` depending on format\n- Not cacheable (configurations may change)\n- Complete configuration as it exists in the system\n\n**Example Response Structure (JSON format):**\n```json\n{\n  \"name\": \"disk_space_usage\",\n  \"on\": \"disk.space\",\n  \"class\": \"Utilization\",\n  \"type\": \"System\",\n  \"component\": \"Disk\",\n  \"lookup\": \"average -1m percentage of used\",\n  \"units\": \"%\",\n  \"warn\": \"$this > 80\",\n  \"crit\": \"$this > 95\",\n  \"info\": \"Disk space utilization is high\",\n  \"to\": \"sysadmin\"\n}\n```\n\nThe exact format and fields depend on the alert configuration and may vary between different alert types.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Alert configuration details"
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string",
                  "description": "Alert configuration in text format"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Missing `config` parameter (error: \"A config hash ID is required. Add ?config=UUID query param\")\n- Invalid UUID format\n- Malformed request\n\n**Error Response:**\nReturns plain text error message explaining what went wrong.\n"
          },
          "404": {
            "description": "Configuration not found. The specified config hash ID does not exist or has been removed.\n\n**Common Reasons:**\n- Alert configuration was deleted\n- Alert configuration was modified (gets a new hash)\n- UUID was mistyped\n- Configuration is from a different Netdata instance\n"
          },
          "500": {
            "description": "Internal server error during configuration retrieval."
          }
        }
      }
    },
    "/api/v3/variable": {
      "get": {
        "operationId": "variable_v3",
        "tags": [
          "variables"
        ],
        "summary": "Retrieve the value of a specific chart variable used in alert expressions",
        "description": "Returns the current value of a variable associated with a specific chart. Variables are used in alert expressions for dynamic threshold calculations, data transformations, and alert logic evaluation.\n\n**What are Chart Variables?**\nVariables in Netdata are named values that can be:\n- **Chart-specific metrics:** Current values from dimensions (e.g., `$used`, `$total`)\n- **Calculated values:** Derived from chart data (e.g., percentages, ratios)\n- **Statistical values:** Min, max, average values over time windows\n- **Alert-related values:** Previous alert states, thresholds\n- **System variables:** Host labels, node information\n\n**Common Use Cases:**\n- **Alert Threshold Debugging:** Understand what value triggered an alert\n- **Alert Expression Development:** Test variable values while writing alert expressions\n- **Troubleshooting:** Verify variable calculations are correct\n- **Dynamic Configuration:** Check runtime values used in alert logic\n\n**Variable Types:**\n1. **Dimension Variables:** Direct dimension values (e.g., `used`, `free`, `cached`)\n2. **Lookup Variables:** Result of lookup operations over time ranges\n3. **Calculated Variables:** Custom calculations defined in alert configs\n4. **Chart Variables:** Chart-level metadata (family, units, etc.)\n5. **Host Variables:** Host-specific values and labels\n\n**Example Variables:**\n- `$this` - The current calculated value\n- `$used` - Value of \"used\" dimension\n- `$total` - Value of \"total\" dimension\n- `$1hour_cpu_usage` - CPU usage over last hour (lookup variable)\n- `$ram_percentage` - Calculated RAM usage percentage\n\n**How Variables Work in Alerts:**\nAlert expressions like `$this > 80` use variables to dynamically evaluate conditions. This endpoint lets you see the actual runtime values of these variables.\n\n**Workflow for Alert Development:**\n1. Identify the chart: `GET /api/v1/charts` or `GET /api/v3/contexts`\n2. Get variable value: `GET /api/v3/variable?chart=system.ram&variable=$used`\n3. Test alert expression with actual values\n4. Refine alert thresholds based on variable behavior\n\n**Response Format:**\nReturns JSON with the variable value and metadata about how it was calculated, including:\n- Current value\n- Calculation trace (how the value was computed)\n- Source dimensions\n- Any transformations applied\n\n**Note:** This is a specialized endpoint primarily used for alert development and troubleshooting. For general metric values, use `/api/v3/data` instead.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "chart",
            "in": "query",
            "description": "The chart identifier (ID or name) where the variable is defined.\n\n**Chart Identifier Format:**\nCharts can be specified by either their unique ID or their name.\n\n**Chart ID Format:**\n- Format: `type.name` (e.g., `system.cpu`, `disk.sda_io`, `mysql.queries`)\n- This is the canonical identifier shown in chart metadata\n- Case-sensitive\n- More reliable as it doesn't change\n\n**Chart Name Format:**\n- Human-readable name (e.g., \"System CPU\")\n- May contain spaces\n- Less reliable as it can change\n- The API will try to find by name if ID lookup fails\n\n**How to Find Chart IDs:**\n1. **From /api/v1/charts:**\n   ```\n   GET /api/v1/charts\n   ```\n   Response includes all chart IDs in the system\n\n2. **From /api/v3/contexts:**\n   ```\n   GET /api/v3/contexts\n   ```\n   Lists contexts and their chart instances\n\n3. **From Alert Configuration:**\n   Alert configs reference charts in their `on` clause\n\n4. **From Netdata Dashboard:**\n   Chart IDs are shown in chart metadata\n\n**Examples:**\n- `chart=system.cpu` - System CPU chart\n- `chart=system.ram` - System RAM chart\n- `chart=disk.sda_io` - Disk sda I/O chart\n- `chart=mysql.queries` - MySQL queries chart\n\n**Common Chart IDs by Category:**\n- **System:** `system.cpu`, `system.load`, `system.ram`, `system.io`\n- **Disk:** `disk.space`, `disk.io`, `disk.inodes`\n- **Network:** `net.eth0`, `net.packets`\n- **Databases:** `mysql.queries`, `postgres.connections`, `redis.memory`\n\n**Important Notes:**\n- This parameter is **REQUIRED**\n- Must reference an existing chart on the specified host\n- Chart must be actively collecting data\n- Case-sensitive\n\n**Error Handling:**\n- Missing parameter → 400 Bad Request: \"A chart= and a variable= are required.\"\n- Invalid/non-existent chart → 404 Not Found: \"Chart is not found: <chart>\"\n",
            "required": true,
            "schema": {
              "type": "string"
            },
            "examples": {
              "system_ram": {
                "value": "system.ram",
                "summary": "System RAM chart"
              },
              "disk_space": {
                "value": "disk.space",
                "summary": "Disk space chart"
              },
              "mysql": {
                "value": "mysql.queries",
                "summary": "MySQL queries chart"
              }
            }
          },
          {
            "name": "variable",
            "in": "query",
            "description": "The variable name to look up within the specified chart.\n\n**Variable Name Format:**\nVariable names typically follow these conventions:\n- Start with `$` in alert expressions, but the `$` is optional in this parameter\n- Names are case-sensitive\n- Can reference dimensions, calculated values, or lookups\n\n**Variable Name Categories:**\n\n**1. Dimension Variables (most common):**\nDirect references to chart dimensions:\n- `used` - Value of \"used\" dimension\n- `free` - Value of \"free\" dimension\n- `cached` - Value of \"cached\" dimension\n- `buffers` - Value of \"buffers\" dimension\n- `read` - Read operations/bytes\n- `write` - Write operations/bytes\n\n**2. Special Variables:**\n- `this` - The calculated/evaluated value from alert expression\n- `status` - Current alert status\n- `value` - Current metric value\n\n**3. Lookup Variables:**\nVariables created via lookup operations:\n- Format: `<duration>_<dimension>_<method>`\n- Example: `1hour_cpu_avg` - Average CPU over last hour\n- Example: `5min_disk_used_max` - Max disk used in last 5 minutes\n\n**4. Calculated Variables:**\nCustom variables defined in alert configurations:\n- `ram_percentage` - (used / total) * 100\n- `disk_usage_ratio` - used / total\n- `error_rate` - errors / total_requests\n\n**5. Chart Metadata Variables:**\n- `family` - Chart family/category\n- `units` - Chart units\n- `chart_type` - Chart type\n\n**How to Discover Available Variables:**\n1. **From Alert Configuration:**\n   Alert expressions reveal which variables are available\n   ```\n   GET /api/v3/alert_config?config=<uuid>\n   ```\n\n2. **From /api/v1/alarm_variables:**\n   Lists all variables for a chart\n   ```\n   GET /api/v1/alarm_variables?chart=system.ram\n   ```\n\n3. **From Chart Dimensions:**\n   Dimension names are typically available as variables\n   ```\n   GET /api/v1/chart?chart=system.ram\n   ```\n\n**Common Variable Examples by Chart:**\n\n**For system.ram:**\n- `used`, `free`, `cached`, `buffers`\n\n**For system.cpu:**\n- `user`, `system`, `nice`, `idle`, `iowait`\n\n**For disk.space:**\n- `used`, `avail` (available), `reserved`\n\n**For disk.io:**\n- `read`, `write`\n\n**For mysql.queries:**\n- `select`, `insert`, `update`, `delete`\n\n**Important Notes:**\n- This parameter is **REQUIRED**\n- Variable name must exist in the chart's variable set\n- Case-sensitive\n- The `$` prefix is optional (both `$used` and `used` work)\n\n**Error Handling:**\n- Missing parameter → 400 Bad Request: \"A chart= and a variable= are required.\"\n- Non-existent variable → Returns trace showing variable not found\n",
            "required": true,
            "schema": {
              "type": "string"
            },
            "examples": {
              "dimension_value": {
                "value": "used",
                "summary": "Get 'used' dimension value"
              },
              "with_dollar": {
                "value": "$used",
                "summary": "Variable with $ prefix (equivalent)"
              },
              "special_variable": {
                "value": "this",
                "summary": "Current calculated value"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success. Returns the variable value and calculation trace.\n\n**Response Structure:**\nThe response is a JSON object containing:\n\n**Variable Lookup Trace:**\nShows the step-by-step process of how the variable value was calculated:\n- Variable name being looked up\n- Source dimensions queried\n- Calculation methods applied\n- Intermediate values\n- Final calculated value\n\n**Example Response:**\n```json\n{\n  \"variable\": \"$used\",\n  \"chart\": \"system.ram\",\n  \"value\": 8589934592,\n  \"units\": \"B\",\n  \"trace\": [\n    {\n      \"step\": \"lookup_dimension\",\n      \"dimension\": \"used\",\n      \"raw_value\": 8589934592\n    },\n    {\n      \"step\": \"final_value\",\n      \"value\": 8589934592,\n      \"units\": \"B\"\n    }\n  ]\n}\n```\n\n**Response Fields:**\n- `variable`: The requested variable name\n- `chart`: The chart ID where variable was found\n- `value`: Current numeric value of the variable\n- `units`: Unit of measurement\n- `trace`: Array of calculation steps showing how value was derived\n\n**Trace Information:**\nThe trace provides transparency into variable evaluation, showing:\n- Dimension lookups performed\n- Data aggregation methods used\n- Time ranges evaluated\n- Transformations applied\n- Why certain values were selected\n\n**Use Cases for Trace:**\n- **Debugging Alerts:** Understand why an alert triggered\n- **Validating Logic:** Verify alert expressions evaluate correctly\n- **Performance Analysis:** See which dimensions contribute to variable\n- **Education:** Learn how alert variables are calculated\n\n**Response Characteristics:**\n- Content-Type: application/json\n- Not cacheable (values change constantly)\n- Real-time evaluation at query time\n- Includes calculation metadata\n\n**Note:** The exact trace format depends on the complexity of the variable lookup. Simple dimension variables have short traces, while complex calculated variables or lookups have detailed multi-step traces.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Variable value and calculation trace"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Missing `chart` parameter (error: \"A chart= and a variable= are required.\")\n- Missing `variable` parameter (error: \"A chart= and a variable= are required.\")\n- Empty parameter values\n- Malformed request\n\n**Error Response:**\nReturns plain text error message explaining what went wrong.\n\n**Example Error:**\n```\nA chart= and a variable= are required.\n```\n"
          },
          "404": {
            "description": "Chart not found. The specified chart ID or name does not exist.\n\n**Error Response:**\nReturns plain text message indicating chart was not found.\n\n**Example Error:**\n```\nChart is not found: system.nonexistent\n```\n\n**Common Reasons:**\n- Chart ID was mistyped\n- Chart doesn't exist on this host\n- Chart was removed (plugin stopped collecting)\n- Chart is on a different node (check node parameter if in multi-node setup)\n\n**Troubleshooting:**\n1. List available charts: `GET /api/v1/charts`\n2. Verify chart ID spelling and capitalization\n3. Check if chart is actively collecting data\n4. Ensure you're querying the correct node\n"
          },
          "500": {
            "description": "Internal server error during variable lookup."
          }
        }
      }
    },
    "/api/v3/info": {
      "get": {
        "operationId": "info_v3",
        "tags": [
          "nodes"
        ],
        "summary": "Retrieve detailed Netdata agent information across all nodes",
        "description": "Returns comprehensive information about Netdata agents running across the monitored infrastructure. This endpoint provides detailed metadata about each agent including version information, capabilities, collection status, and system configuration.\n\n**What is Netdata Agent Information?**\nThe `info` endpoint provides detailed metadata about the Netdata monitoring agent itself, including:\n- Agent version and build information\n- System capabilities and features enabled\n- Collection status and health\n- Host configuration and labels\n- Database information (storage, retention)\n- Plugin and collector status\n- Operating system details\n- Hardware information\n\n**Difference from /api/v3/nodes:**\n- **`/api/v3/nodes`:** Returns lightweight node list with basic identification\n- **`/api/v3/info`:** Returns comprehensive agent details with full capabilities and configuration\n\n**Multi-Node Support:**\nWhen queried on a Netdata Parent, this endpoint can return information for:\n- The parent agent itself\n- All child agents (streaming to the parent)\n- Filtered subsets using scope_nodes/nodes parameters\n\n**Use Cases:**\n- **Infrastructure Inventory:** Complete catalog of all Netdata installations\n- **Version Audits:** Find agents that need updates\n- **Capability Discovery:** What features are available on each node\n- **Health Monitoring:** Verify agent collection status\n- **Configuration Management:** Understand how agents are configured\n- **Troubleshooting:** Diagnose agent-specific issues\n- **License/Compliance:** Track Netdata deployments\n\n**Information Categories:**\n\n**1. Agent Identity:**\n- Unique agent ID (machine_guid)\n- Hostname\n- Agent version and commit\n- Build information\n\n**2. System Information:**\n- Operating system and kernel\n- CPU architecture\n- Virtualization platform\n- Container runtime (if applicable)\n\n**3. Database & Storage:**\n- Database mode (dbengine, ram, alloc)\n- Retention period\n- Storage capacity\n- Disk space usage\n\n**4. Features & Capabilities:**\n- ML/anomaly detection status\n- ACLK (cloud connection) status\n- Streaming capabilities\n- Available collectors\n\n**5. Collection Status:**\n- Number of charts collecting\n- Number of dimensions\n- Collection frequency\n- Last collection timestamp\n\n**6. Host Labels:**\n- Custom labels assigned to the host\n- Automatic labels (OS, architecture, etc.)\n- Cloud provider information (if detected)\n\n**Performance Characteristics:**\n- Fast query (primarily metadata lookups)\n- No time-series data processing\n- Results can be cached for reasonable duration\n- Supports filtering by node patterns\n\n**Example Usage:**\n```\n# Get info for all nodes\nGET /api/v3/info\n\n# Get info for specific nodes\nGET /api/v3/info?nodes=web-server-01,db-server-01\n\n# Get info for nodes matching pattern\nGET /api/v3/info?scope_nodes=prod-*\n\n# Include specific options\nGET /api/v3/info?options=full\n```\n\n**Response Format:**\nReturns JSON with agent information grouped by node, including complete details about each agent's capabilities, configuration, and current status.\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **No Restrictions:** Not subject to bearer protection or IP-based ACL restrictions\n- **No Authentication:** Cannot be restricted by any configuration\n- **Access:** Available to anyone who can reach the agent's HTTP endpoint\n",
        "parameters": [
          {
            "name": "scope_nodes",
            "in": "query",
            "description": "Filter to specific nodes using simple pattern matching.\n\n**Pattern Syntax:**\n- `*` matches any characters\n- Space-separated list for multiple patterns\n- `!` prefix to exclude\n- Combine with: `web* !web-test*`\n\n**Examples:**\n- `scope_nodes=web*` - All web servers\n- `scope_nodes=prod-*` - All production nodes\n- `scope_nodes=* !test*` - All except test nodes\n\n**Use Cases:**\n- Focus on specific infrastructure tiers\n- Exclude development/test environments\n- Group by naming conventions\n\nWhen not specified, returns info for all nodes.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "prod-*"
          },
          {
            "name": "nodes",
            "in": "query",
            "description": "Filter to specific nodes by exact names.\n\nUnlike `scope_nodes`, this requires exact node names (no patterns).\n\n**Format:** Comma or pipe-separated list\n\n**Examples:**\n- `nodes=web-server-01` - Single node\n- `nodes=web-server-01,db-server-01` - Multiple nodes\n- `nodes=web-01|web-02` - Pipe separator\n\n**Best Practice:**\n- Use `nodes` when you know exact names\n- Use `scope_nodes` for pattern-based filtering\n\nWhen not specified, returns info for all nodes matching scope_nodes.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "web-server-01,db-server-01"
          },
          {
            "name": "options",
            "in": "query",
            "description": "Control the level of detail and what information to include in the response.\n\n**Available Options:**\n- `full` or `all` - Include all available information\n- `labels` - Include host labels\n- `uuids` - Include UUIDs and identifiers\n- `deleted` - Include information about deleted/offline nodes\n- `hidden` - Include hidden agents\n\n**Examples:**\n- `options=full` - Complete information\n- `options=labels,uuids` - Labels and identifiers\n- `options=labels|uuids` - Pipe separator also works\n\n**Default Behavior:**\nWhen not specified, returns standard information without deleted/hidden nodes and without excessive detail.\n\n**Use Cases:**\n- Inventory systems need `full` detail\n- Label-based filtering needs `labels`\n- Historical analysis may need `deleted`\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "full,labels"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Maximum time in milliseconds to wait for the query to complete.\n\n**Format:** Integer (milliseconds)\n\n**Default:** Server default timeout\n\n**Example:**\n- `timeout=30000` - 30 second timeout\n\nFor agent info queries, timeouts are rarely needed as this is a fast metadata-only operation. However, on very large multi-node setups, you may want to limit query time.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 1000
            },
            "example": 30000
          },
          {
            "name": "cardinality",
            "in": "query",
            "description": "Limit the number of nodes returned.\n\n**Format:** Integer (maximum nodes)\n\n**Default:** No limit\n\n**Example:**\n- `cardinality=100` - Return at most 100 nodes\n\n**Use Cases:**\n- Prevent huge responses in very large infrastructures\n- Get a sample of nodes for testing\n- Dashboard widgets with limited display space\n\nWhen exceeded, response indicates how many nodes were omitted.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "example": 100
          }
        ],
        "responses": {
          "200": {
            "description": "Success. Returns detailed Netdata agent information.\n\n**Response Structure:**\nThe response is a JSON object containing comprehensive agent information grouped by node.\n\n**Top-Level Structure:**\n- `agents`: Array of agent information objects, one per node\n\n**Per-Agent Information Includes:**\n\n**1. Identity:**\n- `machine_guid`: Unique agent identifier (UUID)\n- `hostname`: Node hostname\n- `agent_version`: Netdata version string\n- `agent_commit`: Git commit hash of build\n\n**2. System Information:**\n- `os_name`: Operating system name\n- `os_version`: OS version\n- `kernel_name`: Kernel name\n- `kernel_version`: Kernel version\n- `architecture`: CPU architecture (x86_64, aarch64, etc.)\n- `virtualization`: Virtualization platform (if any)\n- `container`: Container runtime (Docker, LXC, etc.)\n- `container_detection`: How container was detected\n\n**3. Database & Storage:**\n- `database_mode`: Storage mode (dbengine, ram, alloc, none)\n- `database_retention`: Data retention period in seconds\n- `database_size`: Current database size in bytes\n- `page_cache_size`: Page cache size\n- `metrics_stored`: Number of unique metrics\n\n**4. Features & Capabilities:**\n- `ml_enabled`: Machine learning / anomaly detection enabled\n- `ml_models_running`: Number of ML models active\n- `aclk_available`: Cloud connectivity available\n- `aclk_status`: Cloud connection status\n- `stream_compression`: Streaming compression supported\n- `web_enabled`: Web server enabled\n\n**5. Collection Status:**\n- `charts_count`: Number of charts being collected\n- `dimensions_count`: Number of dimensions (time-series)\n- `collectors_count`: Number of active collectors\n- `update_every`: Collection frequency in seconds\n- `history`: Retention in seconds\n- `memory_mode`: Memory storage mode\n\n**6. Host Labels:**\n- `host_labels`: Object containing all host labels\n  - Includes automatic labels (_os_name, _architecture, etc.)\n  - Includes custom labels assigned by user\n  - May include cloud provider labels\n\n**7. Timestamps:**\n- `first_time_t`: Timestamp of oldest data point\n- `last_time_t`: Timestamp of newest data point\n- `now`: Current server time\n\n**8. Streaming Information (if applicable):**\n- `stream_status`: Streaming status (parent/child)\n- `stream_parents`: Parent nodes (if child)\n- `stream_children`: Child nodes (if parent)\n\n**Example Response Structure:**\n```json\n{\n  \"agents\": [\n    {\n      \"machine_guid\": \"550e8400-e29b-41d4-a716-446655440000\",\n      \"hostname\": \"web-server-01\",\n      \"agent_version\": \"v1.40.0\",\n      \"os_name\": \"ubuntu\",\n      \"os_version\": \"22.04\",\n      \"kernel_version\": \"5.15.0\",\n      \"architecture\": \"x86_64\",\n      \"database_mode\": \"dbengine\",\n      \"database_retention\": 86400,\n      \"ml_enabled\": true,\n      \"charts_count\": 425,\n      \"dimensions_count\": 2850,\n      \"update_every\": 1,\n      \"host_labels\": {\n        \"_os_name\": \"ubuntu\",\n        \"_architecture\": \"x86_64\",\n        \"environment\": \"production\",\n        \"tier\": \"web\"\n      }\n    }\n  ]\n}\n```\n\n**Response Characteristics:**\n- Content-Type: application/json\n- Can be cached (agent info changes infrequently)\n- Complete metadata without time-series data\n- Lightweight and fast to generate\n\n**Filtering:**\nResponse respects scope_nodes/nodes filters and cardinality limits.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Comprehensive Netdata agent information"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Invalid parameter values\n- Malformed filter patterns\n"
          },
          "500": {
            "description": "Internal server error during info retrieval."
          }
        }
      }
    },
    "/api/v3/node_instances": {
      "get": {
        "operationId": "node_instances_v3",
        "tags": [
          "nodes"
        ],
        "summary": "Retrieve chart instances organized by node across the infrastructure",
        "description": "Returns information about all chart instances grouped by node. This endpoint provides a comprehensive view of what metrics are being collected on each node, organized by chart instances.\n\n**What are Node Instances?**\nNode instances represent the specific chart instances (individual monitoring targets) on each node:\n- Each node may have multiple instances of the same chart type\n- Examples: Multiple disks (sda, sdb, sdc), multiple network interfaces (eth0, eth1)\n- Instances represent the specific entities being monitored\n\n**Example:**\nFor disk monitoring:\n- Node: `web-server-01`\n  - Instances: `disk.sda`, `disk.sdb`, `disk.nvme0n1`\n- Node: `db-server-01`\n  - Instances: `disk.sda`, `disk.sdb`\n\n**Difference from Other Endpoints:**\n- **`/api/v3/nodes`:** Returns lightweight node list\n- **`/api/v3/info`:** Returns detailed agent information\n- **`/api/v3/node_instances`:** Returns what chart instances each node has (what's being monitored)\n- **`/api/v3/contexts`:** Returns contexts aggregated across all nodes\n\n**Use Cases:**\n- **Infrastructure Discovery:** What devices/services are monitored on each node\n- **Capacity Planning:** Understand monitoring coverage per node\n- **Configuration Verification:** Verify expected charts are collecting\n- **Collector Status:** See which collectors are active per node\n- **Instance Inventory:** Complete catalog of monitored entities\n- **Troubleshooting:** Find which nodes monitor specific instances\n\n**Response Organization:**\nResults are organized hierarchically:\n1. **By Node:** Top-level grouping by node hostname\n2. **By Context:** Charts grouped by their context (e.g., disk.space)\n3. **By Instance:** Individual chart instances within each context\n\n**Performance Characteristics:**\n- Medium query cost (metadata aggregation across nodes)\n- Response size grows with number of nodes and instances\n- Can be filtered to reduce response size\n- Results can be cached (instances change infrequently)\n\n**Example Query Patterns:**\n```\n# Get all instances across all nodes\nGET /api/v3/node_instances\n\n# Get instances for specific nodes\nGET /api/v3/node_instances?nodes=web-server-01,db-server-01\n\n# Get instances for nodes matching pattern\nGET /api/v3/node_instances?scope_nodes=prod-*\n\n# Limit response size\nGET /api/v3/node_instances?cardinality=100\n```\n\n**Response Includes:**\n- Node identification (hostname, machine_guid)\n- Agent information (version, capabilities)\n- All chart instances organized by context\n- Instance-specific metadata (labels, units, dimensions)\n- Instance collection status\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "scope_nodes",
            "in": "query",
            "description": "Filter to specific nodes using pattern matching.\n\n**Pattern Syntax:**\n- `*` matches any characters\n- Space-separated for multiple patterns\n- `!` prefix excludes\n- Example: `prod-* !prod-test*`\n\n**Examples:**\n- `scope_nodes=web*` - All web servers\n- `scope_nodes=db-* cache-*` - Database and cache nodes\n- `scope_nodes=* !test*` - All except test nodes\n\nWhen not specified, returns instances from all nodes.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "prod-*"
          },
          {
            "name": "nodes",
            "in": "query",
            "description": "Filter to specific nodes by exact names.\n\n**Format:** Comma or pipe-separated exact names\n\n**Examples:**\n- `nodes=web-server-01` - Single node\n- `nodes=web-01,db-01` - Multiple nodes\n\n**Best Practice:** Use `nodes` for exact names, `scope_nodes` for patterns.\n\nWhen not specified, returns instances from all nodes.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "web-server-01,db-server-01"
          },
          {
            "name": "options",
            "in": "query",
            "description": "Control response detail level and included information.\n\n**Available Options:**\n- `full` or `all` - Complete instance information\n- `labels` - Include instance labels\n- `uuids` - Include UUIDs and identifiers\n- `deleted` - Include deleted/offline instances\n- `hidden` - Include hidden instances\n- `instances` or `charts` - Include chart instances (default)\n- `metrics` or `dimensions` - Include dimension details\n\n**Examples:**\n- `options=full` - All information\n- `options=labels,dimensions` - Labels and dimension details\n- `options=labels|uuids` - Pipe separator\n\n**Default:** Returns basic instance information without excessive detail.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "full,labels,dimensions"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Maximum time in milliseconds to wait for query completion.\n\n**Format:** Integer (milliseconds)\n\n**Default:** Server default timeout\n\n**Example:** `timeout=30000` (30 seconds)\n\nFor large multi-node infrastructures, you may need to increase timeout to allow complete instance enumeration.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64",
              "minimum": 1000
            },
            "example": 30000
          },
          {
            "name": "cardinality",
            "in": "query",
            "description": "Limit the number of instances returned per node.\n\n**Format:** Integer (max instances per node)\n\n**Default:** No limit\n\n**Example:** `cardinality=500` - At most 500 instances per node\n\n**Use Cases:**\n- Prevent huge responses from nodes with many instances\n- Sample instances for testing\n- Dashboard widgets with limited space\n\nWhen exceeded, response indicates how many instances were omitted per node.\n",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "example": 500
          }
        ],
        "responses": {
          "200": {
            "description": "Success. Returns chart instances organized by node.\n\n**Response Structure:**\n```json\n{\n  \"nodes\": [\n    {\n      \"machine_guid\": \"uuid\",\n      \"hostname\": \"web-server-01\",\n      \"agent_version\": \"v1.40.0\",\n      \"contexts\": [\n        {\n          \"context\": \"disk.space\",\n          \"instances\": [\n            {\n              \"id\": \"disk.sda\",\n              \"name\": \"disk sda\",\n              \"family\": \"sda\",\n              \"labels\": {...},\n              \"dimensions\": [...],\n              \"status\": \"active\"\n            },\n            {\n              \"id\": \"disk.sdb\",\n              \"name\": \"disk sdb\",\n              \"family\": \"sdb\",\n              \"labels\": {...},\n              \"dimensions\": [...],\n              \"status\": \"active\"\n            }\n          ]\n        },\n        {\n          \"context\": \"net.net\",\n          \"instances\": [\n            {\n              \"id\": \"net.eth0\",\n              \"name\": \"eth0\",\n              \"family\": \"eth0\",\n              \"labels\": {...},\n              \"dimensions\": [...],\n              \"status\": \"active\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Response Fields:**\n\n**Node Level:**\n- `machine_guid`: Unique node identifier\n- `hostname`: Node hostname\n- `agent_version`: Netdata version on this node\n- `contexts`: Array of contexts with their instances\n\n**Context Level:**\n- `context`: Context name (e.g., \"disk.space\", \"system.cpu\")\n- `instances`: Array of chart instances for this context\n\n**Instance Level:**\n- `id`: Chart instance ID (e.g., \"disk.sda\")\n- `name`: Human-readable instance name\n- `family`: Chart family/grouping\n- `labels`: Instance-specific labels\n- `dimensions`: Array of dimensions (metrics) collected\n- `status`: Collection status (active, stale, offline)\n- `units`: Unit of measurement\n- `chart_type`: Chart visualization type\n- `priority`: Display priority\n\n**Dimension Information (when options=dimensions):**\n- `id`: Dimension identifier\n- `name`: Dimension display name\n- `algorithm`: Aggregation algorithm\n- `multiplier`, `divisor`: Value transformation\n\n**Label Information (when options=labels):**\n- Instance labels provide additional metadata\n- Examples: disk_type=ssd, interface_speed=1000, mount_point=/\n\n**Response Characteristics:**\n- Content-Type: application/json\n- Cacheable (instances change infrequently)\n- Size grows with number of nodes and instances\n- Organized hierarchically for easy navigation\n\n**Filtering:**\nResponse respects scope_nodes/nodes filters and cardinality limits.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Chart instances organized by node"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Invalid parameter values\n- Malformed filter patterns\n"
          },
          "500": {
            "description": "Internal server error during instance enumeration."
          }
        }
      }
    },
    "/api/v3/stream_path": {
      "get": {
        "operationId": "stream_path",
        "tags": [
          "nodes"
        ],
        "summary": "Retrieve streaming topology path for nodes",
        "description": "**V3 SPECIFIC ENDPOINT**\n\nReturns the streaming path and topology showing how nodes are connected in the Netdata infrastructure.\nThis endpoint reveals the parent-child relationships between nodes, showing which nodes stream data\nto which parents, creating a hierarchical view of the monitoring infrastructure.\n\n**Streaming Topology:**\n- **Parent nodes**: Nodes that receive streaming data from child nodes\n- **Child nodes**: Nodes that send their metrics to parent nodes for centralization\n- **Streaming path**: The complete chain from child → parent → grandparent (if any)\n\n**Use Cases:**\n- Understand infrastructure hierarchy and data flow\n- Identify parent nodes that aggregate data from multiple children\n- Debug streaming connectivity issues\n- Plan infrastructure changes and reorganization\n- Visualize the complete monitoring topology\n\n**Common Usage Patterns:**\n\n1. **Get complete streaming topology:**\n   ```\n   /api/v3/stream_path\n   ```\n\n2. **Filter by specific nodes:**\n   ```\n   /api/v3/stream_path?nodes=child-node-1|child-node-2\n   ```\n\n3. **Scope to nodes matching pattern:**\n   ```\n   /api/v3/stream_path?scope_nodes=prod-*\n   ```\n\n**Response Structure:**\nThe response includes nodes organized by their streaming relationships, showing:\n- Node hostnames and machine GUIDs\n- Parent-child relationships\n- Streaming connection status (live/stale/offline)\n- Complete path from each child to root parent\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "scope_nodes",
            "in": "query",
            "required": false,
            "description": "Simple pattern to match node hostnames for scope filtering. Uses Netdata's simple pattern\nmatching (not regex). Matched nodes define the scope for topology analysis.\n\n**Pattern Syntax:**\n- `*` matches any number of characters\n- Use `|` to separate multiple patterns (OR logic)\n- Matches are case-insensitive\n- No regex support - only simple wildcards\n\n**Examples:**\n- `prod-*` - All production nodes\n- `*-web-*` - All web server nodes\n- `db-*|cache-*` - All database or cache nodes\n- `*` - All nodes (default)\n",
            "schema": {
              "type": "string",
              "default": "*"
            },
            "example": "prod-*"
          },
          {
            "name": "nodes",
            "in": "query",
            "required": false,
            "description": "Simple pattern to filter which nodes to include in the streaming path response.\nAfter scope is determined, this filters the results. Uses the same pattern syntax as scope_nodes.\n\n**Difference from scope_nodes:**\n- `scope_nodes` defines what nodes to analyze for relationships\n- `nodes` filters which nodes to include in the output\n\n**Examples:**\n- `web-*` - Only show web server nodes in output\n- `parent-*` - Only show parent nodes\n- Specific hostnames: `node1|node2|node3`\n",
            "schema": {
              "type": "string",
              "default": "*"
            },
            "example": "web-*"
          },
          {
            "name": "options",
            "in": "query",
            "required": false,
            "description": "Comma-separated list of options to control response content and format.\n\n**Available Options:**\n- `minify` - Minimize JSON output (no pretty-printing)\n- `debug` - Include debug information about streaming connections\n- `raw` - Include raw streaming metadata\n\n**Examples:**\n- `minify` - Compact JSON response\n- `debug,raw` - Debug mode with raw metadata\n",
            "schema": {
              "type": "string"
            },
            "example": "debug"
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "description": "Maximum time in seconds to wait for the query to complete before timing out.\n\n**Guidelines:**\n- Recommended: 30-60 seconds for most queries\n- Large infrastructures may need longer timeouts\n- Queries timeout if streaming metadata collection takes too long\n",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "default": 60
            },
            "example": 30
          },
          {
            "name": "cardinality",
            "in": "query",
            "required": false,
            "description": "Maximum number of nodes to include in the response to prevent overwhelming large responses.\nWhen this limit is exceeded, the response will indicate how many nodes were omitted.\n\n**Purpose:**\n- Prevent memory exhaustion from very large infrastructures\n- Control response size for performance\n- Useful when exploring large node hierarchies incrementally\n\n**Recommendations:**\n- Small infrastructures (< 50 nodes): Use default or increase\n- Medium infrastructures (50-500 nodes): 200-500\n- Large infrastructures (> 500 nodes): Use filtering or increase limit carefully\n",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 10000,
              "default": 1000
            },
            "example": 500
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved streaming topology path information.\n\nReturns nodes with their streaming relationships, showing parent-child hierarchy,\nconnection status, and complete paths from children to root parents.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "nodes": {
                      "type": "array",
                      "description": "Array of nodes with streaming path information",
                      "items": {
                        "type": "object",
                        "properties": {
                          "hostname": {
                            "type": "string",
                            "description": "Node hostname"
                          },
                          "machine_guid": {
                            "type": "string",
                            "description": "Unique node identifier"
                          },
                          "parent": {
                            "type": "string",
                            "description": "Hostname of parent node (if any)"
                          },
                          "parent_guid": {
                            "type": "string",
                            "description": "Machine GUID of parent node"
                          },
                          "streaming_status": {
                            "type": "string",
                            "enum": [
                              "live",
                              "stale",
                              "offline"
                            ],
                            "description": "Current streaming connection status"
                          },
                          "path": {
                            "type": "array",
                            "description": "Complete path from this node to root parent",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "omitted": {
                      "type": "integer",
                      "description": "Number of nodes omitted due to cardinality limit"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters provided (e.g., invalid pattern syntax)."
          },
          "500": {
            "description": "Internal server error during streaming topology retrieval."
          },
          "504": {
            "description": "Query timeout - streaming topology collection took too long."
          }
        }
      }
    },
    "/api/v3/versions": {
      "get": {
        "operationId": "versions3",
        "tags": [
          "versions"
        ],
        "summary": "Retrieve Netdata agent version information across nodes",
        "description": "Returns version information for Netdata agents running on monitored nodes.\nThis endpoint provides visibility into the software versions deployed across your infrastructure,\nhelping identify version mismatches, outdated agents, and upgrade planning.\n\n**Version Information Includes:**\n- Netdata agent version string (e.g., \"v1.40.0\")\n- Build information and commit hash\n- Protocol versions supported\n- Feature capabilities based on version\n\n**Use Cases:**\n- **Version audit**: Identify which nodes run which versions\n- **Upgrade planning**: Find nodes that need updates\n- **Compatibility checking**: Ensure version compatibility across infrastructure\n- **Feature availability**: Determine which features are available on which nodes\n- **Security compliance**: Identify nodes running vulnerable versions\n\n**Common Usage Patterns:**\n\n1. **Get versions of all nodes:**\n   ```\n   /api/v3/versions\n   ```\n\n2. **Check versions of specific nodes:**\n   ```\n   /api/v3/versions?nodes=prod-*\n   ```\n\n3. **Scope to production infrastructure:**\n   ```\n   /api/v3/versions?scope_nodes=prod-*\n   ```\n\n**Response Structure:**\nReturns version information grouped by node, showing:\n- Agent version string\n- Build timestamp\n- Git commit hash\n- Protocol versions\n- Feature flags and capabilities\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **No Restrictions:** Not subject to bearer protection or IP-based ACL restrictions\n- **No Authentication:** Cannot be restricted by any configuration\n- **Access:** Available to anyone who can reach the agent's HTTP endpoint\n",
        "parameters": [
          {
            "name": "scope_nodes",
            "in": "query",
            "required": false,
            "description": "Simple pattern to match node hostnames for scope filtering. Uses Netdata's simple pattern\nmatching (not regex). Matched nodes define the scope for version information retrieval.\n\n**Pattern Syntax:**\n- `*` matches any number of characters\n- Use `|` to separate multiple patterns (OR logic)\n- Matches are case-insensitive\n- No regex support - only simple wildcards\n\n**Examples:**\n- `prod-*` - All production nodes\n- `*-db-*` - All database nodes\n- `web-*|app-*` - All web or application nodes\n- `*` - All nodes (default)\n",
            "schema": {
              "type": "string",
              "default": "*"
            },
            "example": "prod-*"
          },
          {
            "name": "nodes",
            "in": "query",
            "required": false,
            "description": "Simple pattern to filter which nodes to include in the version information response.\nAfter scope is determined, this filters the results. Uses the same pattern syntax as scope_nodes.\n\n**Difference from scope_nodes:**\n- `scope_nodes` defines what nodes to analyze\n- `nodes` filters which nodes appear in the output\n\n**Examples:**\n- `old-*` - Only show nodes matching \"old-*\" pattern\n- Specific hostnames: `node1|node2|node3`\n",
            "schema": {
              "type": "string",
              "default": "*"
            },
            "example": "*"
          },
          {
            "name": "options",
            "in": "query",
            "required": false,
            "description": "Comma-separated list of options to control response content and format.\n\n**Available Options:**\n- `minify` - Minimize JSON output (no pretty-printing)\n- `debug` - Include additional debug information\n- `raw` - Include raw version metadata\n\n**Examples:**\n- `minify` - Compact JSON response\n- `debug,raw` - Debug mode with raw metadata\n",
            "schema": {
              "type": "string"
            },
            "example": "debug"
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "description": "Maximum time in seconds to wait for the query to complete before timing out.\n\n**Guidelines:**\n- Recommended: 10-30 seconds for most queries\n- Version information is usually quick to retrieve\n- Timeout mainly applies to very large infrastructures\n",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "default": 60
            },
            "example": 10
          },
          {
            "name": "cardinality",
            "in": "query",
            "required": false,
            "description": "Maximum number of nodes to include in the response to prevent overwhelming large responses.\nWhen this limit is exceeded, the response will indicate how many nodes were omitted.\n\n**Purpose:**\n- Prevent memory exhaustion from very large infrastructures\n- Control response size for performance\n- Useful when exploring large node sets incrementally\n\n**Recommendations:**\n- Small infrastructures (< 100 nodes): Use default\n- Medium infrastructures (100-1000 nodes): 500-1000\n- Large infrastructures (> 1000 nodes): Use filtering or increase limit carefully\n",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 10000,
              "default": 1000
            },
            "example": 500
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved version information.\n\nReturns version data for each node including agent version, build info,\nprotocol versions, and feature capabilities.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "versions": {
                      "type": "array",
                      "description": "Array of version information per node",
                      "items": {
                        "type": "object",
                        "properties": {
                          "hostname": {
                            "type": "string",
                            "description": "Node hostname"
                          },
                          "machine_guid": {
                            "type": "string",
                            "description": "Unique node identifier"
                          },
                          "version": {
                            "type": "string",
                            "description": "Netdata agent version string",
                            "example": "v1.40.0"
                          },
                          "build_info": {
                            "type": "string",
                            "description": "Build information and timestamp"
                          },
                          "commit_hash": {
                            "type": "string",
                            "description": "Git commit hash of the build"
                          },
                          "protocol_version": {
                            "type": "integer",
                            "description": "Streaming protocol version supported"
                          },
                          "features": {
                            "type": "array",
                            "description": "Feature flags and capabilities",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "omitted": {
                      "type": "integer",
                      "description": "Number of nodes omitted due to cardinality limit"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters provided (e.g., invalid pattern syntax)."
          },
          "500": {
            "description": "Internal server error during version information retrieval."
          },
          "504": {
            "description": "Query timeout - version collection took too long."
          }
        }
      }
    },
    "/api/v3/progress": {
      "get": {
        "operationId": "progress3",
        "tags": [
          "functions"
        ],
        "summary": "Track progress of long-running function executions",
        "description": "Monitors the progress of long-running Netdata function executions identified by a transaction ID.\nWhen executing functions that may take significant time (e.g., data collection, analysis, exports),\nthis endpoint allows clients to poll for progress updates and track completion status.\n\n**Function Execution Flow:**\n1. Client initiates a function execution (e.g., via `/api/v3/function`)\n2. Function returns immediately with a transaction ID\n3. Client polls `/api/v3/progress?transaction=<id>` for status updates\n4. Progress endpoint returns completion percentage and status\n5. When complete, client retrieves final results\n\n**Progress Information Includes:**\n- **Percentage complete**: 0-100% progress indicator\n- **Status**: running, completed, failed, cancelled\n- **Message**: Human-readable status description\n- **Remaining time estimate**: If available\n\n**Use Cases:**\n- **Long data exports**: Track progress of large data export operations\n- **Analysis functions**: Monitor CPU-intensive analysis tasks\n- **Batch operations**: Track multi-step batch processing\n- **User experience**: Provide progress feedback in UI applications\n\n**Polling Best Practices:**\n- Poll every 1-2 seconds for responsive updates\n- Implement exponential backoff for completed/failed states\n- Set reasonable timeouts (functions may take minutes)\n- Handle cancellation gracefully\n\n**Common Usage Patterns:**\n\n1. **Poll for function progress:**\n   ```\n   /api/v3/progress?transaction=550e8400-e29b-41d4-a716-446655440000\n   ```\n\n2. **Integration with function execution:**\n   ```javascript\n   // 1. Start function\n   const response = await fetch('/api/v3/function?...');\n   const { transaction } = await response.json();\n\n   // 2. Poll for progress\n   const interval = setInterval(async () => {\n     const progress = await fetch(`/api/v3/progress?transaction=${transaction}`);\n     const { percentage, status } = await progress.json();\n\n     if (status === 'completed') {\n       clearInterval(interval);\n       // Fetch final results\n     }\n   }, 1000);\n   ```\n\n**Transaction ID Format:**\n- UUID v4 format: `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`\n- Returned by function execution endpoints\n- Valid for the lifetime of the function execution\n- Expires after completion or timeout\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **No Restrictions:** Not subject to bearer protection or IP-based ACL restrictions\n- **No Authentication:** Cannot be restricted by any configuration\n- **Access:** Available to anyone who can reach the agent's HTTP endpoint\n",
        "parameters": [
          {
            "name": "transaction",
            "in": "query",
            "required": true,
            "description": "Transaction ID (UUID) of the function execution to track. This ID is returned\nwhen initiating a function execution via `/api/v3/function` or similar endpoints.\n\n**UUID Format:**\n- Standard UUID v4 format\n- Example: `550e8400-e29b-41d4-a716-446655440000`\n- Case-insensitive\n\n**Transaction Lifecycle:**\n- **Created**: When function execution starts\n- **Active**: While function is running\n- **Expired**: After completion, failure, or timeout\n- **Retention**: Transaction state kept briefly after completion for final status retrieval\n\n**Invalid Transaction Handling:**\n- Missing transaction: Returns 400 Bad Request\n- Malformed UUID: Returns 400 Bad Request\n- Expired transaction: Returns 404 Not Found\n- Unknown transaction: Returns 404 Not Found\n",
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "example": "550e8400-e29b-41d4-a716-446655440000"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved progress information for the transaction.\n\nReturns current progress status including percentage complete, state, and optional message.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "transaction": {
                      "type": "string",
                      "format": "uuid",
                      "description": "The transaction ID being tracked"
                    },
                    "status": {
                      "type": "string",
                      "enum": [
                        "running",
                        "completed",
                        "failed",
                        "cancelled"
                      ],
                      "description": "Current status of the function execution"
                    },
                    "percentage": {
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 100,
                      "description": "Completion percentage (0-100)"
                    },
                    "message": {
                      "type": "string",
                      "description": "Human-readable status message or error description"
                    },
                    "done": {
                      "type": "integer",
                      "description": "Number of items processed (if applicable)"
                    },
                    "all": {
                      "type": "integer",
                      "description": "Total number of items to process (if applicable)"
                    },
                    "eta_seconds": {
                      "type": "integer",
                      "description": "Estimated time remaining in seconds (if available)"
                    }
                  }
                },
                "examples": {
                  "running": {
                    "value": {
                      "transaction": "550e8400-e29b-41d4-a716-446655440000",
                      "status": "running",
                      "percentage": 45,
                      "message": "Processing data...",
                      "done": 450,
                      "all": 1000,
                      "eta_seconds": 30
                    }
                  },
                  "completed": {
                    "value": {
                      "transaction": "550e8400-e29b-41d4-a716-446655440000",
                      "status": "completed",
                      "percentage": 100,
                      "message": "Function execution completed successfully"
                    }
                  },
                  "failed": {
                    "value": {
                      "transaction": "550e8400-e29b-41d4-a716-446655440000",
                      "status": "failed",
                      "percentage": 67,
                      "message": "Error: timeout during data collection"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Missing transaction parameter\n- Malformed UUID format\n- Invalid transaction ID format\n"
          },
          "404": {
            "description": "Transaction not found. Possible reasons:\n- Transaction ID does not exist\n- Transaction has expired (completed/failed long ago)\n- Transaction was never created\n"
          },
          "500": {
            "description": "Internal server error during progress tracking."
          }
        }
      }
    },
    "/api/v3/function": {
      "get": {
        "operationId": "function3",
        "tags": [
          "functions"
        ],
        "summary": "Execute a Netdata function on a specific node",
        "description": "Executes a named function on a Netdata agent to retrieve live information or trigger actions.\nFunctions are plugin-provided operations that can query system state, collect real-time data,\nor perform administrative tasks.\n\n**What are Netdata Functions?**\nFunctions extend Netdata beyond passive metric collection by allowing:\n- **Live data queries**: Get current system state (processes, connections, services)\n- **Interactive diagnostics**: Run on-demand checks and analysis\n- **Administrative operations**: Trigger actions like cache clearing or config reloading\n- **Plugin-specific features**: Access specialized capabilities provided by plugins\n\n**Common Functions Include:**\n- `systemd-list-units` - List systemd services and their status\n- `processes` - List currently running processes with resource usage\n- `network-connections` - Show active network connections\n- `mount-points` - Display mounted filesystems\n- `docker-containers` - List Docker containers (if Docker plugin enabled)\n- Many more plugin-specific functions\n\n**Function Discovery:**\nUse `/api/v3/functions` to discover available functions on each node.\n\n**Execution Model:**\n- Functions execute on the target node's agent\n- Results are collected and returned in real-time\n- Long-running functions return a transaction ID for progress tracking\n- Functions may require specific permissions or capabilities\n\n**Use Cases:**\n- **System diagnostics**: Query live system state for troubleshooting\n- **Capacity planning**: Get current resource utilization details\n- **Security auditing**: List processes, connections, open ports\n- **Service management**: Check service status across infrastructure\n- **Interactive dashboards**: Provide drill-down capabilities\n\n**Common Usage Patterns:**\n\n1. **List running processes:**\n   ```\n   /api/v3/function?function=processes\n   ```\n\n2. **List systemd services:**\n   ```\n   /api/v3/function?function=systemd-list-units&timeout=30\n   ```\n\n3. **Get network connections:**\n   ```\n   /api/v3/function?function=network-connections\n   ```\n\n4. **Execute with custom timeout for slow operations:**\n   ```\n   /api/v3/function?function=docker-containers&timeout=60\n   ```\n\n**Function Response Formats:**\n- Most functions return JSON data\n- Some may return plain text or formatted output\n- Check Content-Type header for response format\n- Long operations may return transaction ID for `/api/v3/progress` polling\n\n**Security Considerations:**\n- Functions respect user authentication and authorization\n- Some functions may require elevated permissions\n- Function execution is subject to ACL checks\n- Sensitive operations may be restricted by configuration\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "function",
            "in": "query",
            "required": true,
            "description": "Name of the function to execute. Each Netdata plugin can provide multiple functions\nwith different capabilities.\n\n**Function Names:**\n- Kebab-case naming: `function-name-here`\n- Provided by plugins: different plugins provide different functions\n- Discoverable via `/api/v3/functions` endpoint\n- Case-sensitive\n\n**Common Built-in Functions:**\n- `systemd-list-units` - List systemd services\n- `processes` - Running processes with CPU/memory usage\n- `network-connections` - Active network connections and sockets\n- `mount-points` - Mounted filesystems and usage\n- `ipmi-sensors` - IPMI hardware sensors (if available)\n\n**Plugin-Specific Functions:**\n- Docker plugin: `docker-containers`, `docker-images`\n- Apps plugin: `apps-processes`\n- Logs plugin: `logs-query`\n- And many more depending on enabled plugins\n\n**Invalid Function Names:**\n- Missing function: Returns 400 Bad Request\n- Unknown function: Returns 404 Not Found or function-specific error\n- Disabled function: Returns 403 Forbidden\n",
            "schema": {
              "type": "string"
            },
            "example": "processes"
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "description": "Maximum time in seconds to wait for function execution before timing out.\nDifferent functions have different execution times.\n\n**Timeout Guidelines by Function Type:**\n- **Fast queries** (< 1s): processes, mount-points\n  Recommended: 10-30 seconds\n- **Medium queries** (1-5s): systemd-list-units, network-connections\n  Recommended: 30-60 seconds\n- **Slow operations** (5-30s): docker operations, log queries\n  Recommended: 60-300 seconds\n\n**Timeout Behavior:**\n- If execution completes before timeout: Returns results immediately\n- If timeout expires: Function is cancelled and error returned\n- For async functions: Returns transaction ID immediately, timeout applies to overall operation\n\n**Best Practices:**\n- Set conservative timeouts for production systems\n- Consider network latency for remote nodes\n- Monitor timeout errors and adjust accordingly\n",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 3600,
              "default": 60
            },
            "example": 30
          }
        ],
        "responses": {
          "200": {
            "description": "Function executed successfully and returned results.\n\nThe response format depends on the specific function:\n- Most functions return JSON data\n- Some return plain text or formatted output\n- Check Content-Type header\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Function-specific response data"
                },
                "examples": {
                  "processes": {
                    "value": {
                      "processes": [
                        {
                          "pid": 1234,
                          "name": "nginx",
                          "cpu": 2.5,
                          "memory": 45678
                        },
                        {
                          "pid": 5678,
                          "name": "postgres",
                          "cpu": 15.3,
                          "memory": 234567
                        }
                      ]
                    }
                  },
                  "systemd_units": {
                    "value": {
                      "units": [
                        {
                          "name": "nginx.service",
                          "state": "active",
                          "substate": "running"
                        },
                        {
                          "name": "postgresql.service",
                          "state": "active",
                          "substate": "running"
                        }
                      ]
                    }
                  }
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string",
                  "description": "Plain text response from function"
                }
              }
            }
          },
          "202": {
            "description": "Function execution started asynchronously. Use the returned transaction ID\nto poll `/api/v3/progress` for status and results.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "transaction": {
                      "type": "string",
                      "format": "uuid",
                      "description": "Transaction ID for progress tracking"
                    },
                    "message": {
                      "type": "string",
                      "description": "Status message"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Missing required `function` parameter\n- Invalid function name format\n- Invalid request body for the function\n"
          },
          "403": {
            "description": "Forbidden. Possible reasons:\n- Function requires higher permissions than current user has\n- Function is disabled in configuration\n- ACL restrictions prevent execution\n"
          },
          "404": {
            "description": "Function not found. The specified function does not exist or is not available on this node.\n"
          },
          "500": {
            "description": "Internal server error during function execution."
          },
          "503": {
            "description": "Service unavailable. Netdata agent is not ready or function execution system is overloaded.\n"
          },
          "504": {
            "description": "Function execution timeout - operation took longer than specified timeout."
          }
        }
      },
      "post": {
        "operationId": "function3_post",
        "tags": [
          "functions"
        ],
        "summary": "Execute a Netdata function with request body parameters",
        "description": "Same as GET /api/v3/function, but allows passing parameters via request body for functions\nthat require complex input or configuration data.\n\nUse this method when:\n- Function requires complex parameters that don't fit in query string\n- Passing sensitive data that shouldn't be in URL\n- Function accepts JSON configuration or structured data\n\nSee GET /api/v3/function for complete documentation on functions, timeouts, and responses.\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "function",
            "in": "query",
            "required": true,
            "description": "Name of the function to execute (see GET method for details)",
            "schema": {
              "type": "string"
            },
            "example": "processes"
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "description": "Maximum time in seconds to wait for function execution (see GET method for details)",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 3600,
              "default": 60
            },
            "example": 30
          }
        ],
        "requestBody": {
          "description": "Optional request body for functions that accept parameters or configuration.\nThe format and content depend on the specific function being executed.\n\n**When to Use Request Body:**\n- Functions that accept filtering parameters\n- Functions that need configuration data\n- Functions with complex input requirements\n\n**Common Patterns:**\n- JSON object with function-specific parameters\n- Plain text for simple commands\n- Format specified by function documentation\n\n**Example for logs-query function:**\n```json\n{\n  \"after\": -3600,\n  \"before\": 0,\n  \"filter\": \"error\",\n  \"limit\": 100\n}\n```\n",
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Function-specific parameters (varies by function)"
              }
            },
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "Plain text parameters for simple functions"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Function executed successfully (see GET method for response details)",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              },
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "202": {
            "description": "Function execution started asynchronously (see GET method for details)"
          },
          "400": {
            "description": "Bad request (see GET method for details)"
          },
          "403": {
            "description": "Forbidden (see GET method for details)"
          },
          "404": {
            "description": "Function not found (see GET method for details)"
          },
          "500": {
            "description": "Internal server error (see GET method for details)"
          },
          "503": {
            "description": "Service unavailable (see GET method for details)"
          },
          "504": {
            "description": "Function execution timeout (see GET method for details)"
          }
        }
      }
    },
    "/api/v3/functions": {
      "get": {
        "operationId": "functions3",
        "tags": [
          "functions"
        ],
        "summary": "List available functions across all nodes",
        "description": "Retrieves a catalog of available functions across the monitored infrastructure.\nFunctions are plugin-provided operations that extend Netdata's capabilities beyond\npassive metric collection, allowing live queries, diagnostics, and administrative actions.\n\n**What This Endpoint Returns:**\n- **Function inventory**: All functions available across your nodes\n- **Per-node availability**: Which functions each node supports\n- **Function metadata**: Descriptions, parameters, requirements\n- **Plugin information**: Which plugin provides each function\n\n**Function Categories:**\n- **System queries**: processes, mount-points, network-connections\n- **Service management**: systemd-list-units, docker-containers\n- **Hardware**: ipmi-sensors, smart-disk-info\n- **Application-specific**: mysql-queries, redis-info, nginx-status\n- **Diagnostics**: performance-analysis, log-queries\n- **Administrative**: config-reload, cache-clear\n\n**Use Cases:**\n- **Capability discovery**: Determine what operations are available\n- **Multi-node comparison**: See which nodes support which functions\n- **Plugin verification**: Confirm plugins are loaded and functional\n- **UI generation**: Build dynamic interfaces based on available functions\n- **Documentation**: Generate function reference for your infrastructure\n\n**Common Usage Patterns:**\n\n1. **List all functions across all nodes:**\n   ```\n   /api/v3/functions\n   ```\n\n2. **Functions for specific nodes:**\n   ```\n   /api/v3/functions?nodes=web-*\n   ```\n\n3. **Scope to production infrastructure:**\n   ```\n   /api/v3/functions?scope_nodes=prod-*\n   ```\n\n4. **Get detailed function information:**\n   ```\n   /api/v3/functions?options=debug\n   ```\n\n**Response Organization:**\nResults grouped by:\n- **Node**: Functions available on each node\n- **Function name**: Unique identifier\n- **Plugin**: Source plugin providing the function\n- **Capabilities**: What the function can do\n\n**Integration with /api/v3/function:**\n1. Use `/api/v3/functions` to discover available functions\n2. Use `/api/v3/function?function=<name>` to execute specific functions\n3. Results tell you which nodes support which operations\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "scope_nodes",
            "in": "query",
            "required": false,
            "description": "Simple pattern to match node hostnames for scope filtering. Uses Netdata's simple pattern\nmatching (not regex). Matched nodes define the scope for function discovery.\n\n**Pattern Syntax:**\n- `*` matches any number of characters\n- Use `|` to separate multiple patterns (OR logic)\n- Matches are case-insensitive\n- No regex support - only simple wildcards\n\n**Examples:**\n- `prod-*` - All production nodes\n- `*-web-*` - All web server nodes\n- `db-*|cache-*` - All database or cache nodes\n- `*` - All nodes (default)\n",
            "schema": {
              "type": "string",
              "default": "*"
            },
            "example": "prod-*"
          },
          {
            "name": "nodes",
            "in": "query",
            "required": false,
            "description": "Simple pattern to filter which nodes to include in the functions list.\nAfter scope is determined, this filters the results. Uses the same pattern syntax as scope_nodes.\n\n**Difference from scope_nodes:**\n- `scope_nodes` defines what nodes to query for functions\n- `nodes` filters which nodes appear in the output\n\n**Examples:**\n- `web-*` - Only show functions from web servers\n- Specific hostnames: `node1|node2|node3`\n",
            "schema": {
              "type": "string",
              "default": "*"
            },
            "example": "*"
          },
          {
            "name": "options",
            "in": "query",
            "required": false,
            "description": "Comma-separated list of options to control response content and format.\n\n**Available Options:**\n- `minify` - Minimize JSON output (no pretty-printing)\n- `debug` - Include detailed function metadata and plugin information\n- `raw` - Include raw function definitions\n\n**Examples:**\n- `minify` - Compact JSON response\n- `debug,raw` - Full debug information\n",
            "schema": {
              "type": "string"
            },
            "example": "debug"
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "description": "Maximum time in seconds to wait for the query to complete before timing out.\n\n**Guidelines:**\n- Recommended: 10-30 seconds for most queries\n- Function listing is usually fast\n- Timeout mainly applies to very large infrastructures\n",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "default": 60
            },
            "example": 10
          },
          {
            "name": "cardinality",
            "in": "query",
            "required": false,
            "description": "Maximum number of nodes to include in the response to prevent overwhelming large responses.\nWhen this limit is exceeded, the response will indicate how many nodes were omitted.\n\n**Purpose:**\n- Prevent memory exhaustion from very large infrastructures\n- Control response size for performance\n- Useful when exploring large node sets incrementally\n\n**Recommendations:**\n- Small infrastructures (< 100 nodes): Use default\n- Medium infrastructures (100-1000 nodes): 500-1000\n- Large infrastructures (> 1000 nodes): Use filtering or increase limit carefully\n",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 10000,
              "default": 1000
            },
            "example": 500
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved functions catalog.\n\nReturns available functions organized by node, with metadata about each function\nincluding name, description, plugin source, and parameter requirements.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "nodes": {
                      "type": "array",
                      "description": "Array of nodes with their available functions",
                      "items": {
                        "type": "object",
                        "properties": {
                          "hostname": {
                            "type": "string",
                            "description": "Node hostname"
                          },
                          "machine_guid": {
                            "type": "string",
                            "description": "Unique node identifier"
                          },
                          "functions": {
                            "type": "array",
                            "description": "Functions available on this node",
                            "items": {
                              "type": "object",
                              "properties": {
                                "name": {
                                  "type": "string",
                                  "description": "Function name",
                                  "example": "processes"
                                },
                                "plugin": {
                                  "type": "string",
                                  "description": "Plugin providing this function",
                                  "example": "apps.plugin"
                                },
                                "description": {
                                  "type": "string",
                                  "description": "Human-readable function description"
                                },
                                "parameters": {
                                  "type": "array",
                                  "description": "Required or optional parameters",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "name": {
                                        "type": "string"
                                      },
                                      "required": {
                                        "type": "boolean"
                                      },
                                      "description": {
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "omitted": {
                      "type": "integer",
                      "description": "Number of nodes omitted due to cardinality limit"
                    }
                  }
                },
                "examples": {
                  "functions_list": {
                    "value": {
                      "nodes": [
                        {
                          "hostname": "web-server-1",
                          "machine_guid": "12345678-1234-1234-1234-123456789012",
                          "functions": [
                            {
                              "name": "processes",
                              "plugin": "apps.plugin",
                              "description": "List running processes with resource usage"
                            },
                            {
                              "name": "systemd-list-units",
                              "plugin": "systemd.plugin",
                              "description": "List systemd services and their status"
                            },
                            {
                              "name": "network-connections",
                              "plugin": "network.plugin",
                              "description": "Show active network connections"
                            }
                          ]
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters provided (e.g., invalid pattern syntax)."
          },
          "500": {
            "description": "Internal server error during functions listing."
          },
          "504": {
            "description": "Query timeout - functions collection took too long."
          }
        }
      }
    },
    "/api/v3/config": {
      "get": {
        "operationId": "config3",
        "tags": [
          "config"
        ],
        "summary": "Manage Netdata dynamic configuration",
        "description": "Provides access to Netdata's dynamic configuration system, allowing retrieval, modification,\nand management of configuration across plugins and data collectors.\n\n**Dynamic Configuration System:**\nNetdata's dyncfg system allows runtime configuration management without restarting the agent:\n- **View configuration tree**: Browse all configurable components\n- **Get current config**: Retrieve active configuration for any component\n- **Update configuration**: Modify settings on-the-fly\n- **Add/remove jobs**: Manage data collection jobs dynamically\n- **Enable/disable**: Toggle components without editing files\n- **Test configuration**: Validate changes before applying\n\n**Configuration Hierarchy:**\n```\n/ (root)\n├── collectors/\n│   ├── plugins.d/\n│   ├── python.d/\n│   ├── go.d/\n│   └── ...\n├── health/\n└── streaming/\n```\n\n**Common Actions:**\n- `tree` - Browse configuration hierarchy\n- `get` - Retrieve current configuration\n- `schema` - Get configuration schema/template\n- `update` - Modify existing configuration\n- `add` - Create new job/instance\n- `remove` - Delete job/instance\n- `enable` - Activate disabled component\n- `disable` - Deactivate component\n- `test` - Validate configuration without applying\n- `restart` - Restart component with new config\n- `userconfig` - Get user-editable configuration\n\n**Use Cases:**\n- **Configuration management**: Centrally manage agent configuration\n- **Job provisioning**: Add new data collection jobs without restart\n- **A/B testing**: Test configuration changes before deployment\n- **Automation**: Integrate with configuration management tools\n- **Troubleshooting**: View and modify settings for debugging\n\n**Common Usage Patterns:**\n\n1. **Browse configuration tree:**\n   ```\n   /api/v3/config?action=tree&path=/\n   ```\n\n2. **Get configuration for a specific component:**\n   ```\n   /api/v3/config?action=get&id=collectors:go.d:prometheus\n   ```\n\n3. **Get configuration schema:**\n   ```\n   /api/v3/config?action=schema&id=collectors:go.d:prometheus\n   ```\n\n4. **Add new data collection job:**\n   ```\n   POST /api/v3/config?action=add&id=collectors:go.d:prometheus&name=my-app\n   Content-Type: application/json\n\n   {\n     \"url\": \"http://my-app:9090/metrics\",\n     \"update_every\": 10\n   }\n   ```\n\n5. **Update existing configuration:**\n   ```\n   POST /api/v3/config?action=update&id=collectors:go.d:prometheus:my-app\n   Content-Type: application/json\n\n   {\n     \"update_every\": 5\n   }\n   ```\n\n6. **Test configuration before applying:**\n   ```\n   POST /api/v3/config?action=test&id=collectors:go.d:prometheus&name=test-job\n   [configuration JSON]\n   ```\n\n**ID Format:**\nConfiguration IDs use colon-separated hierarchical paths:\n- `collectors:go.d:prometheus` - Plugin/collector level\n- `collectors:go.d:prometheus:job-name` - Specific job/instance\n- `health:notifications` - Health alert notifications\n\n**Request Body:**\nFor `update`, `add`, and `test` actions, provide configuration as JSON in request body.\nUse `schema` action to get the expected configuration structure.\n\n**Security:**\n- Configuration changes require appropriate permissions\n- Some actions may be restricted by ACL\n- Changes are logged for audit trail\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "required": false,
            "description": "Configuration action to perform. Different actions require different additional parameters.\n\n**Available Actions:**\n\n- **`tree`** (default): Browse configuration hierarchy\n  - Additional params: `path` (optional, default \"/\"), `id` (optional)\n  - Returns: Tree structure of configurable components\n\n- **`get`**: Retrieve current configuration\n  - Required params: `id`\n  - Returns: Current active configuration\n\n- **`schema`**: Get configuration schema/template\n  - Required params: `id`\n  - Returns: Schema defining valid configuration structure\n\n- **`update`**: Modify existing configuration\n  - Required params: `id`\n  - Request body: JSON with configuration changes\n  - Returns: Success/error status\n\n- **`add`**: Create new job/instance\n  - Required params: `id`, `name`\n  - Request body: JSON with initial configuration\n  - Returns: Success/error status\n\n- **`remove`**: Delete job/instance\n  - Required params: `id`\n  - Returns: Success/error status\n\n- **`enable`**: Activate disabled component\n  - Required params: `id`\n  - Returns: Success/error status\n\n- **`disable`**: Deactivate component without removing\n  - Required params: `id`\n  - Returns: Success/error status\n\n- **`test`**: Validate configuration without applying\n  - Required params: `id`, `name`\n  - Request body: JSON with configuration to test\n  - Returns: Validation results\n\n- **`restart`**: Restart component with new configuration\n  - Required params: `id`\n  - Returns: Success/error status\n\n- **`userconfig`**: Get user-editable configuration file\n  - Required params: `id`\n  - Returns: Configuration in user-editable format\n",
            "schema": {
              "type": "string",
              "enum": [
                "tree",
                "get",
                "schema",
                "update",
                "add",
                "remove",
                "enable",
                "disable",
                "test",
                "restart",
                "userconfig"
              ],
              "default": "tree"
            },
            "example": "tree"
          },
          {
            "name": "path",
            "in": "query",
            "required": false,
            "description": "Path in configuration tree when using `action=tree`.\nSpecifies which branch of the configuration hierarchy to explore.\n\n**Path Format:**\n- Root: `/`\n- Collectors: `/collectors`\n- Specific plugin: `/collectors/go.d`\n- Health: `/health`\n\n**Examples:**\n- `/` - Root level (all categories)\n- `/collectors` - All collectors\n- `/collectors/go.d` - Go collectors\n",
            "schema": {
              "type": "string",
              "default": "/"
            },
            "example": "/collectors"
          },
          {
            "name": "id",
            "in": "query",
            "required": false,
            "description": "Configuration component ID using colon-separated hierarchical notation.\nRequired for most actions except `tree`.\n\n**ID Format:**\n`category:plugin:collector[:job-name]`\n\n**Examples:**\n- `collectors:go.d:prometheus` - Prometheus collector\n- `collectors:go.d:prometheus:local` - Specific Prometheus job \"local\"\n- `collectors:python.d:nginx` - Nginx Python collector\n- `health:notifications` - Health notification settings\n\n**ID Validation:**\n- Alphanumeric characters, dots, underscores, hyphens\n- Colons separate hierarchy levels\n- Invalid IDs return 400 Bad Request\n",
            "schema": {
              "type": "string"
            },
            "example": "collectors:go.d:prometheus"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "description": "Name for new job/instance when using `action=add` or `action=test`.\n\n**Name Requirements:**\n- Alphanumeric characters, dots, underscores, hyphens\n- Must be unique within the collector/plugin\n- Will be appended to `id` to form full configuration path\n\n**Examples:**\n- If `id=collectors:go.d:prometheus` and `name=my-app`\n- Full config ID becomes: `collectors:go.d:prometheus:my-app`\n\n**Invalid Names:**\n- Empty or missing (when required): Returns 400 Bad Request\n- Special characters: Returns 400 Bad Request\n- Duplicate name: May return error or override behavior depends on action\n",
            "schema": {
              "type": "string"
            },
            "example": "my-app"
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "description": "Maximum time in seconds to wait for configuration operation to complete.\n\n**Timeout Guidelines:**\n- Read operations (get, schema, tree): 10-30 seconds\n- Write operations (update, add, remove): 30-120 seconds\n- Test operations: 60-120 seconds (may involve validation checks)\n- Restart operations: 120-300 seconds (component restart time)\n\n**Minimum:** 10 seconds (enforced by code)\n**Default:** 120 seconds\n",
            "schema": {
              "type": "integer",
              "minimum": 10,
              "maximum": 3600,
              "default": 120
            },
            "example": 60
          }
        ],
        "responses": {
          "200": {
            "description": "Configuration operation completed successfully.\n\nResponse format depends on the action:\n- `tree`: Configuration hierarchy tree\n- `get`: Current configuration JSON\n- `schema`: Configuration schema/template\n- `update`/`add`/`remove`: Success confirmation\n- `test`: Validation results\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Action-specific response data"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Invalid action name\n- Missing required parameters (`id`, `name`)\n- Invalid `id` or `name` format\n- Malformed request body JSON\n"
          },
          "403": {
            "description": "Forbidden. Configuration change requires higher permissions.\n"
          },
          "404": {
            "description": "Configuration component not found. The specified `id` does not exist.\n"
          },
          "500": {
            "description": "Internal server error during configuration operation."
          },
          "504": {
            "description": "Configuration operation timeout."
          }
        }
      },
      "post": {
        "operationId": "config3_post",
        "tags": [
          "config"
        ],
        "summary": "Manage Netdata configuration with request body data",
        "description": "Same as GET /api/v3/config, but allows passing configuration data via request body\nfor actions like `update`, `add`, and `test`.\n\nUse this method when:\n- Updating existing configuration (`action=update`)\n- Adding new jobs/instances (`action=add`)\n- Testing configuration before applying (`action=test`)\n\nSee GET /api/v3/config for complete documentation on actions, parameters, and responses.\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "required": false,
            "description": "Configuration action to perform (see GET method for details)",
            "schema": {
              "type": "string",
              "enum": [
                "tree",
                "get",
                "schema",
                "update",
                "add",
                "remove",
                "enable",
                "disable",
                "test",
                "restart",
                "userconfig"
              ],
              "default": "tree"
            },
            "example": "update"
          },
          {
            "name": "path",
            "in": "query",
            "required": false,
            "description": "Path in configuration tree (see GET method for details)",
            "schema": {
              "type": "string",
              "default": "/"
            },
            "example": "/collectors"
          },
          {
            "name": "id",
            "in": "query",
            "required": false,
            "description": "Configuration component ID (see GET method for details)",
            "schema": {
              "type": "string"
            },
            "example": "collectors:go.d:prometheus"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "description": "Name for new job/instance (see GET method for details)",
            "schema": {
              "type": "string"
            },
            "example": "my-app"
          },
          {
            "name": "timeout",
            "in": "query",
            "required": false,
            "description": "Maximum timeout in seconds (see GET method for details)",
            "schema": {
              "type": "integer",
              "minimum": 10,
              "maximum": 3600,
              "default": 120
            },
            "example": 60
          }
        ],
        "requestBody": {
          "description": "Configuration data for `update`, `add`, and `test` actions.\n\n**Format:**\n- Content-Type: application/json\n- Structure depends on the specific configuration component\n- Use `action=schema` to get the expected structure\n\n**Example for adding Prometheus job:**\n```json\n{\n  \"url\": \"http://localhost:9090/metrics\",\n  \"update_every\": 10,\n  \"autodetection_retry\": 0\n}\n```\n\n**Example for updating existing config:**\n```json\n{\n  \"update_every\": 5,\n  \"timeout\": 30\n}\n```\n",
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "description": "Configuration-specific data structure"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Configuration operation completed successfully (see GET method for response details)",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "Bad request (see GET method for details)"
          },
          "403": {
            "description": "Forbidden (see GET method for details)"
          },
          "404": {
            "description": "Configuration component not found (see GET method for details)"
          },
          "500": {
            "description": "Internal server error (see GET method for details)"
          },
          "504": {
            "description": "Configuration operation timeout (see GET method for details)"
          }
        }
      }
    },
    "/api/v3/settings": {
      "get": {
        "operationId": "settings_get",
        "tags": [
          "settings"
        ],
        "summary": "Retrieve user settings/preferences (GET)",
        "description": "**V3 SPECIFIC ENDPOINT**\n\nRetrieves stored user settings and preferences from Netdata's settings storage.\nThe settings API provides persistent key-value storage for UI preferences, dashboard layouts,\nalert configurations, and other user-specific data.\n\n**Settings System:**\n- **Persistent storage**: Settings survive agent restarts\n- **Version-controlled**: Each update increments version for conflict detection\n- **User-scoped**: Authenticated users can have multiple named settings files\n- **Anonymous access**: Limited to 'default' file only\n- **JSON format**: All settings stored as JSON with mandatory 'version' field\n\n**File-Based Storage:**\nSettings are stored as individual files in Netdata's var/lib directory:\n- Anonymous users: Only `file=default` allowed\n- Authenticated users: Can create custom files (e.g., `file=my-dashboard`)\n- File names: Alphanumeric, dashes, underscores only\n\n**Version Control:**\nEach settings object has a `version` field:\n- Starts at version 1 for new files\n- Auto-incremented on each PUT operation\n- Used for optimistic locking to prevent conflicts\n\n**Use Cases:**\n- **Dashboard preferences**: Store layout, theme, selected metrics\n- **Alert customization**: Save user-specific alert thresholds\n- **UI state**: Remember filters, time ranges, node selections\n- **Multi-device sync**: Share settings across browsers/devices (for authenticated users)\n\n**Common Usage Patterns:**\n\n1. **Get default settings (anonymous user):**\n   ```\n   GET /api/v3/settings?file=default\n   ```\n\n2. **Get named settings file (authenticated):**\n   ```\n   GET /api/v3/settings?file=production-dashboard\n   ```\n\n**Response Structure:**\n```json\n{\n  \"version\": 3,\n  \"theme\": \"dark\",\n  \"defaultTimeRange\": \"-3600\",\n  \"favoriteMetrics\": [\"system.cpu\", \"system.ram\"]\n}\n```\n\n**New Files:**\nIf requested file doesn't exist, returns initial version:\n```json\n{\n  \"version\": 1\n}\n```\n\n**Size Limit:**\nMaximum settings file size: 20 MiB\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **No Restrictions:** Not subject to bearer protection or IP-based ACL restrictions\n- **No Authentication:** Cannot be restricted by any configuration\n- **Access:** Available to anyone who can reach the agent's HTTP endpoint\n",
        "parameters": [
          {
            "name": "file",
            "in": "query",
            "required": false,
            "description": "Name of the settings file to retrieve.\n\n**File Naming Rules:**\n- Alphanumeric characters only\n- Dashes (-) and underscores (_) allowed\n- No spaces or special characters\n- Case-sensitive\n\n**Access Control:**\n- **Anonymous users**: Only `file=default` allowed\n- **Authenticated users (bearer token)**: Any valid file name\n\n**Examples:**\n- `default` - Default settings file\n- `my-dashboard` - Custom dashboard settings\n- `prod-alerts` - Production alert preferences\n- `mobile-view` - Mobile UI settings\n\n**Invalid File Names:**\n- Missing or empty: Returns 400 Bad Request\n- Special characters: Returns 400 Bad Request\n- Non-default for anonymous: Returns 400 Bad Request\n",
            "schema": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "default": "default"
            },
            "example": "default"
          }
        ],
        "responses": {
          "200": {
            "description": "Settings file retrieved successfully.\n\nReturns JSON object with at minimum a `version` field.\nMay contain any additional user-defined fields.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "version"
                  ],
                  "properties": {
                    "version": {
                      "type": "integer",
                      "description": "Current version number (auto-incremented on updates)",
                      "minimum": 1
                    }
                  },
                  "additionalProperties": true
                },
                "examples": {
                  "new_file": {
                    "value": {
                      "version": 1
                    },
                    "summary": "Newly created settings file with just version"
                  },
                  "existing_file": {
                    "value": {
                      "version": 5,
                      "theme": "dark",
                      "language": "en",
                      "dashboard": {
                        "layout": "grid",
                        "columns": 3
                      },
                      "notifications": {
                        "enabled": true,
                        "sound": false
                      }
                    },
                    "summary": "Existing settings with custom fields"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Invalid file name (contains special characters)\n- Anonymous user trying to access non-default file\n- Empty file name\n"
          },
          "500": {
            "description": "Internal server error during settings retrieval."
          }
        }
      },
      "put": {
        "operationId": "settings_put",
        "tags": [
          "settings"
        ],
        "summary": "Create or update user settings/preferences (PUT)",
        "description": "**V3 SPECIFIC ENDPOINT**\n\nCreates or updates user settings with optimistic locking to prevent concurrent modification conflicts.\n\n**Update Process:**\n1. Client GET current settings (to get current version)\n2. Client modifies settings locally\n3. Client PUT updated settings WITH ORIGINAL VERSION\n4. Netdata validates version matches current file\n5. If match: Update succeeds, version auto-incremented\n6. If mismatch: Returns 409 Conflict\n\n**Conflict Resolution (409 Response):**\nWhen you receive 409 Conflict:\n1. Another client updated the file\n2. GET the file again to retrieve latest version\n3. Reapply your changes to the new version\n4. PUT again with the new version number\n\n**Optimistic Locking Flow:**\n```javascript\n// 1. Get current settings\nconst response = await fetch('/api/v3/settings?file=my-dashboard');\nconst settings = await response.json(); // { version: 3, ... }\n\n// 2. Modify settings\nsettings.theme = 'dark';\n\n// 3. PUT with ORIGINAL version (still 3)\nconst result = await fetch('/api/v3/settings?file=my-dashboard', {\n  method: 'PUT',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(settings) // version: 3\n});\n\nif (result.status === 409) {\n  // Conflict! File was updated by another client\n  // Must GET again and retry\n}\n// If successful, file now has version: 4\n```\n\n**Payload Requirements:**\n- MUST be valid JSON\n- MUST include `version` field with current file version\n- MAY include any additional fields\n- Maximum size: 20 MiB\n\n**Version Management:**\n- Client provides current version in payload\n- Netdata verifies version matches file on disk\n- Netdata increments version before saving\n- Saved file has version + 1\n\n**Use Cases:**\n- Save dashboard configuration changes\n- Update user preferences\n- Store UI state\n- Persist alert customizations\n",
        "parameters": [
          {
            "name": "file",
            "in": "query",
            "required": false,
            "description": "Name of the settings file to create or update.\n\n**File Naming Rules:**\n- Alphanumeric characters only\n- Dashes (-) and underscores (_) allowed\n- No spaces or special characters\n- Case-sensitive\n\n**Access Control:**\n- **Anonymous users**: Only `file=default` allowed\n- **Authenticated users (bearer token)**: Any valid file name\n\n**File Creation:**\n- If file doesn't exist: Created with initial payload\n- If file exists: Updated with new payload (version check applies)\n",
            "schema": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "default": "default"
            },
            "example": "my-dashboard"
          }
        ],
        "requestBody": {
          "description": "JSON object containing settings data with mandatory `version` field.\n\n**Required Fields:**\n- `version`: Integer matching current file version (or 0 for non-existent files)\n\n**Optional Fields:**\n- Any user-defined fields\n\n**Size Limit:**\nMaximum 20 MiB\n\n**Version Rules:**\n- New file: version can be 0 or 1\n- Existing file: version MUST match current file version exactly\n- Mismatch causes 409 Conflict\n",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "version"
                ],
                "properties": {
                  "version": {
                    "type": "integer",
                    "description": "Current version from GET request",
                    "minimum": 0
                  }
                },
                "additionalProperties": true
              },
              "examples": {
                "create_new": {
                  "value": {
                    "version": 0,
                    "theme": "dark",
                    "language": "en"
                  },
                  "summary": "Creating new settings file"
                },
                "update_existing": {
                  "value": {
                    "version": 5,
                    "theme": "light",
                    "dashboard": {
                      "layout": "list"
                    }
                  },
                  "summary": "Updating existing file (version from previous GET)"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Settings updated successfully. Version has been incremented.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string",
                      "example": "OK"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Common causes:\n- Invalid file name\n- Missing `version` field in payload\n- Invalid JSON payload\n- Empty payload\n- Payload exceeds 20 MiB\n- Anonymous user trying to access non-default file\n"
          },
          "409": {
            "description": "Conflict. Version mismatch detected.\n\n**Resolution Steps:**\n1. GET current settings to retrieve latest version\n2. Reapply your changes to the new version\n3. PUT again with updated version number\n\nThis prevents lost updates when multiple clients modify settings concurrently.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string",
                      "example": "Payload version does not match the version of the stored object"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal server error during settings update."
          }
        }
      }
    },
    "/api/v3/stream_info": {
      "get": {
        "operationId": "stream_info",
        "tags": [
          "streaming"
        ],
        "summary": "Get streaming information and statistics",
        "description": "**V3 SPECIFIC ENDPOINT**\n\nReturns detailed information about Netdata's streaming connections, including sender/receiver\nstatistics, buffer usage, compression ratios, and connection health metrics.\n\n**Streaming Overview:**\nNetdata supports hierarchical streaming where:\n- **Child nodes** send metrics to **parent nodes** for centralization\n- **Parent nodes** aggregate and store metrics from multiple children\n- Streaming uses efficient binary protocol with compression\n- Connections can be TLS-encrypted and authenticated\n\n**Information Provided:**\n- **Connection status**: Active, established, disconnected\n- **Streaming statistics**: Bytes sent/received, compression ratios\n- **Buffer usage**: Current buffer fill levels, drops\n- **Performance metrics**: Streaming latency, throughput\n- **Replication status**: Data replication lag and progress\n- **Protocol version**: Streaming protocol version in use\n\n**Use Cases:**\n- **Monitor streaming health**: Ensure children are connected and streaming\n- **Troubleshoot connectivity**: Identify disconnections and buffer issues\n- **Performance analysis**: Check compression ratios and throughput\n- **Capacity planning**: Monitor buffer usage and network bandwidth\n- **Replication monitoring**: Track data replication status\n\n**Common Usage Patterns:**\n\n1. **Get streaming info for localhost:**\n   ```\n   /api/v3/stream_info\n   ```\n\n2. **Get streaming info for specific node:**\n   ```\n   /api/v3/stream_info?machine_guid=12345678-1234-1234-1234-123456789012\n   ```\n\n**Response Structure:**\nReturns streaming information including:\n- Parent/child relationship status\n- Connection uptime and reconnection count\n- Bytes sent/received with compression ratios\n- Buffer usage (current size, maximum size, drops)\n- Replication lag and status\n- Stream protocol version\n\n**Streaming Modes:**\n- **Sender mode**: Node is streaming data TO a parent\n- **Receiver mode**: Node is receiving data FROM children\n- **Both**: Node can be both sender and receiver\n\n**Health Indicators:**\n- `connected: true/false` - Connection status\n- `buffer_used_percentage` - Buffer fill level\n- `compression_ratio` - Data compression efficiency\n- `replication_lag_seconds` - Data replication delay\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **No Restrictions:** Not subject to bearer protection or IP-based ACL restrictions\n- **No Authentication:** Cannot be restricted by any configuration\n- **Access:** Available to anyone who can reach the agent's HTTP endpoint\n",
        "parameters": [
          {
            "name": "machine_guid",
            "in": "query",
            "required": false,
            "description": "Machine GUID (unique node identifier) to query streaming information for.\nIf not specified, returns streaming information for the local agent.\n\n**GUID Format:**\n- UUID format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`\n- Case-insensitive\n- Can be obtained from `/api/v3/nodes` endpoint\n\n**Use Cases:**\n- Query specific child node's streaming status\n- Check parent node's connection to specific child\n- Diagnostic queries for particular node\n\n**Examples:**\n- `12345678-1234-1234-1234-123456789012` - Specific node\n- Empty/omitted - Local agent (default)\n\n**Invalid GUIDs:**\n- Malformed UUID: May return error or empty result\n- Non-existent GUID: Returns empty or not-found response\n",
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "example": "12345678-1234-1234-1234-123456789012"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved streaming information.\n\nReturns streaming connection details, statistics, and health metrics.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "machine_guid": {
                      "type": "string",
                      "format": "uuid",
                      "description": "Node machine GUID"
                    },
                    "hostname": {
                      "type": "string",
                      "description": "Node hostname"
                    },
                    "streaming_mode": {
                      "type": "string",
                      "enum": [
                        "sender",
                        "receiver",
                        "both",
                        "none"
                      ],
                      "description": "Streaming mode of this node"
                    },
                    "sender": {
                      "type": "object",
                      "description": "Sender (child→parent) streaming information",
                      "properties": {
                        "connected": {
                          "type": "boolean",
                          "description": "Whether sender is currently connected to parent"
                        },
                        "parent_hostname": {
                          "type": "string",
                          "description": "Hostname of parent node"
                        },
                        "uptime_seconds": {
                          "type": "integer",
                          "description": "Connection uptime in seconds"
                        },
                        "reconnects": {
                          "type": "integer",
                          "description": "Number of reconnection attempts"
                        },
                        "bytes_sent": {
                          "type": "integer",
                          "description": "Total bytes sent"
                        },
                        "bytes_compressed": {
                          "type": "integer",
                          "description": "Bytes after compression"
                        },
                        "compression_ratio": {
                          "type": "number",
                          "description": "Compression ratio (original/compressed)"
                        },
                        "buffer_used_bytes": {
                          "type": "integer",
                          "description": "Current send buffer usage"
                        },
                        "buffer_max_bytes": {
                          "type": "integer",
                          "description": "Maximum send buffer size"
                        },
                        "buffer_used_percentage": {
                          "type": "number",
                          "description": "Buffer fill percentage"
                        },
                        "drops": {
                          "type": "integer",
                          "description": "Number of dropped metrics due to buffer overflow"
                        }
                      }
                    },
                    "receiver": {
                      "type": "object",
                      "description": "Receiver (parent←children) streaming information",
                      "properties": {
                        "children": {
                          "type": "array",
                          "description": "Connected child nodes",
                          "items": {
                            "type": "object",
                            "properties": {
                              "machine_guid": {
                                "type": "string",
                                "format": "uuid"
                              },
                              "hostname": {
                                "type": "string"
                              },
                              "connected": {
                                "type": "boolean"
                              },
                              "uptime_seconds": {
                                "type": "integer"
                              },
                              "bytes_received": {
                                "type": "integer"
                              },
                              "replication_lag_seconds": {
                                "type": "integer"
                              }
                            }
                          }
                        }
                      }
                    },
                    "protocol_version": {
                      "type": "integer",
                      "description": "Streaming protocol version"
                    }
                  }
                },
                "examples": {
                  "sender_info": {
                    "value": {
                      "machine_guid": "12345678-1234-1234-1234-123456789012",
                      "hostname": "child-node-1",
                      "streaming_mode": "sender",
                      "sender": {
                        "connected": true,
                        "parent_hostname": "parent-node",
                        "uptime_seconds": 86400,
                        "reconnects": 2,
                        "bytes_sent": 524288000,
                        "bytes_compressed": 104857600,
                        "compression_ratio": 5,
                        "buffer_used_bytes": 1048576,
                        "buffer_max_bytes": 10485760,
                        "buffer_used_percentage": 10,
                        "drops": 0
                      },
                      "protocol_version": 3
                    },
                    "summary": "Child node streaming to parent"
                  },
                  "receiver_info": {
                    "value": {
                      "machine_guid": "87654321-4321-4321-4321-210987654321",
                      "hostname": "parent-node",
                      "streaming_mode": "receiver",
                      "receiver": {
                        "children": [
                          {
                            "machine_guid": "12345678-1234-1234-1234-123456789012",
                            "hostname": "child-node-1",
                            "connected": true,
                            "uptime_seconds": 86400,
                            "bytes_received": 524288000,
                            "replication_lag_seconds": 2
                          },
                          {
                            "machine_guid": "23456789-2345-2345-2345-234567890123",
                            "hostname": "child-node-2",
                            "connected": true,
                            "uptime_seconds": 43200,
                            "bytes_received": 262144000,
                            "replication_lag_seconds": 1
                          }
                        ]
                      },
                      "protocol_version": 3
                    },
                    "summary": "Parent node receiving from children"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid machine_guid format."
          },
          "404": {
            "description": "Node with specified machine_guid not found."
          },
          "500": {
            "description": "Internal server error during streaming info retrieval."
          }
        }
      }
    },
    "/api/v3/rtc_offer": {
      "post": {
        "operationId": "rtcOffer3",
        "tags": [
          "webrtc"
        ],
        "summary": "Establish WebRTC peer connection by exchanging SDP offer/answer",
        "description": "**WebRTC Connection Establishment**\n\nThis endpoint implements the WebRTC signaling process for establishing peer-to-peer data connections with the Netdata agent. It follows the standard WebRTC negotiation flow using SDP (Session Description Protocol) offer/answer exchange.\n\n**How It Works:**\n1. Client creates a WebRTC peer connection and generates an SDP offer\n2. Client sends the SDP offer to this endpoint via POST request body\n3. Server processes the offer, configures ICE servers and connection parameters\n4. Server generates and returns an SDP answer with ICE candidates\n5. Client sets the answer to complete the WebRTC connection handshake\n6. Data channels can then be established for real-time communication\n\n**Use Cases:**\n- **Real-time dashboards:** Stream live metrics with minimal latency using WebRTC data channels\n- **Browser-based monitoring:** Enable direct peer-to-peer connections from web browsers to agents\n- **NAT traversal:** Establish connections through firewalls and NATs using ICE/STUN/TURN\n- **Low-latency updates:** Bypass HTTP polling for instant metric updates via WebRTC\n- **Bi-directional communication:** Enable interactive control and monitoring in real-time\n\n**Connection Configuration:**\n- Maximum message size: 5 MiB (local), negotiated with remote peer\n- ICE transport policy: All (both UDP and TCP)\n- Automatic ICE candidate gathering\n- Support for STUN/TURN servers\n- Automatic port range selection\n- MTU auto-detection\n\n**Important Notes:**\n- WebRTC must be enabled in agent configuration (enabled by default in debug builds)\n- The endpoint waits for ICE gathering to complete before returning the answer\n- The SDP offer must be valid and include media descriptions\n- Response includes both SDP answer and gathered ICE candidates\n- Connections are automatically cleaned up on timeout or disconnection\n\n**Example SDP Offer Structure:**\n```\nv=0\no=- 123456789 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 0.0.0.0\na=ice-ufrag:XXXX\na=ice-pwd:YYYY\na=fingerprint:sha-256 ZZ:ZZ:...\na=setup:actpass\na=mid:0\na=sctp-port:5000\na=max-message-size:65536\n```\n\n**Performance Characteristics:**\n- Synchronous operation (blocks until ICE gathering completes)\n- Typical response time: 100-500ms (depending on ICE gathering)\n- Supports multiple concurrent connections\n- Automatic connection cleanup on idle timeout\n\n**Security & Access Control:**\n- ⚠️ **ACLK-Only API** - This endpoint is ONLY accessible via Netdata Cloud (ACLK connection)\n- **NOT accessible via:** Direct HTTP/HTTPS to agent, local dashboard, or external tools\n- **Authentication:** Requires Netdata Cloud authentication (`SIGNED_ID` + `SAME_SPACE`)\n- **User Requirements:** User must be authenticated and in the same cloud space as the agent\n- **Development Mode:** Can be enabled for testing with `ACL_DEV_OPEN_ACCESS` flag\n",
        "security": [
          {
            "aclkAuth": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "SDP (Session Description Protocol) offer from the client's WebRTC peer connection.\nMust be a valid SDP offer string containing session information, media descriptions,\nICE credentials, and DTLS fingerprint.\n",
                "example": "v=0\no=- 123456789 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 0.0.0.0\na=ice-ufrag:abcd1234\na=ice-pwd:efgh5678ijkl9012mnop3456\na=fingerprint:sha-256 AB:CD:EF:01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB:CD:EF:01:23:45:67:89:AB\na=setup:actpass\na=mid:0\na=sctp-port:5000\na=max-message-size:65536\n"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "SDP answer successfully generated. The response contains the server's SDP answer\nincluding all gathered ICE candidates. The client should set this as the remote\ndescription to complete the WebRTC handshake.\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "sdp": {
                      "type": "string",
                      "description": "SDP answer from the server containing session information, media descriptions,\nICE credentials, DTLS fingerprint, and all gathered ICE candidates.\n"
                    },
                    "type": {
                      "type": "string",
                      "enum": [
                        "answer"
                      ],
                      "description": "SDP message type (always \"answer\" for responses)"
                    }
                  },
                  "example": {
                    "sdp": "v=0\no=- 987654321 2 IN IP4 192.168.1.100\ns=-\nt=0 0\na=group:BUNDLE 0\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 192.168.1.100\na=candidate:1 1 udp 2130706431 192.168.1.100 54321 typ host\na=candidate:2 1 udp 1694498815 203.0.113.1 54321 typ srflx raddr 192.168.1.100 rport 54321\na=ice-ufrag:wxyz9876\na=ice-pwd:stuv5432wxyz1098abcd7654\na=fingerprint:sha-256 12:34:56:78:9A:BC:DE:F0:12:34:56:78:9A:BC:DE:F0:12:34:56:78:9A:BC:DE:F0:12:34:56:78:9A:BC:DE:F0:12\na=setup:active\na=mid:0\na=sctp-port:5000\na=max-message-size:5242880\n",
                    "type": "answer"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request due to one of the following reasons:\n- WebRTC is not enabled on this agent (check configuration)\n- No SDP offer provided in request body\n- Invalid SDP format or content\n- Missing required SDP fields (ice-ufrag, ice-pwd, fingerprint)\n"
          },
          "500": {
            "description": "Internal server error during WebRTC connection establishment or ICE gathering."
          }
        }
      }
    },
    "/api/v3/claim": {
      "get": {
        "operationId": "claim3",
        "tags": [
          "claiming"
        ],
        "summary": "Claim agent to Netdata Cloud",
        "description": "**Agent Claiming to Netdata Cloud**\n\nThis endpoint initiates the process of claiming (connecting) a Netdata agent to Netdata Cloud. Claiming establishes a secure, authenticated connection between the agent and Netdata Cloud, enabling centralized monitoring, team collaboration, and cloud-based features.\n\n**Claiming Process Flow:**\n1. **Get Claim Info:** Call endpoint without parameters to get claiming status and verification command\n2. **Generate Verification Key:** Server generates random session ID and saves it to `/var/lib/netdata/netdata_random_session_id`\n3. **Verify Server Ownership:** Administrator runs provided OS-specific command to retrieve the verification key\n4. **Submit Claim Request:** Call endpoint with key, token, URL, and optionally rooms to complete claiming\n5. **Establish Connection:** Server connects to Netdata Cloud and registers the agent\n6. **Reload Connection:** Agent reloads cloud connection and waits for online status\n\n**Use Cases:**\n- **Initial Setup:** Claim a new agent to connect it to Netdata Cloud for the first time\n- **Team Onboarding:** Add agents to specific cloud rooms for team organization\n- **Infrastructure Management:** Connect agents across distributed infrastructure to centralized monitoring\n- **Security Verification:** Ensure only authorized users can claim agents through server access verification\n- **Status Checking:** Query current claiming status and cloud connection state\n\n**Claiming States:**\n- **AVAILABLE:** Agent can be claimed (not yet connected to cloud)\n- **OFFLINE:** Agent was claimed but is currently offline from cloud\n- **INDIRECT:** Agent is connected through a parent agent\n- **ONLINE:** Agent is claimed and online (cannot be re-claimed without unclaiming first)\n- **BANNED:** Agent is banned from cloud (cannot be claimed)\n\n**Security Features:**\n- Random session key verification prevents unauthorized claiming\n- Key is regenerated after each claim attempt (successful or failed)\n- Key stored in file system requires server access to retrieve\n- Parameter validation ensures only safe characters (alphanumeric, dots, commas, dashes, colons, slashes, underscores)\n- Different OS-specific commands for key retrieval (Linux/Docker/Windows)\n\n**Platform-Specific Key Retrieval:**\n- **Linux:** `sudo cat /var/lib/netdata/netdata_random_session_id`\n- **Docker:** `docker exec netdata cat /var/lib/netdata/netdata_random_session_id`\n- **Windows:** `more C:\\path\\to\\netdata_random_session_id`\n\n**Response Formats:**\n- **Info Response:** Returns cloud status, can_be_claimed flag, verification command, and agents info\n- **Success Response:** Includes success=true, message=\"ok\", updated cloud status\n- **Error Response:** Includes success=false, error message, can_be_claimed flag, new verification key\n\n**Important Notes:**\n- Agent must be in AVAILABLE, OFFLINE, or INDIRECT state to be claimed\n- Claiming token is obtained from Netdata Cloud UI (Space settings → Nodes tab → Add Nodes)\n- Base URL typically points to Netdata Cloud API (e.g., https://api.netdata.cloud)\n- Rooms parameter is optional - agent will be added to specified war rooms if provided\n- After successful claiming, agent automatically reloads connection and waits for online status\n- Failed claim attempts regenerate the verification key for security\n\n**Example Workflow:**\n```bash\n# 1. Get claiming info and verification command\ncurl http://localhost:19999/api/v3/claim\n\n# 2. Run the command shown in response to get the key\nsudo cat /var/lib/netdata/netdata_random_session_id\n# Output: 12345678-1234-1234-1234-123456789abc\n\n# 3. Submit claim request with key from step 2 and token from Netdata Cloud\ncurl \"http://localhost:19999/api/v3/claim?key=12345678-1234-1234-1234-123456789abc&token=YOUR_CLAIM_TOKEN&url=https://api.netdata.cloud&rooms=room1,room2\"\n```\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **Security Model:** Protected by random session key verification (not ACL/bearer token)\n- **Verification Required:** Must provide verification key from agent's file system to claim\n- **Server Access:** Only users with server file system access can obtain the verification key\n- **No ACL Restrictions:** Not subject to IP-based ACL or bearer protection\n",
        "parameters": [
          {
            "name": "key",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "**Verification key (UUID) obtained from the server's file system.**\n\nThis is a randomly generated session ID that proves the requester has access to the server.\nTo obtain this key:\n1. Call the endpoint without parameters to get the OS-specific command\n2. Run the command on the server (requires sudo/admin access)\n3. Copy the UUID from the file content\n4. Use it in the claim request\n\n**Security Notes:**\n- Key is randomly generated on each info request\n- Key is regenerated after each claim attempt (prevents reuse)\n- Mismatched key triggers new key generation (prevents brute force)\n- Validates server ownership through file system access\n\n**When to Include:**\n- Omit when requesting claiming info/status\n- Include when submitting actual claim request\n\nExample: `12345678-1234-1234-1234-123456789abc`\n"
          },
          {
            "name": "token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "**Claiming token from Netdata Cloud.**\n\nThis token authorizes the agent to connect to a specific Netdata Cloud space.\nObtained from Netdata Cloud UI: Space settings → Nodes tab → Add Nodes → Copy claim token\n\n**Validation:**\n- Must contain only alphanumeric characters, dots, commas, dashes, colons, slashes, underscores\n- Required when key parameter is provided\n- Invalid token triggers error and key regeneration\n\n**Token Characteristics:**\n- Space-specific (each cloud space has different tokens)\n- Can be regenerated in cloud UI if compromised\n- Does not expire (remains valid until regenerated)\n\nExample: `a1b2c3d4-e5f6-7890-abcd-ef1234567890`\n"
          },
          {
            "name": "url",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uri"
            },
            "description": "**Netdata Cloud API base URL.**\n\nThe endpoint URL for Netdata Cloud API where the agent will connect.\n\n**Standard Values:**\n- Production: `https://api.netdata.cloud`\n- Staging/Testing: `https://api-staging.netdata.cloud` (if applicable)\n\n**Validation:**\n- Must contain only alphanumeric characters, dots, commas, dashes, colons, slashes, underscores\n- Required when key parameter is provided\n- Should be valid HTTPS URL pointing to Netdata Cloud API\n\n**Important Notes:**\n- Use the URL provided in Netdata Cloud UI claim instructions\n- Different cloud regions may have different URLs\n- Invalid URL prevents successful claiming\n\nExample: `https://api.netdata.cloud`\n"
          },
          {
            "name": "rooms",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "**Comma-separated list of war room IDs to add the agent to.**\n\nWar rooms are organizational units within a Netdata Cloud space for grouping related nodes.\n\n**Format:**\n- Comma-separated room IDs (no spaces)\n- Each room ID validated for safe characters\n- Optional parameter (agent claimed to space without specific rooms if omitted)\n\n**Validation:**\n- Must contain only alphanumeric characters, dots, commas, dashes, colons, slashes, underscores\n- Invalid format triggers error and key regeneration\n\n**Room IDs:**\n- Obtained from Netdata Cloud UI (room settings)\n- Room must exist in the target space\n- Agent added to all specified rooms after claiming\n- Can be modified later in cloud UI\n\n**Use Cases:**\n- Add agent to production monitoring room\n- Organize by environment (dev, staging, prod)\n- Group by application or service type\n\nExample: `room-1234-5678-90ab,room-cdef-0123-4567`\n"
          }
        ],
        "responses": {
          "200": {
            "description": "Claiming request processed successfully. Check the `success` field to determine if claiming succeeded.\n- **Info response** (no key provided): Returns cloud status, verification command, and can_be_claimed flag\n- **Success response** (key provided, claim succeeded): Returns success=true with updated cloud status\n- **Action failed response** (key provided, claim failed): Returns success=false with failure reason\n",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "success": {
                      "type": "boolean",
                      "description": "Present only for claim action responses (when key is provided).\ntrue = claiming succeeded, false = claiming failed.\nNot present in info responses (when requesting claim status without key).\n"
                    },
                    "message": {
                      "type": "string",
                      "description": "Result message. Present only for claim action responses.\n- Success: \"ok\"\n- Failure: Reason for failure (e.g., \"invalid key\", \"invalid parameters\", cloud connection error)\n"
                    },
                    "cloud_status": {
                      "type": "string",
                      "enum": [
                        "available",
                        "offline",
                        "indirect",
                        "online",
                        "banned"
                      ],
                      "description": "Current cloud connection status of the agent.\n- available: Not claimed yet, can be claimed\n- offline: Claimed but currently disconnected\n- indirect: Connected through parent agent\n- online: Claimed and connected (cannot re-claim)\n- banned: Banned from cloud (cannot claim)\n"
                    },
                    "can_be_claimed": {
                      "type": "boolean",
                      "description": "Whether the agent can currently be claimed. Present in info and error responses.\ntrue for available/offline/indirect states, false for online/banned.\n"
                    },
                    "key_filename": {
                      "type": "string",
                      "description": "Full path to the file containing the verification key.\nPresent in info and error responses (not present after successful claim).\nPlatform-specific path (Linux: /var/lib/netdata/..., Windows: C:\\...).\n"
                    },
                    "cmd": {
                      "type": "string",
                      "description": "OS-specific command to retrieve the verification key.\nPresent in info and error responses.\n- Linux: \"sudo cat /var/lib/netdata/netdata_random_session_id\"\n- Docker: \"docker exec netdata cat /var/lib/netdata/netdata_random_session_id\"\n- Windows: \"more C:\\path\\to\\netdata_random_session_id\"\n"
                    },
                    "help": {
                      "type": "string",
                      "description": "Human-readable instructions for obtaining the verification key.\nPresent in info and error responses.\n"
                    },
                    "agents": {
                      "type": "array",
                      "description": "Agent information for the claimed node(s)",
                      "items": {
                        "type": "object"
                      }
                    }
                  }
                },
                "examples": {
                  "info_response": {
                    "value": {
                      "cloud_status": "available",
                      "can_be_claimed": true,
                      "key_filename": "/var/lib/netdata/netdata_random_session_id",
                      "cmd": "sudo cat /var/lib/netdata/netdata_random_session_id",
                      "help": "We need to verify this server is yours. SSH to this server and run this command. It will give you a UUID. Copy and paste this UUID to this box:",
                      "agents": [
                        {
                          "hostname": "my-server",
                          "machine_guid": "12345678-1234-1234-1234-123456789abc"
                        }
                      ]
                    },
                    "summary": "Info response (no claim attempt)"
                  },
                  "success_response": {
                    "value": {
                      "success": true,
                      "message": "ok",
                      "cloud_status": "online",
                      "agents": [
                        {
                          "hostname": "my-server",
                          "machine_guid": "12345678-1234-1234-1234-123456789abc",
                          "claimed_id": "cloud-node-id-123"
                        }
                      ]
                    },
                    "summary": "Successful claim"
                  },
                  "error_response": {
                    "value": {
                      "success": false,
                      "message": "invalid key",
                      "cloud_status": "available",
                      "can_be_claimed": true,
                      "key_filename": "/var/lib/netdata/netdata_random_session_id",
                      "cmd": "sudo cat /var/lib/netdata/netdata_random_session_id",
                      "help": "We need to verify this server is yours. SSH to this server and run this command. It will give you a UUID. Copy and paste this UUID to this box:",
                      "agents": [
                        {
                          "hostname": "my-server",
                          "machine_guid": "12345678-1234-1234-1234-123456789abc"
                        }
                      ]
                    },
                    "summary": "Failed claim (invalid key)"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request (only in v2 API or earlier). V3 returns errors as JSON with HTTP 200.\nReasons include:\n- Invalid key (doesn't match generated session ID)\n- Invalid parameters (missing token/url, or invalid characters)\n- Cloud connection failure\n"
          }
        }
      }
    },
    "/api/v3/bearer_protection": {
      "get": {
        "operationId": "bearerProtection3",
        "tags": [
          "authentication"
        ],
        "summary": "Enable or disable bearer token authentication requirement",
        "description": "**Bearer Token Authentication Control**\n\nThis endpoint controls whether the Netdata agent requires bearer token authentication for API access. Bearer protection adds an additional security layer by requiring a valid bearer token in the Authorization header for all API requests when enabled.\n\n**Use Cases:**\n- **Cloud Integration:** Enable bearer protection when agent is claimed to Netdata Cloud\n- **Security Hardening:** Add token-based authentication to prevent unauthorized API access\n- **Multi-Tenant Environments:** Enforce authentication in shared infrastructure\n- **Dynamic Security:** Toggle authentication requirements based on operational needs\n- **Remote Management:** Netdata Cloud can enable protection when claiming agents\n\n**How It Works:**\n1. When bearer protection is enabled, all API requests must include: `Authorization: Bearer <token>`\n2. Tokens are obtained via `/api/v3/bearer_get_token` endpoint\n3. Tokens have expiration times and must be renewed periodically\n4. Invalid or missing tokens result in HTTP 401 Unauthorized\n5. Some endpoints (like claiming) may bypass bearer protection\n\n**Security Verification:**\n- **claim_id:** Must match the agent's current claim ID (prevents requests to wrong agent)\n- **machine_guid:** Must match the agent's machine GUID (hardware fingerprint)\n- **node_id:** Must match the agent's node UUID (persistent identity)\n- All three identifiers must be present and match for the operation to succeed\n\n**Protection States:**\n- **Enabled (true):** All API requests require valid bearer token in Authorization header\n- **Disabled (false):** API requests do not require bearer tokens (default for unclaimed agents)\n\n**Important Notes:**\n- This endpoint itself requires authentication (typically called by Netdata Cloud during claiming)\n- Changing protection state affects all subsequent API requests immediately\n- Netdata Cloud automatically enables bearer protection when an agent is claimed\n- Local access may still work without bearer token depending on configuration\n- The endpoint validates that the request is for the correct agent using claim_id, machine_guid, and node_id\n- Mismatched identifiers return HTTP 400 Bad Request\n\n**Typical Workflow:**\n1. Agent is claimed to Netdata Cloud\n2. Cloud calls this endpoint to enable bearer protection\n3. All future API calls to the agent require bearer tokens\n4. Cloud obtains tokens via `/api/v3/bearer_get_token` as needed\n5. Tokens are included in Authorization headers for authenticated requests\n\n**Security & Access Control:**\n- ⚠️ **ACLK-Only API** - This endpoint is ONLY accessible via Netdata Cloud (ACLK connection)\n- **NOT accessible via:** Direct HTTP/HTTPS to agent, even with bearer token\n- **Authentication:** Requires Netdata Cloud authentication with elevated permissions\n- **Required Permissions:** `SIGNED_ID` + `SAME_SPACE` + `VIEW_AGENT_CONFIG` + `EDIT_AGENT_CONFIG`\n- **User Roles:** Typically Admin or Manager role required\n- **Development Mode:** Can be enabled for testing with `ACL_DEV_OPEN_ACCESS` flag\n",
        "security": [
          {
            "aclkAuth": []
          }
        ],
        "parameters": [
          {
            "name": "bearer_protection",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "on",
                "off",
                true,
                false,
                "yes",
                "no"
              ]
            },
            "description": "**Whether to enable or disable bearer token authentication requirement.**\n\n**Valid Values:**\n- Enable: `on`, `true`, `yes`\n- Disable: `off`, `false`, `no`\n\n**Default Behavior:**\n- If omitted, maintains current bearer protection state\n- When agent is unclaimed, defaults to disabled\n- When agent is claimed, typically enabled by Netdata Cloud\n\n**Effect:**\n- When enabled: All API requests must include valid bearer token in Authorization header\n- When disabled: API requests work without bearer tokens (less secure)\n\nExample: `bearer_protection=on`\n"
          },
          {
            "name": "claim_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "**Claim ID of the agent from Netdata Cloud.**\n\nThis identifies which Netdata Cloud space the agent is claimed to.\nUsed to verify the request is for the correct agent.\n\n**Validation:**\n- Must match the agent's current claim ID\n- Request fails with HTTP 400 if claim ID doesn't match\n- Prevents accidentally enabling protection on wrong agent\n\n**Where to Find:**\n- Obtained from cloud when agent is claimed\n- Available in agent's claiming configuration\n- Included in cloud API responses\n\nExample: `claim_id=1234567890abcdef`\n"
          },
          {
            "name": "machine_guid",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "**Machine GUID of the agent.**\n\nHardware-based unique identifier for the agent instance.\nGenerated based on machine characteristics.\n\n**Purpose:**\n- Verifies request is for the specific agent instance\n- Prevents applying protection to wrong node\n- Part of multi-factor agent identification\n\n**Characteristics:**\n- Persists across agent restarts\n- May change if hardware changes significantly\n- Matches the `machine_guid` in agent info\n\n**Where to Find:**\n- Available in `/api/v3/info` response\n- Stored in agent's state files\n- Shown in Netdata Cloud node details\n\nExample: `machine_guid=12345678-1234-1234-1234-123456789abc`\n"
          },
          {
            "name": "node_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "**Node UUID of the agent.**\n\nPersistent unique identifier for the agent.\nMore stable than machine_guid.\n\n**Purpose:**\n- Provides additional verification layer\n- Ensures request targets correct node\n- Used alongside claim_id and machine_guid for security\n\n**Characteristics:**\n- Generated once and persists\n- Does not change with hardware changes\n- Unique across all Netdata installations\n\n**Where to Find:**\n- Available in `/api/v3/info` response\n- Stored in agent's persistent state\n- Used by Netdata Cloud for node identification\n\nExample: `node_id=23456789-2345-2345-2345-234567890abc`\n"
          }
        ],
        "responses": {
          "200": {
            "description": "Bearer protection state successfully changed.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "bearer_protection": {
                      "type": "boolean",
                      "description": "Current bearer protection state after the operation (true = enabled, false = disabled)"
                    }
                  }
                },
                "example": {
                  "bearer_protection": true
                }
              }
            }
          },
          "400": {
            "description": "Bad request due to one of the following:\n- claim_id doesn't match the agent's claim ID\n- machine_guid doesn't match the agent's machine GUID\n- node_id doesn't match or is missing\n- Invalid parameter values\n"
          }
        }
      }
    },
    "/api/v3/bearer_get_token": {
      "get": {
        "operationId": "bearerGetToken3",
        "tags": [
          "authentication"
        ],
        "summary": "Obtain bearer authentication token",
        "description": "**Bearer Token Generation**\n\nThis endpoint generates a bearer authentication token that can be used to authenticate API requests when bearer protection is enabled. Tokens are time-limited and include role-based access control information.\n\n**Use Cases:**\n- **Netdata Cloud Access:** Cloud obtains tokens to query agent metrics and execute functions\n- **API Integration:** Applications get tokens to access protected agent APIs\n- **User Authentication:** Generate tokens for users based on their roles and permissions\n- **Automated Monitoring:** Scripts obtain tokens for scheduled metric collection\n- **Temporary Access:** Create limited-lifetime tokens for specific operations\n\n**Token Characteristics:**\n- **Time-Limited:** Tokens expire after a set duration (configurable)\n- **Role-Based:** Tokens include user role information (admin, manager, viewer, etc.)\n- **Access-Scoped:** Tokens specify allowed access levels (data, functions, etc.)\n- **Cloud-Linked:** Can be associated with cloud account ID for tracking\n- **Client-Identified:** Can include client name for audit logging\n\n**Token Usage:**\n```\n# Obtain token\nTOKEN=$(curl \"http://localhost:19999/api/v3/bearer_get_token?claim_id=...&machine_guid=...&node_id=...\" | jq -r .token)\n\n# Use token in subsequent requests\ncurl -H \"Authorization: Bearer $TOKEN\" http://localhost:19999/api/v3/data?chart=system.cpu\n```\n\n**Security Verification:**\n- **claim_id:** Must match the agent's claim ID (ensures request is for correct agent)\n- **machine_guid:** Must match the agent's machine GUID (hardware verification)\n- **node_id:** Must match the agent's node UUID (persistent identity)\n- All three identifiers must be present and exact matches\n\n**Remote Agent Support:**\n- If requested for a child/remote agent (not localhost), request is forwarded via function call\n- Token is generated on the remote agent with appropriate permissions\n- Response includes remote agent's machine_guid\n\n**Token Expiration:**\n- Tokens have finite lifetime (typically hours)\n- Expired tokens return HTTP 401 Unauthorized\n- Applications should refresh tokens before expiration\n- Expiration time included in response for planning renewal\n\n**Important Notes:**\n- This endpoint typically requires existing authentication (cloud or admin access)\n- Generated token inherits user role and access permissions from requester\n- Tokens are cryptographically secure random UUIDs\n- Response includes current bearer protection state\n- Failed verification attempts do not generate tokens\n- Mismatched identifiers return HTTP 400 Bad Request\n\n**Typical Workflow:**\n1. Netdata Cloud or authorized client calls this endpoint with agent identifiers\n2. Agent verifies claim_id, machine_guid, and node_id all match\n3. Agent generates bearer token with specified role/access/account info\n4. Token and expiration time returned in JSON response\n5. Client includes token in Authorization header for subsequent API calls\n6. Token is validated on each API request until expiration\n7. Client requests new token before expiration to maintain access\n\n**Security & Access Control:**\n- ⚠️ **ACLK-Only API** - This endpoint is ONLY accessible via Netdata Cloud (ACLK connection)\n- **NOT accessible via:** Direct HTTP/HTTPS to agent, local dashboard, or external tools\n- **Authentication:** Requires Netdata Cloud authentication (`SIGNED_ID` + `SAME_SPACE`)\n- **User Requirements:** User must be authenticated and in the same cloud space as the agent\n- **Token Scope:** Generated tokens inherit the requester's role and access permissions\n- **Development Mode:** Can be enabled for testing with `ACL_DEV_OPEN_ACCESS` flag\n",
        "security": [
          {
            "aclkAuth": []
          }
        ],
        "parameters": [
          {
            "name": "claim_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "**Claim ID of the agent from Netdata Cloud.**\n\nIdentifies which Netdata Cloud space the agent belongs to.\nUsed to verify the token request is for the correct agent.\n\n**Validation:**\n- Must match the agent's current claim ID\n- Request fails with HTTP 400 if claim ID doesn't match\n- Can use `claim_id_matches_any()` for multi-agent parents\n\n**Security:**\n- Prevents token generation for wrong agent\n- Ensures cloud can only get tokens for agents it manages\n- Part of multi-factor agent verification\n\nExample: `claim_id=1234567890abcdef`\n"
          },
          {
            "name": "machine_guid",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "**Machine GUID of the target agent.**\n\nHardware-based unique identifier for the agent instance.\n\n**Purpose:**\n- Verifies request is for the specific agent instance\n- Prevents token generation for wrong node\n- Must match exactly or request fails\n\n**Where to Find:**\n- Available in `/api/v3/info` response\n- Included in cloud agent registration\n- Stored in agent state files\n\n**Validation:**\n- Compared against host->machine_guid\n- Both claim_id and machine_guid must match\n- node_id also verified for triple authentication\n\nExample: `machine_guid=12345678-1234-1234-1234-123456789abc`\n"
          },
          {
            "name": "node_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "**Node UUID of the target agent.**\n\nPersistent unique identifier for the agent node.\n\n**Purpose:**\n- Additional verification layer beyond machine_guid\n- Ensures correct node identification\n- Used in combination with other identifiers\n\n**Characteristics:**\n- More stable than machine_guid\n- Persists across hardware changes\n- Unique across all Netdata installations\n\n**Validation:**\n- Must be non-zero UUID\n- Must match host->node_id exactly\n- Compared in lowercase format\n\nExample: `node_id=23456789-2345-2345-2345-234567890abc`\n"
          }
        ],
        "responses": {
          "200": {
            "description": "Bearer token successfully generated.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "integer",
                      "description": "HTTP status code (always 200 for success)",
                      "example": 200
                    },
                    "mg": {
                      "type": "string",
                      "description": "Machine GUID of the agent that generated the token"
                    },
                    "bearer_protection": {
                      "type": "boolean",
                      "description": "Current bearer protection state (true = enabled, false = disabled)"
                    },
                    "token": {
                      "type": "string",
                      "format": "uuid",
                      "description": "Bearer token UUID to use in Authorization header.\nFormat: `Authorization: Bearer <token>`\n"
                    },
                    "expiration": {
                      "type": "integer",
                      "format": "int64",
                      "description": "Unix timestamp (seconds since epoch) when the token expires"
                    }
                  }
                },
                "example": {
                  "status": 200,
                  "mg": "12345678-1234-1234-1234-123456789abc",
                  "bearer_protection": true,
                  "token": "34567890-3456-3456-3456-345678901234",
                  "expiration": 1704110400
                }
              }
            }
          },
          "400": {
            "description": "Bad request due to one of the following:\n- claim_id doesn't match any claimed agent\n- machine_guid doesn't match the agent's machine GUID\n- node_id is missing, invalid, or doesn't match\n- Request is for a different agent than the one being called\n"
          }
        }
      }
    },
    "/api/v3/me": {
      "get": {
        "operationId": "me3",
        "tags": [
          "authentication"
        ],
        "summary": "Get current authenticated user information",
        "description": "**Current User Authentication Info**\n\nThis endpoint returns information about the currently authenticated user or session. It provides details about the authentication method, user role, access permissions, and associated cloud account if applicable.\n\n**Use Cases:**\n- **Authentication Verification:** Verify that authentication is working and check what method was used\n- **Permission Checking:** Determine what access levels the current session has\n- **Role Discovery:** Find out the user role (admin, manager, viewer, etc.) for authorization decisions\n- **Cloud Integration:** Get cloud account ID for linking with Netdata Cloud features\n- **Client Identification:** Retrieve client name for audit logging or display purposes\n- **Security Auditing:** Log authentication methods and access levels for security reviews\n\n**Authentication Methods:**\n- **cloud:** Authenticated via Netdata Cloud (most common for claimed agents)\n- **bearer:** Authenticated using bearer token (obtained via `/api/v3/bearer_get_token`)\n- **god:** God mode authentication (debug/development builds only)\n- **none:** No authentication (default for unclaimed agents without bearer protection)\n\n**User Roles:**\nRoles determine what operations a user can perform:\n- **admin:** Full administrative access (all operations allowed)\n- **manager:** Management access (most operations allowed, some restrictions)\n- **troubleshooter:** Diagnostic access (read metrics, execute diagnostic functions)\n- **observer:** Read-only access to metrics (no configuration changes)\n- **member:** Basic member access\n- **billing:** Billing-related access\n- **none:** No specific role assigned\n\n**Access Permissions:**\nAccess is a bitmask of allowed operations:\n- **registry:** Can access agent registry features\n- **dashboard:** Can view dashboards\n- **data:** Can query metrics data\n- **functions:** Can execute agent functions\n- **badges:** Can generate badges\n- **mgmt:** Can perform management operations\n- **stream:** Can receive streaming data\n- **SSL_FORCE:** SSL/TLS is required\n- **signed_id:** Has signed/verified identity\n- **sensitive_data:** Can access sensitive configuration data\n\n**Cloud Integration:**\n- **cloud_account_id:** UUID linking session to Netdata Cloud account\n- Present when authenticated via Netdata Cloud\n- Used for tracking and authorization in cloud features\n- Zero UUID (00000000-0000-0000-0000-000000000000) when not cloud-authenticated\n\n**Client Identification:**\n- **client_name:** Human-readable name identifying the client application\n- Examples: \"Netdata Cloud\", \"API Script\", \"Custom Dashboard\"\n- Useful for audit logs and debugging\n- May be empty for anonymous/local access\n\n**Important Notes:**\n- This endpoint always succeeds (returns HTTP 200) even without authentication\n- For unauthenticated requests, auth=\"none\" and minimal permissions returned\n- The response reflects the current session's authentication state\n- Access permissions are cumulative (multiple permissions can be granted)\n- God mode is only available in debug builds with NETDATA_GOD_MODE defined\n- Bearer tokens inherit role and access from the user/cloud account that requested them\n\n**Security Considerations:**\n- Use this endpoint to verify authentication before performing sensitive operations\n- Check both user_role and access permissions for proper authorization\n- Cloud account ID can be used for cross-referencing with cloud audit logs\n- Authentication method indicates security level (cloud/bearer > none)\n\n**Example Responses:**\n\n**Netdata Cloud User:**\n```json\n{\n  \"auth\": \"cloud\",\n  \"cloud_account_id\": \"12345678-1234-1234-1234-123456789abc\",\n  \"client_name\": \"Netdata Cloud\",\n  \"access\": [\"registry\", \"dashboard\", \"data\", \"functions\", \"badges\", \"mgmt\", \"stream\", \"signed_id\"],\n  \"user_role\": \"admin\"\n}\n```\n\n**Bearer Token User:**\n```json\n{\n  \"auth\": \"bearer\",\n  \"cloud_account_id\": \"12345678-1234-1234-1234-123456789abc\",\n  \"client_name\": \"API Client\",\n  \"access\": [\"data\", \"functions\", \"signed_id\"],\n  \"user_role\": \"observer\"\n}\n```\n\n**Unauthenticated Local Access:**\n```json\n{\n  \"auth\": \"none\",\n  \"cloud_account_id\": \"00000000-0000-0000-0000-000000000000\",\n  \"client_name\": \"\",\n  \"access\": [\"registry\", \"dashboard\", \"data\", \"badges\"],\n  \"user_role\": \"none\"\n}\n```\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **No Restrictions:** Not subject to bearer protection or IP-based ACL restrictions\n- **No Authentication:** Cannot be restricted by any configuration\n- **Access:** Available to anyone who can reach the agent's HTTP endpoint\n",
        "responses": {
          "200": {
            "description": "Current user information successfully retrieved.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "auth": {
                      "type": "string",
                      "enum": [
                        "cloud",
                        "bearer",
                        "god",
                        "none"
                      ],
                      "description": "Authentication method used for the current session.\n- cloud: Authenticated via Netdata Cloud\n- bearer: Authenticated using bearer token\n- god: God mode (debug builds only)\n- none: No authentication\n"
                    },
                    "cloud_account_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "Cloud account UUID associated with this session.\nZero UUID (00000000-0000-0000-0000-000000000000) when not cloud-authenticated.\n"
                    },
                    "client_name": {
                      "type": "string",
                      "description": "Human-readable name of the client application.\nMay be empty for anonymous/local access.\nExamples: \"Netdata Cloud\", \"API Script\", \"Custom Dashboard\"\n"
                    },
                    "access": {
                      "type": "array",
                      "description": "Array of access permissions granted to this session.\nPermissions are cumulative (multiple can be granted).\n",
                      "items": {
                        "type": "string",
                        "enum": [
                          "registry",
                          "dashboard",
                          "data",
                          "functions",
                          "badges",
                          "mgmt",
                          "stream",
                          "SSL_FORCE",
                          "signed_id",
                          "sensitive_data"
                        ]
                      }
                    },
                    "user_role": {
                      "type": "string",
                      "enum": [
                        "admin",
                        "manager",
                        "troubleshooter",
                        "observer",
                        "member",
                        "billing",
                        "none"
                      ],
                      "description": "User role determining what operations are allowed.\n- admin: Full administrative access\n- manager: Management access with some restrictions\n- troubleshooter: Diagnostic and troubleshooting access\n- observer: Read-only access to metrics\n- member: Basic member access\n- billing: Billing-related access\n- none: No specific role\n"
                    }
                  }
                },
                "examples": {
                  "cloud_admin": {
                    "value": {
                      "auth": "cloud",
                      "cloud_account_id": "12345678-1234-1234-1234-123456789abc",
                      "client_name": "Netdata Cloud",
                      "access": [
                        "registry",
                        "dashboard",
                        "data",
                        "functions",
                        "badges",
                        "mgmt",
                        "stream",
                        "signed_id"
                      ],
                      "user_role": "admin"
                    },
                    "summary": "Netdata Cloud admin user"
                  },
                  "bearer_observer": {
                    "value": {
                      "auth": "bearer",
                      "cloud_account_id": "12345678-1234-1234-1234-123456789abc",
                      "client_name": "Monitoring Script",
                      "access": [
                        "data",
                        "functions",
                        "signed_id"
                      ],
                      "user_role": "observer"
                    },
                    "summary": "Bearer token with observer role"
                  },
                  "unauthenticated": {
                    "value": {
                      "auth": "none",
                      "cloud_account_id": "00000000-0000-0000-0000-000000000000",
                      "client_name": "",
                      "access": [
                        "registry",
                        "dashboard",
                        "data",
                        "badges"
                      ],
                      "user_role": "none"
                    },
                    "summary": "Unauthenticated local access"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/v2/weights": {
      "get": {
        "deprecated": true,
        "operationId": "weights2",
        "tags": [
          "weights"
        ],
        "summary": "Score or weight all or some of the metrics, across all nodes, according to various algorithms.",
        "description": "This endpoint goes through all metrics and scores them according to an algorithm.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/weightMethods"
          },
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/scopeInstances"
          },
          {
            "$ref": "#/components/parameters/scopeLabels"
          },
          {
            "$ref": "#/components/parameters/scopeDimensions"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/filterInstances"
          },
          {
            "$ref": "#/components/parameters/filterLabels"
          },
          {
            "$ref": "#/components/parameters/filterAlerts"
          },
          {
            "$ref": "#/components/parameters/filterDimensions"
          },
          {
            "$ref": "#/components/parameters/baselineAfter"
          },
          {
            "$ref": "#/components/parameters/baselineBefore"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/tier"
          },
          {
            "$ref": "#/components/parameters/points"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup2"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroupOptions2"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          }
        ],
        "responses": {
          "200": {
            "description": "JSON object with weights for each context, chart and dimension.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/weights2"
                }
              }
            }
          },
          "400": {
            "description": "The given parameters are invalid."
          },
          "403": {
            "description": "metrics correlations are not enabled on this Netdata Agent."
          },
          "404": {
            "description": "No charts could be found, or the method that correlated the metrics did not produce any result.\n"
          },
          "504": {
            "description": "Timeout - the query took too long and has been cancelled."
          }
        }
      }
    },
    "/api/v2/alerts": {
      "get": {
        "deprecated": true,
        "operationId": "alerts2",
        "tags": [
          "alerts"
        ],
        "summary": "OBSOLETE: Get current alert status across all nodes (use /api/v3/alerts instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/alerts` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/alerts` with `/api/v3/alerts` in all API calls.\n\nReturns the current status of health monitoring alerts across all nodes in the infrastructure.\nSupports filtering by status, alert name, and node selection.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "name": "status",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Filter alerts by status (e.g., CRITICAL, WARNING, CLEAR)"
          },
          {
            "name": "alert",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Filter by alert name pattern"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          }
        ],
        "responses": {
          "200": {
            "description": "Alert status successfully retrieved"
          },
          "400": {
            "description": "Invalid parameters"
          }
        }
      }
    },
    "/api/v2/alert_transitions": {
      "get": {
        "deprecated": true,
        "operationId": "alertTransitions2",
        "tags": [
          "alerts"
        ],
        "summary": "OBSOLETE: Get alert state transition history (use /api/v3/alert_transitions instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/alert_transitions` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/alert_transitions` with `/api/v3/alert_transitions` in all API calls.\n\nReturns historical alert state transitions showing how alerts changed over time.\nSupports faceted filtering by status, type, role, class, component, node, alert name, chart name, and context.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "name": "alert",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Filter by alert name"
          },
          {
            "name": "transition",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Filter by transition type"
          },
          {
            "name": "last",
            "in": "query",
            "schema": {
              "type": "integer"
            },
            "description": "Return only the last N transitions"
          },
          {
            "name": "anchor_gi",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int64"
            },
            "description": "Global ID anchor for pagination"
          },
          {
            "name": "f_status",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for alert status"
          },
          {
            "name": "f_type",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for alert type"
          },
          {
            "name": "f_role",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for recipient role"
          },
          {
            "name": "f_class",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for alert class"
          },
          {
            "name": "f_component",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for alert component"
          },
          {
            "name": "f_node",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for node"
          },
          {
            "name": "f_alert",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for alert name"
          },
          {
            "name": "f_instance",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for chart/instance name"
          },
          {
            "name": "f_context",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "description": "Facet filter for context"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          }
        ],
        "responses": {
          "200": {
            "description": "Alert transitions successfully retrieved"
          },
          "400": {
            "description": "Invalid parameters"
          }
        }
      }
    },
    "/api/v2/alert_config": {
      "get": {
        "deprecated": true,
        "operationId": "alertConfig2",
        "tags": [
          "alerts"
        ],
        "summary": "OBSOLETE: Get alert configuration by hash ID (use /api/v3/alert_config instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/alert_config` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/alert_config` with `/api/v3/alert_config` in all API calls.\n\nRetrieves the complete configuration for a specific alert using its configuration hash (UUID).\nReturns alert definition including conditions, thresholds, and notification settings.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "config",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Alert configuration hash ID (UUID)"
          }
        ],
        "responses": {
          "200": {
            "description": "Alert configuration successfully retrieved"
          },
          "400": {
            "description": "Missing or invalid config parameter"
          }
        }
      }
    },
    "/api/v2/info": {
      "get": {
        "deprecated": true,
        "operationId": "info2",
        "tags": [
          "agent"
        ],
        "summary": "OBSOLETE: Get agent information (use /api/v3/info instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/info` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/info` with `/api/v3/info` in all API calls.\n\nReturns comprehensive agent information including version, capabilities, OS details, hardware specs,\nand configuration. Essential for discovering agent capabilities before querying metrics.\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **No Restrictions:** Not subject to bearer protection or IP-based ACL restrictions\n- **No Authentication:** Cannot be restricted by any configuration\n- **Access:** Available to anyone who can reach the agent's HTTP endpoint\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          }
        ],
        "responses": {
          "200": {
            "description": "Agent information successfully retrieved"
          },
          "400": {
            "description": "Invalid parameters"
          }
        }
      }
    },
    "/api/v2/node_instances": {
      "get": {
        "deprecated": true,
        "operationId": "nodeInstances2",
        "tags": [
          "nodes"
        ],
        "summary": "OBSOLETE: Get node instances hierarchy (use /api/v3/node_instances instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/node_instances` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/node_instances` with `/api/v3/node_instances` in all API calls.\n\nReturns hierarchical organization of chart instances across nodes, showing relationships between\nparent and child agents and their monitored components.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          }
        ],
        "responses": {
          "200": {
            "description": "Node instances successfully retrieved"
          },
          "400": {
            "description": "Invalid parameters"
          }
        }
      }
    },
    "/api/v2/versions": {
      "get": {
        "deprecated": true,
        "operationId": "versions2",
        "tags": [
          "agent"
        ],
        "summary": "OBSOLETE: Get agent version information (use /api/v3/versions instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/versions` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/versions` with `/api/v3/versions` in all API calls.\n\nReturns agent version information across all nodes, useful for upgrade planning and compatibility checking.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          }
        ],
        "responses": {
          "200": {
            "description": "Version information successfully retrieved"
          },
          "400": {
            "description": "Invalid parameters"
          }
        }
      }
    },
    "/api/v2/progress": {
      "get": {
        "deprecated": true,
        "operationId": "progress2",
        "tags": [
          "functions"
        ],
        "summary": "OBSOLETE: Track async operation progress (use /api/v3/progress instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/progress` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/progress` with `/api/v3/progress` in all API calls.\n\nTracks progress of long-running asynchronous operations using transaction UUID.\nUsed for polling function execution status and completion percentage.\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **No Restrictions:** Not subject to bearer protection or IP-based ACL restrictions\n- **No Authentication:** Cannot be restricted by any configuration\n- **Access:** Available to anyone who can reach the agent's HTTP endpoint\n",
        "parameters": [
          {
            "name": "transaction",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Transaction UUID from async operation"
          }
        ],
        "responses": {
          "200": {
            "description": "Progress information successfully retrieved"
          },
          "400": {
            "description": "Missing or invalid transaction parameter"
          }
        }
      }
    },
    "/api/v2/functions": {
      "get": {
        "deprecated": true,
        "operationId": "functions2",
        "tags": [
          "functions"
        ],
        "summary": "OBSOLETE: List available functions (use /api/v3/functions instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/functions` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/functions` with `/api/v3/functions` in all API calls.\n\nLists all functions available on agents, including their descriptions, parameters, and capabilities.\nFunctions provide live operational data and diagnostic capabilities.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          }
        ],
        "responses": {
          "200": {
            "description": "Functions list successfully retrieved"
          },
          "400": {
            "description": "Invalid parameters"
          }
        }
      }
    },
    "/api/v2/rtc_offer": {
      "post": {
        "deprecated": true,
        "operationId": "rtcOffer2",
        "tags": [
          "webrtc"
        ],
        "summary": "OBSOLETE: Establish WebRTC connection (use /api/v3/rtc_offer instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/rtc_offer` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/rtc_offer` with `/api/v3/rtc_offer` in all API calls.\n\nEstablishes WebRTC peer-to-peer connection by exchanging SDP offer/answer for real-time data channels.\n\n**Security & Access Control:**\n- ⚠️ **ACLK-Only API** - Accessible only via Netdata Cloud (ACLK connection)\n- Same access requirements as v3 version\n",
        "security": [
          {
            "aclkAuth": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "SDP offer from client's WebRTC peer connection"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "SDP answer successfully generated"
          },
          "400": {
            "description": "Invalid or missing SDP offer"
          },
          "500": {
            "description": "Internal error during WebRTC connection establishment"
          }
        }
      }
    },
    "/api/v2/claim": {
      "get": {
        "deprecated": true,
        "operationId": "claim2",
        "tags": [
          "claiming"
        ],
        "summary": "OBSOLETE: Claim agent to Netdata Cloud (use /api/v3/claim instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/claim` instead, which provides improved error handling.\n\n**Migration:** Replace `/api/v2/claim` with `/api/v3/claim` in all API calls.\nParameters are identical, but v3 returns errors as JSON instead of plain text for better integration.\n\nClaims (connects) agent to Netdata Cloud using server ownership verification.\nEnables centralized monitoring and team collaboration features.\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **Security Model:** Protected by random session key verification (not ACL/bearer token)\n- **Verification Required:** Must provide verification key from agent's file system to claim\n- **Server Access:** Only users with server file system access can obtain the verification key\n- **No ACL Restrictions:** Not subject to IP-based ACL or bearer protection\n",
        "parameters": [
          {
            "name": "key",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Verification key obtained from server file system"
          },
          {
            "name": "token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Claiming token from Netdata Cloud"
          },
          {
            "name": "url",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uri"
            },
            "description": "Netdata Cloud API base URL"
          },
          {
            "name": "rooms",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Comma-separated war room IDs"
          }
        ],
        "responses": {
          "200": {
            "description": "Claim operation processed (check response for success/failure)"
          },
          "400": {
            "description": "Invalid parameters (v2 returns plain text errors)"
          }
        }
      }
    },
    "/api/v2/bearer_protection": {
      "get": {
        "deprecated": true,
        "operationId": "bearerProtection2",
        "tags": [
          "authentication"
        ],
        "summary": "OBSOLETE: Enable/disable bearer authentication (use /api/v3/bearer_protection instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/bearer_protection` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/bearer_protection` with `/api/v3/bearer_protection` in all API calls.\n\nControls whether agent requires bearer token authentication for API access.\nUsed by Netdata Cloud to secure agents after claiming.\n\n**Security & Access Control:**\n- ⚠️ **ACLK-Only API** - Accessible only via Netdata Cloud (ACLK connection)\n- Requires elevated permissions (Admin/Manager role)\n- Same access requirements as v3 version\n",
        "security": [
          {
            "aclkAuth": []
          }
        ],
        "parameters": [
          {
            "name": "bearer_protection",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "on",
                "off",
                true,
                false,
                "yes",
                "no"
              ]
            },
            "description": "Enable or disable bearer protection"
          },
          {
            "name": "claim_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Agent's claim ID"
          },
          {
            "name": "machine_guid",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Agent's machine GUID"
          },
          {
            "name": "node_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Agent's node UUID"
          }
        ],
        "responses": {
          "200": {
            "description": "Bearer protection state successfully changed"
          },
          "400": {
            "description": "Invalid parameters or verification failed"
          }
        }
      }
    },
    "/api/v2/bearer_get_token": {
      "get": {
        "deprecated": true,
        "operationId": "bearerGetToken2",
        "tags": [
          "authentication"
        ],
        "summary": "OBSOLETE: Get bearer authentication token (use /api/v3/bearer_get_token instead)",
        "description": "**⚠️ OBSOLETE API - Will be removed in future versions**\n\nThis endpoint is deprecated. Use `/api/v3/bearer_get_token` instead, which provides the same functionality.\n\n**Migration:** Replace `/api/v2/bearer_get_token` with `/api/v3/bearer_get_token` in all API calls.\n\nGenerates time-limited bearer token for authenticating API requests when bearer protection is enabled.\n\n**Security & Access Control:**\n- ⚠️ **ACLK-Only API** - Accessible only via Netdata Cloud (ACLK connection)\n- Same access requirements as v3 version\n",
        "security": [
          {
            "aclkAuth": []
          }
        ],
        "parameters": [
          {
            "name": "claim_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Agent's claim ID"
          },
          {
            "name": "machine_guid",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Agent's machine GUID"
          },
          {
            "name": "node_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Agent's node UUID"
          }
        ],
        "responses": {
          "200": {
            "description": "Bearer token successfully generated"
          },
          "400": {
            "description": "Invalid parameters or verification failed"
          }
        }
      }
    },
    "/api/v3/weights": {
      "get": {
        "operationId": "weights3",
        "tags": [
          "weights"
        ],
        "summary": "Score or weight all or some of the metrics, across all nodes, according to various algorithms.",
        "description": "This endpoint goes through all metrics and scores them according to an algorithm.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/weightMethods"
          },
          {
            "$ref": "#/components/parameters/scopeNodes"
          },
          {
            "$ref": "#/components/parameters/scopeContexts"
          },
          {
            "$ref": "#/components/parameters/scopeInstances"
          },
          {
            "$ref": "#/components/parameters/scopeLabels"
          },
          {
            "$ref": "#/components/parameters/scopeDimensions"
          },
          {
            "$ref": "#/components/parameters/filterNodes"
          },
          {
            "$ref": "#/components/parameters/filterContexts"
          },
          {
            "$ref": "#/components/parameters/filterInstances"
          },
          {
            "$ref": "#/components/parameters/filterLabels"
          },
          {
            "$ref": "#/components/parameters/filterAlerts"
          },
          {
            "$ref": "#/components/parameters/filterDimensions"
          },
          {
            "$ref": "#/components/parameters/baselineAfter"
          },
          {
            "$ref": "#/components/parameters/baselineBefore"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/tier"
          },
          {
            "$ref": "#/components/parameters/points"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup2"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroupOptions2"
          },
          {
            "$ref": "#/components/parameters/cardinalityLimit"
          }
        ],
        "responses": {
          "200": {
            "description": "JSON object with weights for each context, chart and dimension.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/weights2"
                }
              }
            }
          },
          "400": {
            "description": "The given parameters are invalid."
          },
          "403": {
            "description": "metrics correlations are not enabled on this Netdata Agent."
          },
          "404": {
            "description": "No charts could be found, or the method that correlated the metrics did not produce any result.\n"
          },
          "504": {
            "description": "Timeout - the query took too long and has been cancelled."
          }
        }
      }
    },
    "/api/v1/weights": {
      "get": {
        "deprecated": true,
        "operationId": "weights1",
        "tags": [
          "weights"
        ],
        "summary": "Score or weight all or some of the metrics of a single node, according to various algorithms.",
        "description": "This endpoint goes through all metrics and scores them according to an algorithm.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/weightMethods"
          },
          {
            "$ref": "#/components/parameters/context"
          },
          {
            "$ref": "#/components/parameters/baselineAfter"
          },
          {
            "$ref": "#/components/parameters/baselineBefore"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/tier"
          },
          {
            "$ref": "#/components/parameters/points"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup1"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroupOptions1"
          }
        ],
        "responses": {
          "200": {
            "description": "JSON object with weights for each context, chart and dimension.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/weights"
                }
              }
            }
          },
          "400": {
            "description": "The given parameters are invalid."
          },
          "403": {
            "description": "metrics correlations are not enabled on this Netdata Agent."
          },
          "404": {
            "description": "No charts could be found, or the method that correlated the metrics did not produce any result."
          },
          "504": {
            "description": "Timeout - the query took too long and has been cancelled."
          }
        }
      }
    },
    "/api/v1/metric_correlations": {
      "get": {
        "deprecated": true,
        "operationId": "metricCorrelations1",
        "tags": [
          "weights"
        ],
        "summary": "Analyze all the metrics to find their correlations - EOL",
        "description": "THIS ENDPOINT IS OBSOLETE. Use the /weights endpoint. Given two time-windows (baseline, highlight), it goes through all the available metrics, querying both windows and tries to find how these two windows relate to each other. It supports multiple algorithms to do so. The result is a list of all metrics evaluated, weighted for 0.0 (the two windows are more different) to 1.0 (the two windows are similar). The algorithm adjusts automatically the baseline window to be a power of two multiple of the highlighted (1, 2, 4, 8, etc).\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/weightMethods"
          },
          {
            "$ref": "#/components/parameters/baselineAfter"
          },
          {
            "$ref": "#/components/parameters/baselineBefore"
          },
          {
            "$ref": "#/components/parameters/after"
          },
          {
            "$ref": "#/components/parameters/before"
          },
          {
            "$ref": "#/components/parameters/points"
          },
          {
            "$ref": "#/components/parameters/tier"
          },
          {
            "$ref": "#/components/parameters/timeoutMS"
          },
          {
            "$ref": "#/components/parameters/dataQueryOptions"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroup1"
          },
          {
            "$ref": "#/components/parameters/dataTimeGroupOptions1"
          }
        ],
        "responses": {
          "200": {
            "description": "JSON object with weights for each chart and dimension.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/metric_correlations"
                }
              }
            }
          },
          "400": {
            "description": "The given parameters are invalid."
          },
          "403": {
            "description": "metrics correlations are not enabled on this Netdata Agent."
          },
          "404": {
            "description": "No charts could be found, or the method that correlated the metrics did not produce any result."
          },
          "504": {
            "description": "Timeout - the query took too long and has been cancelled."
          }
        }
      }
    },
    "/api/v1/function": {
      "get": {
        "deprecated": true,
        "operationId": "function1",
        "tags": [
          "functions"
        ],
        "description": "|\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "function",
            "in": "query",
            "description": "The name of the function, as returned by the collector.",
            "required": true,
            "allowEmptyValue": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/timeoutSecs"
          }
        ],
        "responses": {
          "200": {
            "description": "The collector function has been executed successfully. Each collector may return a different type of content."
          },
          "400": {
            "description": "The request was rejected by the collector."
          },
          "404": {
            "description": "The requested function is not found."
          },
          "500": {
            "description": "Other internal error, getting this error means there is a bug in Netdata."
          },
          "503": {
            "description": "The collector to execute the function is not currently available."
          },
          "504": {
            "description": "Timeout while waiting for the collector to execute the function."
          },
          "591": {
            "description": "The collector sent a response, but it was invalid or corrupted."
          }
        }
      }
    },
    "/api/v1/functions": {
      "get": {
        "deprecated": true,
        "operationId": "functions1",
        "tags": [
          "functions"
        ],
        "summary": "Get a list of all registered collector functions.",
        "description": "Collector functions are programs that can be executed on demand.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "A JSON object containing one object per supported function."
          }
        }
      }
    },
    "/api/v1/alarms": {
      "get": {
        "deprecated": true,
        "operationId": "alerts1",
        "tags": [
          "alerts"
        ],
        "summary": "Get a list of active or raised alarms on the server",
        "description": "The alarms endpoint returns the list of all raised or enabled alarms on the netdata server. Called without any parameters, the raised alarms in state WARNING or CRITICAL are returned. By passing \"?all\", all the enabled alarms are returned.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "all",
            "in": "query",
            "description": "If passed, all enabled alarms are returned.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "active",
            "in": "query",
            "description": "If passed, the raised alarms in state WARNING or CRITICAL are returned.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An object containing general info and a linked list of alarms.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alarms"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/alarms_values": {
      "get": {
        "deprecated": true,
        "operationId": "alertValues1",
        "tags": [
          "alerts"
        ],
        "summary": "Get a list of active or raised alarms on the server",
        "description": "The alarms_values endpoint returns the list of all raised or enabled alarms on the netdata server. Called without any parameters, the raised alarms in state WARNING or CRITICAL are returned. By passing '?all', all the enabled alarms are returned. This option output differs from `/alarms` in the number of variables delivered. This endpoint gives to user `id`, `value`, `last_updated` time, and alarm `status`.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "all",
            "in": "query",
            "description": "If passed, all enabled alarms are returned.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "active",
            "in": "query",
            "description": "If passed, the raised alarms in state WARNING or CRITICAL are returned.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An object containing general info and a linked list of alarms.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alarms_values"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/alarm_log": {
      "get": {
        "deprecated": true,
        "operationId": "alertsLog1",
        "tags": [
          "alerts"
        ],
        "summary": "Retrieves the entries of the alarm log",
        "description": "Returns an array of alarm_log entries, with historical information on raised and cleared alarms.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "after",
            "in": "query",
            "description": "Passing the parameter after=UNIQUEID returns all the events in the alarm log that occurred after UNIQUEID. An automated series of calls would call the interface once without after=, store the last UNIQUEID of the returned set, and give it back to get incrementally the next events.\n",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An array of alarm log entries.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/alarm_log_entry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/alarm_count": {
      "get": {
        "deprecated": true,
        "operationId": "alertsCount1",
        "tags": [
          "alerts"
        ],
        "summary": "Get an overall status of the chart",
        "description": "Checks multiple charts with the same context and counts number of alarms with given status.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/context"
          },
          {
            "name": "status",
            "in": "query",
            "description": "Specify alarm status to count.",
            "required": false,
            "allowEmptyValue": true,
            "schema": {
              "type": "string",
              "enum": [
                "REMOVED",
                "UNDEFINED",
                "UNINITIALIZED",
                "CLEAR",
                "RAISED",
                "WARNING",
                "CRITICAL"
              ],
              "default": "RAISED"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "An object containing a count of alarms with given status for given contexts.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal server error. This usually means the server is out of memory."
          }
        }
      }
    },
    "/api/v1/alarm_variables": {
      "get": {
        "deprecated": true,
        "operationId": "getNodeAlertVariables1",
        "tags": [
          "alerts"
        ],
        "summary": "List variables available to configure alarms for a chart",
        "description": "Returns the basic information of a chart and all the variables that can be used in alarm and template health configurations for the particular chart or family.\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "chart",
            "in": "query",
            "description": "The id of the chart as returned by the /charts call.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "as returned by /charts",
              "default": "system.cpu"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A javascript object with information about the chart and the available variables.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/alarm_variables"
                }
              }
            }
          },
          "400": {
            "description": "Bad request - the body will include a message stating what is wrong."
          },
          "404": {
            "description": "No chart with the given id is found."
          },
          "500": {
            "description": "Internal server error. This usually means the server is out of memory."
          }
        }
      }
    },
    "/api/v1/manage/health": {
      "get": {
        "deprecated": true,
        "operationId": "health1",
        "tags": [
          "management"
        ],
        "summary": "Accesses the health management API to control health checks and notifications at runtime.\n",
        "description": "Available from Netdata v1.12 and above, protected via bearer authorization. Especially useful for maintenance periods, the API allows you to disable health checks completely, silence alarm notifications, or Disable/Silence specific alarms that match selectors on alarm/template name, chart, context, host and family. For the simple disable/silence all scenarios, only the cmd parameter is required. The other parameters are used to define alarm selectors. For more information and examples, refer to the netdata documentation.\n\n**Security & Access Control:**\n- 🔧 **Management API** - Subject to management ACL restrictions\n- **IP Restrictions:** Controlled by `allow management from` in netdata.conf (default: localhost only)\n- **Internal Permissions:** Each management action has its own permission requirements\n- **No Bearer Protection:** Not subject to bearer token authentication\n",
        "parameters": [
          {
            "name": "cmd",
            "in": "query",
            "description": "DISABLE ALL: No alarm criteria are evaluated, nothing is written in the alarm log. SILENCE ALL: No notifications are sent. RESET: Return to the default state. DISABLE/SILENCE: Set the mode to be used for the alarms matching the criteria of the alarm selectors. LIST: Show active configuration.\n",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "DISABLE ALL",
                "SILENCE ALL",
                "DISABLE",
                "SILENCE",
                "RESET",
                "LIST"
              ]
            }
          },
          {
            "name": "alarm",
            "in": "query",
            "description": "The expression provided will match both `alarm` and `template` names.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "chart",
            "in": "query",
            "description": "Chart ids/names, as shown on the dashboard. These will match the `on` entry of a configured `alarm`.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "context",
            "in": "query",
            "description": "Chart context, as shown on the dashboard. These will match the `on` entry of a configured `template`.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "hosts",
            "in": "query",
            "description": "The hostnames that will need to match.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A plain text response based on the result of the command."
          },
          "403": {
            "description": "Bearer authentication error."
          }
        }
      }
    },
    "/api/v1/aclk": {
      "get": {
        "deprecated": true,
        "operationId": "aclk1",
        "tags": [
          "management"
        ],
        "summary": "Get information about current ACLK state",
        "description": "ACLK endpoint returns detailed information about current state of ACLK (Agent to Cloud communication).\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "JSON object with ACLK information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/aclk_state"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/variable": {
      "get": {
        "deprecated": true,
        "operationId": "variable1",
        "tags": [
          "data"
        ],
        "summary": "[DEPRECATED] Get a chart variable value",
        "description": "**[DEPRECATED - Use `/api/v3/variable` instead]**\n\n**Chart Variable Retrieval**\n\nThis endpoint returns the current value of a chart variable. Variables are values computed by Netdata that can be used in alert expressions and calculations. Each chart can have multiple variables representing different aspects of its data.\n\n**Common Variables:**\n- Calculated values (averages, sums, percentages)\n- Threshold values used in alerts\n- State information (counts, flags)\n- Time-based values (last update, collection duration)\n\n**Use Cases:**\n- **Alert Debugging:** Check variable values used in alert conditions\n- **Custom Calculations:** Retrieve computed values for external processing\n- **Monitoring Verification:** Verify that calculated variables match expectations\n- **Integration:** Feed variable values to external monitoring systems\n\n**Migration to v3:**\nUse `/api/v3/variable` which provides the same functionality with enhanced error handling and clearer response format.\n\n**Security:**\n- Requires appropriate data access permissions\n- Variables may contain sensitive metrics information\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "parameters": [
          {
            "name": "chart",
            "in": "query",
            "description": "Chart ID for which to retrieve the variable. This is the full chart ID as shown in the dashboard.\n\n**Examples:**\n- `system.cpu` - System CPU usage chart\n- `disk.sda.io` - Disk I/O for sda\n- `nginx_local.connections` - Nginx connections\n",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "system.cpu"
          },
          {
            "name": "variable",
            "in": "query",
            "description": "Variable name to retrieve. Each chart has different variables available depending on its configuration and alert definitions.\n\n**Common Variables:**\n- `used` - Used value (for utilization charts)\n- `free` - Free value (for utilization charts)\n- `value` - Current value\n- `avg` - Average value\n- `sum` - Sum of all dimensions\n- Custom variable names defined in alert configurations\n",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "used"
          }
        ],
        "responses": {
          "200": {
            "description": "Variable value returned successfully",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "number",
                  "format": "double"
                },
                "example": 42.5
              }
            }
          },
          "400": {
            "description": "Bad request - missing chart or variable parameter"
          },
          "404": {
            "description": "Chart or variable not found"
          }
        }
      }
    },
    "/api/v1/registry": {
      "get": {
        "deprecated": true,
        "operationId": "registry1",
        "tags": [
          "registry"
        ],
        "summary": "[DEPRECATED] Registry operations for tracking dashboard access",
        "description": "**[DEPRECATED - Registry functionality being phased out]**\n\n**Dashboard Access Registry**\n\nThe registry API tracks which dashboards (browsers) have accessed which Netdata agents, enabling features like:\n- Dashboard synchronization across multiple agents\n- Tracking which users/machines accessed which agents\n- Migrating dashboard preferences between agents\n\n**Actions:**\n\n**1. hello** - Initial registry contact\n- Identifies the dashboard to the registry\n- Returns person_guid for tracking this dashboard\n\n**2. access** - Record dashboard accessing an agent\n- Called when a dashboard accesses a Netdata agent\n- Tracks the relationship between dashboard and agent\n- Parameters: machine, url, name\n\n**3. delete** - Remove a tracked agent URL\n- Removes a specific agent URL from dashboard's history\n- Parameters: machine, url, name, delete_url\n\n**4. search** - Find all agents accessed by a dashboard\n- Returns list of all agents this dashboard has accessed\n- Parameter: for (machine_guid to search for)\n\n**5. switch** - Migrate dashboard identity\n- Transfers tracking from one person_guid to another\n- Parameters: machine, url, name, to (new person_guid)\n\n**Use Cases:**\n- **Multi-Agent Dashboards:** Track which agents a user has accessed\n- **Dashboard Migration:** Move identity between browsers/machines\n- **Access History:** See which dashboards accessed an agent\n- **Cleanup:** Remove old/invalid agent entries\n\n**Security Notes:**\n- Registry stores dashboard-agent relationships\n- person_guid is stored in browser cookies\n- machine_guid identifies Netdata agents\n- No authentication required (deprecated functionality)\n\n**Deprecation:**\nRegistry functionality is being phased out. Modern deployments should use Netdata Cloud for multi-agent management.\n\n**Security & Access Control:**\n- 🔓 **Always Public API** - This endpoint is always accessible without authentication\n- **Internal ACL:** Manages its own access control internally (not via standard ACL)\n- **No External Restrictions:** Not subject to bearer protection or IP-based ACL\n",
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "description": "Registry action to perform.\n\n**Available Actions:**\n- `hello` - Initial contact with registry\n- `access` - Record dashboard access to agent\n- `delete` - Remove agent URL from dashboard history\n- `search` - Find all agents accessed by dashboard\n- `switch` - Migrate dashboard identity to new person_guid\n",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "hello",
                "access",
                "delete",
                "search",
                "switch"
              ]
            },
            "example": "access"
          },
          {
            "name": "machine",
            "in": "query",
            "description": "Machine GUID of the dashboard making the request. This is typically stored in browser cookies and identifies the specific browser/client.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "example": "12345678-1234-1234-1234-123456789012"
          },
          {
            "name": "name",
            "in": "query",
            "description": "Human-readable name for the dashboard/machine (typically hostname). Used for display purposes in registry listings.\n",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "my-laptop"
          },
          {
            "name": "url",
            "in": "query",
            "description": "URL of the Netdata agent being accessed. This is the full URL including protocol and port.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uri"
            },
            "example": "http://netdata.example.com:19999"
          },
          {
            "name": "delete_url",
            "in": "query",
            "description": "URL to delete from the registry (used with action=delete). Must match a previously registered URL.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uri"
            },
            "example": "http://old-server.example.com:19999"
          },
          {
            "name": "for",
            "in": "query",
            "description": "Machine GUID to search for (used with action=search). Returns all agents accessed by this machine.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "example": "12345678-1234-1234-1234-123456789012"
          },
          {
            "name": "to",
            "in": "query",
            "description": "New person_guid to switch to (used with action=switch). Migrates the dashboard identity to a new person_guid.\n",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "example": "87654321-4321-4321-4321-210987654321"
          }
        ],
        "responses": {
          "200": {
            "description": "Registry operation successful",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Response varies by action type"
                }
              }
            }
          },
          "400": {
            "description": "Invalid action or missing required parameters"
          }
        }
      }
    },
    "/api/v1/dbengine_stats": {
      "get": {
        "deprecated": true,
        "operationId": "dbengine_stats1",
        "tags": [
          "management"
        ],
        "summary": "[DEPRECATED] Get DBEngine storage statistics",
        "description": "**[DEPRECATED - Use Netdata Cloud or internal metrics for storage monitoring]**\n\n**DBEngine Storage Statistics**\n\nReturns detailed statistics about Netdata's DBEngine storage system for all configured storage tiers. DBEngine is Netdata's high-performance time-series database that stores metrics on disk.\n\n**Statistics Provided (per tier):**\n\n**Datafiles:**\n- Active datafiles count\n- Total datafiles (active + archived)\n- Datafile size limits\n\n**Extents:**\n- Number of extents (storage chunks)\n- Extent compression statistics\n- Extent allocation and fragmentation\n\n**Pages:**\n- Page cache statistics\n- Page types (hot, cold, compressed)\n- Page I/O statistics\n\n**Compression:**\n- Compression ratios achieved\n- Compression algorithm efficiency\n- Space saved by compression\n\n**Retention:**\n- Actual retention achieved\n- Retention limits and targets\n- Disk space usage\n\n**Performance:**\n- Read/write rates\n- Cache hit ratios\n- I/O wait times\n\n**Use Cases:**\n- **Capacity Planning:** Monitor disk space usage trends\n- **Performance Tuning:** Analyze cache efficiency and I/O patterns\n- **Storage Optimization:** Review compression ratios and retention\n- **Troubleshooting:** Diagnose DBEngine performance issues\n\n**Storage Tiers:**\nNetdata supports multiple storage tiers with different retention periods:\n- **Tier 0:** High resolution (1-second), short retention\n- **Tier 1:** Medium resolution, medium retention\n- **Tier 2:** Low resolution, long retention\n\n**Availability:**\nThis endpoint only works if DBEngine is enabled. Returns 404 if DBEngine is disabled.\n\n**Migration:**\nModern Netdata installations should use:\n- Netdata Cloud for storage monitoring across agents\n- Internal metrics: `netdata.dbengine_*` charts\n- System info API for aggregate statistics\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "DBEngine statistics for all tiers",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Object with one property per tier (tier0, tier1, tier2, etc.) containing detailed statistics",
                  "additionalProperties": {
                    "type": "object",
                    "description": "Statistics for this specific tier"
                  }
                },
                "example": {
                  "tier0": {
                    "datafiles_active": 4,
                    "datafiles_total": 12,
                    "extents_total": 156789,
                    "pages_total": 8934567,
                    "compression_ratio": 3.2,
                    "disk_space_bytes": 524288000,
                    "retention_seconds": 86400
                  },
                  "tier1": {
                    "datafiles_active": 2,
                    "datafiles_total": 6,
                    "extents_total": 45678,
                    "pages_total": 1234567,
                    "compression_ratio": 4.1,
                    "disk_space_bytes": 134217728,
                    "retention_seconds": 604800
                  }
                }
              }
            }
          },
          "404": {
            "description": "DBEngine is not enabled"
          },
          "503": {
            "description": "Service unavailable - Netdata not ready"
          }
        }
      }
    },
    "/api/v1/ml_info": {
      "get": {
        "deprecated": true,
        "operationId": "ml_info1",
        "tags": [
          "management"
        ],
        "summary": "[DEPRECATED] Get machine learning detection information",
        "description": "**[DEPRECATED - Use internal metrics and Netdata Cloud for ML monitoring]**\n\n**Machine Learning Detection Info**\n\nReturns information about Netdata's built-in machine learning (ML) anomaly detection system for the specified host. Netdata trains ML models on every metric to detect anomalous behavior in real-time.\n\n**Information Provided:**\n\n**Training Status:**\n- Whether ML is enabled and trained\n- Training progress and completion percentage\n- Number of models trained\n- Training time and resource usage\n\n**Detection Configuration:**\n- Detection sensitivity settings\n- Anomaly detection thresholds\n- Update frequency\n- Model parameters\n\n**Model Statistics:**\n- Number of dimensions being modeled\n- Model types in use (k-means, etc.)\n- Model accuracy metrics\n- Training data requirements\n\n**Detection State:**\n- Current anomaly detection status\n- Recent anomaly counts\n- Detection performance metrics\n\n**Use Cases:**\n- **ML Verification:** Confirm ML is trained and detecting anomalies\n- **Troubleshooting:** Diagnose why ML isn't detecting issues\n- **Configuration:** Verify ML settings are applied correctly\n- **Monitoring:** Track ML training progress on new agents\n\n**Availability:**\nThis endpoint only works if:\n- Netdata was compiled with ML support (`ENABLE_ML`)\n- ML is enabled in configuration\n- The agent has finished initial startup\n\nReturns 503 (Service Unavailable) if ML is not compiled in or not ready.\n\n**Machine Learning in Netdata:**\n- Trains individual k-means models for every metric dimension\n- Updates models continuously as new data arrives\n- Detects anomalies in real-time (within seconds)\n- No configuration required - works out of the box\n- Models stored locally, no data sent to cloud\n\n**Migration:**\nModern deployments should:\n- Use internal metrics: `netdata.ml_*` charts\n- Check Netdata Cloud for ML insights\n- Use alert transitions API to see ML-based alerts\n- Monitor anomaly rates via `/api/v2/data` with appropriate options\n\n**Security & Access Control:**\n- 📊 **Public Data API** - Bearer token optional, IP-based ACL restrictions apply\n- **Default Access:** Public (no authentication required)\n- **Bearer Protection:** When enabled via `/api/v3/bearer_protection`, requires bearer token\n- **IP Restrictions:** Subject to `allow dashboard from` in netdata.conf\n- **Access Methods:** Direct HTTP/HTTPS, Netdata Cloud, external tools\n",
        "security": [
          {},
          {
            "bearerAuth": []
          }
        ],
        "responses": {
          "200": {
            "description": "ML detection information for the host",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "description": "Machine learning detection configuration and status"
                },
                "example": {
                  "enabled": true,
                  "trained": true,
                  "training_progress": 100,
                  "models_trained": 1247,
                  "dimensions_monitored": 1247,
                  "detection_enabled": true,
                  "anomaly_detection_running": true
                }
              }
            }
          },
          "503": {
            "description": "Service unavailable - ML not compiled in, not enabled, or Netdata not ready"
          }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "description": "Bearer token authentication for API access when bearer protection is enabled.\n\n**How to obtain a token:**\n1. Token must be obtained via `/api/v3/bearer_get_token` endpoint\n2. This endpoint is ACLK-only (requires Netdata Cloud access)\n3. Token includes role-based access control and expiration time\n\n**How to use:**\n```\nAuthorization: Bearer <token>\n```\n\n**When required:**\n- When bearer protection is enabled on the agent (via `/api/v3/bearer_protection`)\n- Applies to all APIs with `HTTP_ACCESS_ANONYMOUS_DATA` permission\n- Does not apply to APIs with `HTTP_ACL_NOCHECK` (always public)\n- Does not apply to ACLK-only APIs (use cloud authentication)\n\n**Token expiration:**\n- Tokens are time-limited and must be renewed periodically\n- Expired tokens return HTTP 401 Unauthorized\n"
      },
      "aclkAuth": {
        "type": "http",
        "scheme": "bearer",
        "description": "ACLK-only authentication - these APIs are ONLY accessible via Netdata Cloud (ACLK).\n\n**Access Requirements:**\n- User must be authenticated via Netdata Cloud (`SIGNED_ID`)\n- User and agent must be in the same Netdata Cloud space (`SAME_SPACE`)\n- Additional role-based permissions may apply per endpoint\n\n**NOT accessible via:**\n- Direct HTTP/HTTPS to agent (even with bearer token)\n- Local dashboard\n- External integrations\n\n**Available only through:**\n- Netdata Cloud web interface\n- Netdata Cloud API (ACLK tunnel)\n\n**Development mode:**\n- Can be made available in dev mode with `ACL_DEV_OPEN_ACCESS` flag\n"
      },
      "ipAcl": {
        "type": "apiKey",
        "in": "header",
        "name": "X-Forwarded-For",
        "description": "IP-based Access Control List restrictions (informational only).\n\n**Configuration:**\nAPIs are subject to IP-based ACL restrictions configured in `netdata.conf`:\n\n```conf\n[web]\n    allow dashboard from = *\n    allow badges from = *\n    allow management from = localhost\n```\n\n**ACL Categories:**\n- `allow dashboard from` - Controls access to metrics, alerts, nodes, functions, config APIs\n- `allow badges from` - Controls access to badge generation APIs\n- `allow management from` - Controls access to management APIs\n\n**Default behavior:**\n- Most APIs allow access from any IP by default\n- Management APIs restrict to localhost by default\n- Can be customized per deployment\n\n**Note:** This is not a standard authentication mechanism but rather IP filtering.\nAPIs with `HTTP_ACL_NOCHECK` bypass all IP restrictions.\n"
      }
    },
    "parameters": {
      "scopeNodes": {
        "name": "scope_nodes",
        "in": "query",
        "description": "A simple pattern limiting the nodes scope of the query. The scope controls both data and metadata response. The simple pattern is checked against the nodes' machine guid, node id and hostname. The default nodes scope is all nodes for which this Agent has data for. Usually the nodes scope is used to slice the entire dashboard (e.g. the Global Nodes Selector at the Netdata Cloud overview dashboard). Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "scopeContexts": {
        "name": "scope_contexts",
        "in": "query",
        "description": "A simple pattern limiting the contexts scope of the query. The scope controls both data and metadata response. The default contexts scope is all contexts for which this Agent has data for. Usually the contexts scope is used to slice data on the dashboard (e.g. each context based chart has its own contexts scope, limiting the chart to all the instances of the selected context). Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "scopeInstances": {
        "name": "scope_instances",
        "in": "query",
        "description": "A simple pattern limiting the instances scope of the query. The scope controls both data and metadata response. This limits which instances are even considered for the query, including their visibility in the query response metadata. The simple pattern is checked against the instance `id`, the instance `name`, the fully qualified name of the instance `id` and `name`, like `instance@machine_guid`, where `instance` is either its `id` or `name`. Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "scopeLabels": {
        "name": "scope_labels",
        "in": "query",
        "description": "A simple pattern limiting the labels scope of the query. The scope controls both data and metadata response. This limits which instances are even considered for the query based on their labels. The simple pattern is checked against `name:value` of all the labels of all the eligible instances (as filtered by scope nodes, scope contexts, and scope instances). Only instances having labels that match this pattern will be included in the query. Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "scopeDimensions": {
        "name": "scope_dimensions",
        "in": "query",
        "description": "A simple pattern limiting the dimensions scope of the query. The scope controls both data and metadata response. This limits which dimensions are even considered for the query, including their visibility in the query response metadata. The simple pattern is checked against both the dimension `id` and `name`. Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "filterNodes": {
        "name": "nodes",
        "in": "query",
        "description": "A simple pattern matching the nodes to be queried. This only controls the data response, not the metadata. The simple pattern is checked against the nodes' machine guid, node id, hostname. The default nodes selector is all the nodes matched by the nodes scope. Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "filterContexts": {
        "name": "contexts",
        "in": "query",
        "description": "A simple pattern matching the contexts to be queried. This only controls the data response, not the metadata. Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "filterInstances": {
        "name": "instances",
        "in": "query",
        "description": "A simple pattern matching the instances to be queried. The simple pattern is checked against the instance `id`, the instance `name`, the fully qualified name of the instance `id` and `name`, like `instance@machine_guid`, where `instance` is either its `id` or `name`. Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "filterLabels": {
        "name": "labels",
        "in": "query",
        "description": "A simple pattern matching the labels to be queried. The simple pattern is checked against `name:value` of all the labels of all the eligible instances (as filtered by all the above: scope nodes, scope contexts, nodes, contexts and instances). Negative simple patterns should not be used in this filter.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "filterAlerts": {
        "name": "alerts",
        "in": "query",
        "description": "A simple pattern matching the alerts to be queried. The simple pattern is checked against the `name` of alerts and the combination of `name:status`, when status is one of `CLEAR`, `WARNING`, `CRITICAL`, `REMOVED`, `UNDEFINED`, `UNINITIALIZED`, of all the alerts of all the eligible instances (as filtered by all the above). A negative simple pattern will exclude the instances having the labels matched.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "filterDimensions": {
        "name": "dimensions",
        "in": "query",
        "description": "A simple patterns matching the dimensions to be queried. The simple pattern is checked against and `id` and the `name` of the dimensions of the eligible instances (as filtered by all the above). Both positive and negative simple pattern expressions are supported.\n",
        "required": false,
        "schema": {
          "type": "string",
          "format": "simple pattern",
          "default": "*"
        }
      },
      "dataFormat1": {
        "name": "format",
        "in": "query",
        "description": "The format of the data to be returned.",
        "allowEmptyValue": false,
        "schema": {
          "type": "string",
          "enum": [
            "json",
            "jsonp",
            "csv",
            "tsv",
            "tsv-excel",
            "ssv",
            "ssvcomma",
            "datatable",
            "datasource",
            "html",
            "markdown",
            "array",
            "csvjsonarray"
          ],
          "default": "json"
        }
      },
      "dataFormat2": {
        "name": "format",
        "in": "query",
        "description": "The format of the data to be returned.",
        "allowEmptyValue": false,
        "schema": {
          "type": "string",
          "enum": [
            "json",
            "json2",
            "jsonp",
            "csv",
            "tsv",
            "tsv-excel",
            "ssv",
            "ssvcomma",
            "datatable",
            "datasource",
            "html",
            "markdown",
            "array",
            "csvjsonarray"
          ],
          "default": "json2"
        }
      },
      "dataQueryOptions": {
        "name": "options",
        "in": "query",
        "description": "Options that affect data generation.\n* `jsonwrap` - Wrap the output in a JSON object with metadata about the query.\n* `raw` - change the output so that it is aggregatable across multiple such queries. Supported by `/api/v2` data queries and `json2` format.\n* `minify` - Remove unnecessary spaces and newlines from the output.\n* `debug` - Provide additional information in `jsonwrap` output to help tracing issues.\n* `nonzero` - Do not return dimensions that all their values are zero, to improve the visual appearance of charts. They will still be returned if all the dimensions are entirely zero.\n* `null2zero` - Replace `null` values with `0`.\n* `absolute` or `abs` - Traditionally Netdata returns select dimensions negative to improve visual appearance. This option turns this feature off.\n* `display-absolute` - Only used by badges, to do color calculation using the signed value, but render the value without a sign.\n* `flip` or `reversed` - Order the timestamps array in reverse order (newest to oldest).\n* `min2max` - When flattening multi-dimensional data into a single metric format, use `max - min` instead of `sum`. This is EOL - use `/api/v2` to control aggregation across dimensions.\n* `percentage` - Convert all values into a percentage vs the row total. When enabled, Netdata will query all dimensions, even the ones that have not been selected or are hidden, to find the row total, in order to calculate the percentage of each dimension selected.\n* `seconds` - Output timestamps in seconds instead of dates.\n* `milliseconds` or `ms` - Output timestamps in milliseconds instead of dates.\n* `unaligned` - by default queries are aligned to the the view, so that as time passes past data returned do not change. When a data query will not be used for visualization, `unaligned` can be given to avoid aligning the query time-frame for visual precision.\n* `match-ids`, `match-names`. By default filters match both IDs and names when they are available. Setting either of the two options will disable the other.\n* `anomaly-bit` - query the anomaly information instead of metric values. This is EOL, use `/api/v2` and `json2` format which always returns this information and many more.\n* `jw-anomaly-rates` - return anomaly rates as a separate result set in the same `json` format response. This is EOL, use `/api/v2` and `json2` format which always returns information and many more. \n* `details` - `/api/v2/data` returns in `jsonwrap` the full tree of dimensions that have been matched by the query.\n* `group-by-labels` - `/api/v2/data` returns in `jsonwrap` flattened labels per output dimension. These are used to identify the instances that have been aggregated into each dimension, making it possible to provide a map, like Netdata does for Kubernetes.\n* `natural-points` - return timestamps as found in the database. The result is again fixed-step, but the query engine attempts to align them with the timestamps found in the database.\n* `virtual-points` - return timestamps independent of the database alignment. This is needed aggregating data across multiple Netdata Agents, to ensure that their outputs do not need to be interpolated to be merged.\n* `selected-tier` - use data exclusively from the selected tier given with the `tier` parameter. This option is set automatically when the `tier` parameter is set.\n* `all-dimensions` - In `/api/v1` `jsonwrap` include metadata for all candidate metrics examined. In `/api/v2` this is standard behavior and no option is needed.\n* `label-quotes` - In `csv` output format, enclose each header label in quotes.\n* `objectrows` - Each row of value should be an object, not an array (only for `json` format).\n* `google_json` - Comply with google JSON/JSONP specs (only for `json` format).\n* `minimal-stats` or `minimal` - Reduce the amount of statistics returned in `jsonwrap` format to save bandwidth.\n* `long-json-keys` or `long-keys` - Use descriptive key names in JSON output instead of abbreviated ones.\n* `mcp-info` - Include additional metadata useful for the Model Context Protocol (MCP) integration.\n* `rfc3339` - Return timestamps in RFC3339 format (e.g., \"2023-01-01T00:00:00Z\") instead of Unix timestamps.\n",
        "required": false,
        "allowEmptyValue": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "jsonwrap",
              "raw",
              "minify",
              "debug",
              "nonzero",
              "null2zero",
              "abs",
              "absolute",
              "display-absolute",
              "flip",
              "reversed",
              "min2max",
              "percentage",
              "seconds",
              "ms",
              "milliseconds",
              "unaligned",
              "match-ids",
              "match-names",
              "anomaly-bit",
              "jw-anomaly-rates",
              "details",
              "group-by-labels",
              "natural-points",
              "virtual-points",
              "selected-tier",
              "all-dimensions",
              "label-quotes",
              "objectrows",
              "google_json",
              "minimal-stats",
              "minimal",
              "long-json-keys",
              "long-keys",
              "mcp-info",
              "rfc3339"
            ]
          },
          "default": [
            "seconds",
            "jsonwrap"
          ]
        }
      },
      "dataTimeGroup1": {
        "name": "group",
        "in": "query",
        "description": "Time aggregation function. If multiple collected values are to be grouped in order to return fewer points, this parameters defines the method of grouping. If the `absolute` option is set, the values are turned positive before applying this calculation.\n",
        "required": false,
        "schema": {
          "type": "string",
          "enum": [
            "min",
            "max",
            "avg",
            "average",
            "median",
            "stddev",
            "sum",
            "incremental-sum",
            "ses",
            "des",
            "cv",
            "countif",
            "percentile",
            "percentile25",
            "percentile50",
            "percentile75",
            "percentile80",
            "percentile90",
            "percentile95",
            "percentile97",
            "percentile98",
            "percentile99",
            "trimmed-mean",
            "trimmed-mean1",
            "trimmed-mean2",
            "trimmed-mean3",
            "trimmed-mean5",
            "trimmed-mean10",
            "trimmed-mean15",
            "trimmed-mean20",
            "trimmed-mean25",
            "trimmed-median",
            "trimmed-median1",
            "trimmed-median2",
            "trimmed-median3",
            "trimmed-median5",
            "trimmed-median10",
            "trimmed-median15",
            "trimmed-median20",
            "trimmed-median25",
            "ema",
            "extremes"
          ],
          "default": "average"
        }
      },
      "dataTimeGroup2": {
        "name": "time_group",
        "in": "query",
        "description": "Time aggregation function. If multiple collected values are to be grouped in order to return fewer points, this parameters defines the method of grouping. If the `absolute` option is set, the values are turned positive before applying this calculation.\n",
        "required": false,
        "schema": {
          "type": "string",
          "enum": [
            "min",
            "max",
            "avg",
            "average",
            "median",
            "stddev",
            "sum",
            "incremental-sum",
            "ses",
            "des",
            "cv",
            "countif",
            "percentile",
            "percentile25",
            "percentile50",
            "percentile75",
            "percentile80",
            "percentile90",
            "percentile95",
            "percentile97",
            "percentile98",
            "percentile99",
            "trimmed-mean",
            "trimmed-mean1",
            "trimmed-mean2",
            "trimmed-mean3",
            "trimmed-mean5",
            "trimmed-mean10",
            "trimmed-mean15",
            "trimmed-mean20",
            "trimmed-mean25",
            "trimmed-median",
            "trimmed-median1",
            "trimmed-median2",
            "trimmed-median3",
            "trimmed-median5",
            "trimmed-median10",
            "trimmed-median15",
            "trimmed-median20",
            "trimmed-median25",
            "ema",
            "extremes"
          ],
          "default": "average"
        }
      },
      "dataTimeGroupOptions1": {
        "name": "group_options",
        "in": "query",
        "description": "When the time grouping function supports additional parameters, this field can be used to pass them to it. Currently `countif`, `trimmed-mean`, `trimmed-median` and `percentile` support this. For `countif` the string may start with `<`, `<=`, `<:`, `<>`, `!=`, `>`, `>=`, `>:`. For all others just a number is expected.\n",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "dataTimeGroupOptions2": {
        "name": "time_group_options",
        "in": "query",
        "description": "When the time grouping function supports additional parameters, this field can be used to pass them to it. Currently `countif`, `trimmed-mean`, `trimmed-median` and `percentile` support this. For `countif` the string may start with `<`, `<=`, `<:`, `<>`, `!=`, `>`, `>=`, `>:`. For all others just a number is expected.\n",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "cardinalityLimit": {
        "name": "cardinality_limit",
        "in": "query",
        "description": "Limits the number of unique items (contexts, instances, dimensions) returned in the query result. This is useful for preventing excessive memory usage and response sizes when queries match a large number of metrics. The query engine will return the most relevant items up to this limit.\n",
        "required": false,
        "schema": {
          "type": "integer",
          "format": "int64",
          "minimum": 1,
          "default": 10000
        }
      },
      "contextsQueryOptions": {
        "name": "options",
        "in": "query",
        "description": "Options that affect the output of contexts metadata queries.\n* `minify` - Remove unnecessary spaces and newlines from the output to reduce bandwidth.\n* `debug` - Provide additional debugging information in the response.\n* `config` - Include alert configuration information (used by /api/v2/alert_transitions).\n* `instances` - Include alert/context instance information (used by /api/v2/alerts).\n* `values` - Include latest metric values (used by /api/v2/alerts).\n* `summary` - Include summary counters (used by /api/v2/alerts).\n* `mcp` - Format output for Model Context Protocol (MCP) integration.\n* `dimensions` - Include dimension information for each context.\n* `labels` - Include label information for each context.\n* `priorities` - Include priority information for each context.\n* `titles` - Include title information for each context.\n* `rfc3339` - Return timestamps in RFC3339 format (e.g., \"2023-01-01T00:00:00Z\") instead of Unix timestamps.\n\nNote: Some options like `retention`, `liveness`, `family`, and `units` are automatically included by specific endpoints and cannot be controlled via this parameter.\n",
        "required": false,
        "allowEmptyValue": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "minify",
              "debug",
              "config",
              "instances",
              "values",
              "summary",
              "mcp",
              "dimensions",
              "labels",
              "priorities",
              "titles",
              "rfc3339"
            ]
          },
          "default": []
        }
      },
      "dataTimeResampling1": {
        "name": "gtime",
        "in": "query",
        "description": "The grouping number of seconds. This is used in conjunction with group=average to change the units of metrics (ie when the data is per-second, setting gtime=60 will turn them to per-minute).\n",
        "required": false,
        "allowEmptyValue": false,
        "schema": {
          "type": "number",
          "format": "integer",
          "default": 0
        }
      },
      "dataTimeResampling2": {
        "name": "time_resampling",
        "in": "query",
        "description": "For incremental values that are \"per second\", this value is used to resample them to \"per minute` (60) or \"per hour\" (3600). It can only be used in conjunction with group=average.\n",
        "required": false,
        "schema": {
          "type": "number",
          "format": "integer",
          "default": 0
        }
      },
      "timeoutMS": {
        "name": "timeout",
        "in": "query",
        "description": "Specify a timeout value in milliseconds after which the Agent will abort the query and return a 503 error. A value of 0 indicates no timeout.\n",
        "required": false,
        "schema": {
          "type": "number",
          "format": "integer",
          "default": 0
        }
      },
      "timeoutSecs": {
        "name": "timeout",
        "in": "query",
        "description": "Specify a timeout value in seconds after which the Agent will abort the query and return a 504 error. A value of 0 indicates no timeout, but some endpoints, like `weights`, do not accept infinite timeouts (they have a predefined default), so to disable the timeout it must be set to a really high value.\n",
        "required": false,
        "schema": {
          "type": "number",
          "format": "integer",
          "default": 0
        }
      },
      "before": {
        "name": "before",
        "in": "query",
        "description": "`after` and `before` define the time-frame of a query. `before` can be a negative number of seconds, up to 3 years (-94608000), relative to current clock. If not set, it is assumed to be the current clock time. When `before` is positive, it is assumed to be a unix epoch timestamp. When non-data endpoints support the `after` and `before`, they use the time-frame to limit their response for objects having data retention within the time-frame given.\n",
        "required": false,
        "schema": {
          "type": "integer",
          "default": 0
        }
      },
      "after": {
        "name": "after",
        "in": "query",
        "description": "`after` and `before` define the time-frame of a query. `after` can be a negative number of seconds, up to 3 years (-94608000), relative to `before`. If not set, it is usually assumed to be -600. When non-data endpoints support the `after` and `before`, they use the time-frame to limit their response for objects having data retention within the time-frame given.\n",
        "required": false,
        "schema": {
          "type": "integer",
          "default": -600
        }
      },
      "baselineBefore": {
        "name": "baseline_before",
        "in": "query",
        "description": "`baseline_after` and `baseline_before` define the baseline time-frame of a comparative query. `baseline_before` can be a negative number of seconds, up to 3 years (-94608000), relative to current clock. If not set, it is assumed to be the current clock time. When `baseline_before` is positive, it is assumed to be a unix epoch timestamp.\n",
        "required": false,
        "schema": {
          "type": "integer",
          "default": 0
        }
      },
      "baselineAfter": {
        "name": "baseline_after",
        "in": "query",
        "description": "`baseline_after` and `baseline_before` define the baseline time-frame of a comparative query. `baseline_after` can be a negative number of seconds, up to 3 years (-94608000), relative to `baseline_before`. If not set, it is usually assumed to be -300.\n",
        "required": false,
        "schema": {
          "type": "integer",
          "default": -600
        }
      },
      "points": {
        "name": "points",
        "in": "query",
        "description": "The number of points to be returned. If not given, or it is <= 0, or it is bigger than the points stored in the database for the given duration, all the available collected values for the given duration will be returned. For `weights` endpoints that do statistical analysis, the `points` define the detail of this analysis (the default is 500).\n",
        "required": false,
        "schema": {
          "type": "number",
          "format": "integer",
          "default": 0
        }
      },
      "tier": {
        "name": "tier",
        "in": "query",
        "description": "Use only the given dbengine tier for executing the query. Setting this parameters automatically sets the option `selected-tier` for the query.\n",
        "required": false,
        "schema": {
          "type": "number",
          "format": "integer"
        }
      },
      "callback": {
        "name": "callback",
        "in": "query",
        "description": "For JSONP responses, the callback function name.\n",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "filename": {
        "name": "filename",
        "in": "query",
        "description": "Add `Content-Disposition: attachment; filename=` header to the response, that will instruct the browser to save the response with the given filename.\"\n",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "tqx": {
        "name": "tqx",
        "in": "query",
        "description": "[Google Visualization API](https://developers.google.com/chart/interactive/docs/dev/implementing_data_source?hl=en) formatted parameter.\n",
        "required": false,
        "schema": {
          "type": "string"
        }
      },
      "contextOptions1": {
        "name": "options",
        "in": "query",
        "description": "Options that affect data generation.\n* `full` or `all` - Include all available information.\n* `charts` - Include chart information.\n* `dimensions` - Include dimension information.\n* `labels` - Include label information.\n* `uuids` - Include UUIDs in the response.\n* `queue` - Include queue information.\n* `flags` - Include internal flags.\n* `deleted` - Include deleted items.\n* `deepscan` - Perform a deep scan for contexts.\n* `rfc3339` - Return timestamps in RFC3339 format instead of Unix timestamps.\n",
        "required": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "full",
              "all",
              "charts",
              "dimensions",
              "labels",
              "uuids",
              "queue",
              "flags",
              "deleted",
              "deepscan",
              "rfc3339"
            ]
          }
        }
      },
      "chart": {
        "name": "chart",
        "in": "query",
        "description": "The id of the chart as returned by the `/api/v1/charts` call.",
        "required": false,
        "allowEmptyValue": false,
        "schema": {
          "type": "string",
          "format": "as returned by `/api/v1/charts`"
        }
      },
      "context": {
        "name": "context",
        "in": "query",
        "description": "The context of the chart as returned by the /charts call.",
        "required": false,
        "allowEmptyValue": false,
        "schema": {
          "type": "string",
          "format": "as returned by /charts"
        }
      },
      "dimension": {
        "name": "dimension",
        "in": "query",
        "description": "Zero, one or more dimension ids or names, as returned by the /chart call, separated with comma or pipe. Netdata simple patterns are supported.",
        "required": false,
        "allowEmptyValue": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "as returned by /charts"
          }
        }
      },
      "dimensions": {
        "name": "dimensions",
        "in": "query",
        "description": "a simple pattern matching dimensions (use comma or pipe as separator)",
        "required": false,
        "allowEmptyValue": true,
        "schema": {
          "type": "string"
        }
      },
      "chart_label_key": {
        "name": "chart_label_key",
        "in": "query",
        "description": "Specify the chart label keys that need to match for context queries as comma separated values. At least one matching key is needed to match the corresponding chart.\n",
        "required": false,
        "allowEmptyValue": false,
        "schema": {
          "type": "string",
          "format": "key1,key2,key3"
        }
      },
      "chart_labels_filter": {
        "name": "chart_labels_filter",
        "in": "query",
        "description": "Specify the chart label keys and values to match for context queries. All keys/values need to match for the chart to be included in the query. The labels are specified as key1:value1,key2:value2\n",
        "required": false,
        "allowEmptyValue": false,
        "schema": {
          "type": "string",
          "format": "key1:value1,key2:value2,key3:value3"
        }
      },
      "weightMethods": {
        "name": "method",
        "in": "query",
        "description": "The weighting / scoring algorithm.",
        "required": false,
        "schema": {
          "type": "string",
          "enum": [
            "ks2",
            "volume",
            "anomaly-rate",
            "value"
          ]
        }
      }
    },
    "schemas": {
      "info": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "description": "netdata version of the server.",
            "example": "1.11.1_rolling"
          },
          "uid": {
            "type": "string",
            "description": "netdata unique id of the server.",
            "example": "24e9fe3c-f2ac-11e8-bafc-0242ac110002"
          },
          "mirrored_hosts": {
            "type": "array",
            "description": "List of hosts mirrored of the server (include itself).",
            "items": {
              "type": "string"
            },
            "example": [
              "host1.example.com",
              "host2.example.com"
            ]
          },
          "mirrored_hosts_status": {
            "type": "array",
            "description": "List of details of hosts mirrored to this served (including self). Indexes correspond to indexes in \"mirrored_hosts\".",
            "items": {
              "type": "object",
              "description": "Host data",
              "properties": {
                "guid": {
                  "type": "string",
                  "format": "uuid",
                  "nullable": false,
                  "description": "Host unique GUID from `netdata.public.unique.id`.",
                  "example": "245e4bff-3b34-47c1-a6e5-5c535a9abfb2"
                },
                "reachable": {
                  "type": "boolean",
                  "nullable": false,
                  "description": "Current state of streaming. Always true for localhost/self."
                },
                "claim_id": {
                  "type": "string",
                  "format": "uuid",
                  "nullable": true,
                  "description": "Cloud GUID/identifier in case the host is claimed. If child status unknown or unclaimed this field is set to `null`",
                  "example": "c3b2a66a-3052-498c-ac52-7fe9e8cccb0c"
                }
              }
            }
          },
          "os_name": {
            "type": "string",
            "description": "Operating System Name.",
            "example": "Manjaro Linux"
          },
          "os_id": {
            "type": "string",
            "description": "Operating System ID.",
            "example": "manjaro"
          },
          "os_id_like": {
            "type": "string",
            "description": "Known OS similar to this OS.",
            "example": "arch"
          },
          "os_version": {
            "type": "string",
            "description": "Operating System Version.",
            "example": "18.0.4"
          },
          "os_version_id": {
            "type": "string",
            "description": "Operating System Version ID.",
            "example": "unknown"
          },
          "os_detection": {
            "type": "string",
            "description": "OS parameters detection method.",
            "example": "Mixed"
          },
          "kernel_name": {
            "type": "string",
            "description": "Kernel Name.",
            "example": "Linux"
          },
          "kernel_version": {
            "type": "string",
            "description": "Kernel Version.",
            "example": "4.19.32-1-MANJARO"
          },
          "is_k8s_node": {
            "type": "boolean",
            "description": "Netdata is running on a K8s node.",
            "example": false
          },
          "architecture": {
            "type": "string",
            "description": "Kernel architecture.",
            "example": "x86_64"
          },
          "virtualization": {
            "type": "string",
            "description": "Virtualization Type.",
            "example": "kvm"
          },
          "virt_detection": {
            "type": "string",
            "description": "Virtualization detection method.",
            "example": "systemd-detect-virt"
          },
          "container": {
            "type": "string",
            "description": "Container technology.",
            "example": "docker"
          },
          "container_detection": {
            "type": "string",
            "description": "Container technology detection method.",
            "example": "dockerenv"
          },
          "stream_compression": {
            "type": "boolean",
            "description": "Stream transmission compression method.",
            "example": true
          },
          "labels": {
            "type": "object",
            "description": "List of host labels.",
            "properties": {
              "app": {
                "type": "string",
                "description": "Host label.",
                "example": "netdata"
              }
            }
          },
          "collectors": {
            "type": "array",
            "items": {
              "type": "object",
              "description": "Array of collector plugins and modules.",
              "properties": {
                "plugin": {
                  "type": "string",
                  "description": "Collector plugin.",
                  "example": "python.d.plugin"
                },
                "module": {
                  "type": "string",
                  "description": "Module of the collector plugin.",
                  "example": "dockerd"
                }
              }
            }
          },
          "alarms": {
            "type": "object",
            "description": "Number of alarms in the server.",
            "properties": {
              "normal": {
                "type": "integer",
                "description": "Number of alarms in normal state."
              },
              "warning": {
                "type": "integer",
                "description": "Number of alarms in warning state."
              },
              "critical": {
                "type": "integer",
                "description": "Number of alarms in critical state."
              }
            }
          }
        }
      },
      "chart_summary": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string",
            "description": "The hostname of the netdata server."
          },
          "version": {
            "type": "string",
            "description": "netdata version of the server."
          },
          "release_channel": {
            "type": "string",
            "description": "The release channel of the build on the server.",
            "example": "nightly"
          },
          "timezone": {
            "type": "string",
            "description": "The current timezone on the server."
          },
          "os": {
            "type": "string",
            "description": "The netdata server host operating system.",
            "enum": [
              "macos",
              "linux",
              "freebsd"
            ]
          },
          "history": {
            "type": "number",
            "description": "The duration, in seconds, of the round robin database maintained by netdata."
          },
          "memory_mode": {
            "type": "string",
            "description": "The name of the database memory mode on the server."
          },
          "update_every": {
            "type": "number",
            "description": "The default update frequency of the netdata server. All charts have an update frequency equal or bigger than this."
          },
          "charts": {
            "type": "object",
            "description": "An object containing all the chart objects available at the netdata server. This is used as an indexed array. The key of each chart object is the id of the chart.",
            "additionalProperties": {
              "$ref": "#/components/schemas/chart"
            }
          },
          "charts_count": {
            "type": "number",
            "description": "The number of charts."
          },
          "dimensions_count": {
            "type": "number",
            "description": "The total number of dimensions."
          },
          "alarms_count": {
            "type": "number",
            "description": "The number of alarms."
          },
          "rrd_memory_bytes": {
            "type": "number",
            "description": "The size of the round robin database in bytes."
          }
        }
      },
      "chart": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique id of the chart."
          },
          "name": {
            "type": "string",
            "description": "The name of the chart."
          },
          "type": {
            "type": "string",
            "description": "The type of the chart. Types are not handled by netdata. You can use this field for anything you like."
          },
          "family": {
            "type": "string",
            "description": "The family of the chart. Families are not handled by netdata. You can use this field for anything you like."
          },
          "title": {
            "type": "string",
            "description": "The title of the chart."
          },
          "priority": {
            "type": "number",
            "description": "The relative priority of the chart. Netdata does not care about priorities. This is just an indication of importance for the chart viewers to sort charts of higher priority (lower number) closer to the top. Priority sorting should only be used among charts of the same type or family."
          },
          "enabled": {
            "type": "boolean",
            "description": "True when the chart is enabled. Disabled charts do not currently collect values, but they may have historical values available."
          },
          "units": {
            "type": "string",
            "description": "The unit of measurement for the values of all dimensions of the chart."
          },
          "data_url": {
            "type": "string",
            "description": "The absolute path to get data values for this chart. You are expected to use this path as the base when constructing the URL to fetch data values for this chart."
          },
          "chart_type": {
            "type": "string",
            "description": "The chart type.",
            "enum": [
              "line",
              "area",
              "stacked"
            ]
          },
          "duration": {
            "type": "number",
            "description": "The duration, in seconds, of the round robin database maintained by netdata."
          },
          "first_entry": {
            "type": "number",
            "description": "The UNIX timestamp of the first entry (the oldest) in the round robin database."
          },
          "last_entry": {
            "type": "number",
            "description": "The UNIX timestamp of the latest entry in the round robin database."
          },
          "update_every": {
            "type": "number",
            "description": "The update frequency of this chart, in seconds. One value every this amount of time is kept in the round robin database."
          },
          "dimensions": {
            "type": "object",
            "description": "An object containing all the chart dimensions available for the chart. This is used as an indexed array. For each pair in the dictionary: the key is the id of the dimension and the value is a dictionary containing the name.\"\n",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "The name of the dimension"
                }
              }
            }
          },
          "chart_variables": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/chart_variables"
            }
          },
          "green": {
            "type": "number",
            "nullable": true,
            "description": "Chart health green threshold."
          },
          "red": {
            "type": "number",
            "nullable": true,
            "description": "Chart health red threshold."
          }
        }
      },
      "context_summary": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string",
            "description": "The hostname of the netdata server."
          },
          "machine_guid": {
            "type": "string",
            "description": "The unique installation id of this netdata server."
          },
          "node_id": {
            "type": "string",
            "description": "The unique node id of this netdata server at the hub.",
            "example": "nightly"
          },
          "claim_id": {
            "type": "string",
            "description": "The unique handshake id of this netdata server and the hub."
          },
          "host_labels": {
            "type": "object",
            "description": "The host labels associated with this netdata server."
          },
          "context": {
            "type": "object",
            "description": "An object containing all the context objects available at the netdata server. This is used as an indexed array. The key of each context object is the id of the context.",
            "additionalProperties": {
              "$ref": "#/components/schemas/context"
            }
          }
        }
      },
      "context": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "description": "The version of this context. The number are not sequential, but bigger numbers depict a newer object."
          },
          "hub_version": {
            "type": "string",
            "description": "The version of this context, as known by hub."
          },
          "family": {
            "type": "string",
            "description": "The family of the context. When multiple charts of a context have different families, the netdata server replaces the different parts with [x], so that the context can have only one family."
          },
          "title": {
            "type": "string",
            "description": "The title of the context. When multiple charts of a context have different titles, the netdata server replaces the different parts with [x], so that the context can have only one title."
          },
          "priority": {
            "type": "number",
            "description": "The relative priority of the context. When multiple contexts have different priorities, the minimum among them is selected as the priority of the context."
          },
          "units": {
            "type": "string",
            "description": "The unit of measurement for the values of all dimensions of the context. If multiple charts of context have different units, the latest collected is selected."
          },
          "chart_type": {
            "type": "string",
            "description": "The chart type.",
            "enum": [
              "line",
              "area",
              "stacked"
            ]
          },
          "first_time_t": {
            "type": "number",
            "description": "The UNIX timestamp of the first entry (the oldest) in the database."
          },
          "last_time_t": {
            "type": "number",
            "description": "The UNIX timestamp of the latest entry in the database."
          },
          "charts": {
            "type": "object",
            "description": "An object containing all the charts available for the chart. This is used as an indexed array. For each pair in the dictionary, the key is the id of the chart and the value provides all details about the chart."
          }
        }
      },
      "alarm_variables": {
        "type": "object",
        "properties": {
          "chart": {
            "type": "string",
            "description": "The unique id of the chart."
          },
          "chart_name": {
            "type": "string",
            "description": "The name of the chart."
          },
          "cnart_context": {
            "type": "string",
            "description": "The context of the chart. It is shared across multiple monitored software or hardware instances and used in alarm templates."
          },
          "family": {
            "type": "string",
            "description": "The family of the chart."
          },
          "host": {
            "type": "string",
            "description": "The host containing the chart."
          },
          "chart_variables": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/chart_variables"
            }
          },
          "family_variables": {
            "type": "object",
            "properties": {
              "varname1": {
                "type": "number",
                "format": "float"
              },
              "varname2": {
                "type": "number",
                "format": "float"
              }
            }
          },
          "host_variables": {
            "type": "object",
            "properties": {
              "varname1": {
                "type": "number",
                "format": "float"
              },
              "varname2": {
                "type": "number",
                "format": "float"
              }
            }
          }
        }
      },
      "chart_variables": {
        "type": "object",
        "properties": {
          "varname1": {
            "type": "number",
            "format": "float"
          },
          "varname2": {
            "type": "number",
            "format": "float"
          }
        }
      },
      "jsonwrap2": {
        "description": "Data response with `format=json2`\n",
        "type": "object",
        "properties": {
          "api": {
            "$ref": "#/components/schemas/api"
          },
          "agents": {
            "$ref": "#/components/schemas/agents"
          },
          "versions": {
            "$ref": "#/components/schemas/versions"
          },
          "summary": {
            "description": "Summarized information about nodes, contexts, instances, labels, alerts, and dimensions. The items returned are determined by the scope of the query only, however the statistical data in them are influenced by the filters of the query. Using this information the dashboard allows users to slice and dice the data by filtering and grouping.\n",
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/nodeWithDataStatistics"
                }
              },
              "contexts": {
                "type": "array",
                "items": {
                  "type": "object",
                  "description": "An object describing a unique context. `is` stands for instances, `ds` for dimensions, `al` for alerts, `sts` for statistics.\n",
                  "properties": {
                    "id": {
                      "description": "the context id.",
                      "type": "string"
                    },
                    "is": {
                      "$ref": "#/components/schemas/jsonwrap2_items_count"
                    },
                    "ds": {
                      "$ref": "#/components/schemas/jsonwrap2_items_count"
                    },
                    "al": {
                      "$ref": "#/components/schemas/jsonwrap2_alerts_count"
                    },
                    "sts": {
                      "oneOf": [
                        {
                          "$ref": "#/components/schemas/jsonwrap2_sts"
                        },
                        {
                          "$ref": "#/components/schemas/jsonwrap2_sts_raw"
                        }
                      ]
                    }
                  }
                }
              },
              "instances": {
                "type": "array",
                "items": {
                  "type": "object",
                  "description": "An object describing an instance. `ds` stands for dimensions, `al` for alerts, `sts` for statistics.\n",
                  "properties": {
                    "id": {
                      "description": "the id of the instance.",
                      "type": "string"
                    },
                    "nm": {
                      "description": "the name of the instance (may be absent when it is the same with the id)",
                      "type": "string"
                    },
                    "ni": {
                      "description": "the node index id this instance belongs to. The UI uses this to compone the fully qualified name of the instance, using the node hostname to present it to users and its machine guid to add it to filters."
                    },
                    "ds": {
                      "$ref": "#/components/schemas/jsonwrap2_items_count"
                    },
                    "al": {
                      "$ref": "#/components/schemas/jsonwrap2_alerts_count"
                    },
                    "sts": {
                      "oneOf": [
                        {
                          "$ref": "#/components/schemas/jsonwrap2_sts"
                        },
                        {
                          "$ref": "#/components/schemas/jsonwrap2_sts_raw"
                        }
                      ]
                    }
                  }
                }
              },
              "dimensions": {
                "type": "array",
                "items": {
                  "type": "object",
                  "description": "An object describing a unique dimension. `ds` stands for `dimensions`, `sts` for statistics.\n",
                  "properties": {
                    "id": {
                      "description": "the id of the dimension.",
                      "type": "string"
                    },
                    "nm": {
                      "description": "the name of the dimension (may be absent when it is the same with the id)",
                      "type": "string"
                    },
                    "ds": {
                      "$ref": "#/components/schemas/jsonwrap2_items_count"
                    },
                    "sts": {
                      "oneOf": [
                        {
                          "$ref": "#/components/schemas/jsonwrap2_sts"
                        },
                        {
                          "$ref": "#/components/schemas/jsonwrap2_sts_raw"
                        }
                      ]
                    }
                  }
                }
              },
              "labels": {
                "type": "array",
                "items": {
                  "type": "object",
                  "description": "An object describing a label key. `ds` stands for `dimensions`, `sts` for statistics.\n",
                  "properties": {
                    "id": {
                      "description": "the key of the label.",
                      "type": "string"
                    },
                    "ds": {
                      "$ref": "#/components/schemas/jsonwrap2_items_count"
                    },
                    "sts": {
                      "oneOf": [
                        {
                          "$ref": "#/components/schemas/jsonwrap2_sts"
                        },
                        {
                          "$ref": "#/components/schemas/jsonwrap2_sts_raw"
                        }
                      ]
                    },
                    "vl": {
                      "description": "An array of values for this key.\n",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "description": "The value string",
                            "type": "string"
                          },
                          "ds": {
                            "$ref": "#/components/schemas/jsonwrap2_items_count"
                          },
                          "sts": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/jsonwrap2_sts"
                              },
                              {
                                "$ref": "#/components/schemas/jsonwrap2_sts_raw"
                              }
                            ]
                          }
                        }
                      }
                    }
                  }
                }
              },
              "alerts": {
                "description": "An array of all the unique alerts running, grouped by alert name (`nm` is available here)\n",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/jsonwrap2_alerts_count"
                }
              }
            }
          },
          "totals": {
            "type": "object",
            "properties": {
              "nodes": {
                "$ref": "#/components/schemas/jsonwrap2_items_count"
              },
              "contexts": {
                "$ref": "#/components/schemas/jsonwrap2_items_count"
              },
              "instances": {
                "$ref": "#/components/schemas/jsonwrap2_items_count"
              },
              "dimensions": {
                "$ref": "#/components/schemas/jsonwrap2_items_count"
              },
              "label_keys": {
                "$ref": "#/components/schemas/jsonwrap2_items_count"
              },
              "label_key_values": {
                "$ref": "#/components/schemas/jsonwrap2_items_count"
              }
            }
          },
          "functions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "db": {
            "type": "object",
            "properties": {
              "tiers": {
                "description": "The number of tiers this server is using.\n",
                "type": "integer"
              },
              "update_every": {
                "description": "The minimum update every, in seconds, for all tiers and all metrics aggregated into this query.\n",
                "type": "integer"
              },
              "first_entry": {
                "description": "The minimum unix epoch timestamp of the retention across all tiers for all metrics aggregated into this query.\n",
                "type": "integer"
              },
              "last_entry": {
                "description": "The maximum unix epoch timestamp of the retention across all tier for all metrics aggregated into this query.\n",
                "type": "integer"
              },
              "per_tier": {
                "description": "An array with information for each of the tiers available, related to this query.\n",
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "tier": {
                      "description": "The tier number of this tier, starting at 0.\n",
                      "type": "integer"
                    },
                    "queries": {
                      "description": "The number of queries executed on this tier. Usually one query per metric is made, but the query may cross multiple tier, in which case more than one query per metric is made.\n",
                      "type": "integer"
                    },
                    "points": {
                      "description": "The number of points read from this tier.\n",
                      "type": "integer"
                    },
                    "update_every": {
                      "description": "The minimum resolution of all metrics queried on this tier.\n",
                      "type": "integer"
                    },
                    "first_entry": {
                      "description": "The minimum unix epoch timestamp available across all metrics that used this tier. This reflects the oldest timestamp of the tier's retention.\n",
                      "type": "integer"
                    },
                    "last_entry": {
                      "description": "The maximum unix epoch timestamp available across all metrics that used this tier. This reflects the newest timestamp of the tier's retention.\n"
                    }
                  }
                }
              },
              "units": {
                "description": "The units of the database data\n",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "dimensions": {
                "type": "object",
                "properties": {
                  "ids": {
                    "description": "An array with the dimension ids that uniquely identify the dimensions for this query. It is the same with `view.dimensions.ids`.\n",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "units": {
                    "description": "An array with the units each dimension has in the database (independent of group-by aggregation that may override the units).\n",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "sts": {
                    "description": "Statistics about the data collection points used for each dimension.\n",
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/jsonwrap2_sts"
                      },
                      {
                        "$ref": "#/components/schemas/jsonwrap2_sts_raw"
                      }
                    ]
                  }
                }
              }
            }
          },
          "view": {
            "type": "object",
            "properties": {
              "title": {
                "description": "The title the chart should have.\n",
                "type": "string"
              },
              "format": {
                "description": "The format the `result` top level member has. Available on when `debug` flag is set.\n",
                "type": "string"
              },
              "options": {
                "description": "An array presenting all the options given to the query. Available on when `debug` flag is set.\n",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "time_group": {
                "description": "The same as the parameter `time_group`. Available on when `debug` flag is set.\n",
                "type": "string"
              },
              "after": {
                "description": "The oldest unix epoch timestamp of the data returned in the `result`.\n",
                "type": "integer"
              },
              "before": {
                "description": "The newest unix epoch timestamp of the data returned in the `result`.\n",
                "type": "integer"
              },
              "partial_data_trimming": {
                "description": "Information related to trimming of the last few points of the `result`, that was required to remove (increasing) partial data.\nTrimming is disabled when the `raw` option is given to the query.\nThis object is available only when the `debug` flag is set.\n",
                "type": "object",
                "properties": {
                  "max_update_every": {
                    "description": "The maximum `update_every` for all metrics aggregated into the query.\nTrimming is by default enabled at `view.before - max_update_every`, but only when `view.before >= now - max_update_every`.\n",
                    "type": "integer"
                  },
                  "expected_after": {
                    "description": "The timestamp at which trimming can be enabled.\nIf this timestamp is greater or equal to `view.before`, there is no trimming.\n",
                    "type": "integer"
                  },
                  "trimmed_after": {
                    "description": "The timestamp at which trimming has been applied.\nIf this timestamp is greater or equal to `view.before`, there is no trimming.\n"
                  }
                }
              },
              "points": {
                "description": "The number of points in `result`. Available only when `raw` is given.\n",
                "type": "integer"
              },
              "units": {
                "description": "The units of the query.\n",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "chart_type": {
                "description": "The default chart type of the query.\n",
                "type": "string",
                "enum": [
                  "line",
                  "area",
                  "stacked"
                ]
              },
              "dimensions": {
                "description": "Detailed information about the chart dimensions included in the `result`.\n",
                "type": "object",
                "properties": {
                  "grouped_by": {
                    "description": "An array with the order of the groupings performed.\n",
                    "type": "array",
                    "items": {
                      "type": "string",
                      "enum": [
                        "selected",
                        "dimension",
                        "instance",
                        "node",
                        "context",
                        "units",
                        "label:key1",
                        "label:key2",
                        "label:keyN"
                      ]
                    }
                  },
                  "ids": {
                    "description": "An array with the dimension ids that uniquely identify the dimensions for this query.\n",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "names": {
                    "description": "An array with the dimension names to be presented to users. Names may be overlapping, but IDs are not.\n",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "priorities": {
                    "description": "An array with the relative priorities of the dimensions.\nNumbers may not be sequential or unique. The application is expected to order by this and then by name.\n",
                    "type": "array",
                    "items": {
                      "type": "integer"
                    }
                  },
                  "aggregated": {
                    "description": "An array with the number of source metrics aggregated into each dimension.\n",
                    "type": "array",
                    "items": {
                      "type": "integer"
                    }
                  },
                  "units": {
                    "description": "An array with the units each dimension has.\n",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "sts": {
                    "description": "Statistics about the view points for each dimension.\n",
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/jsonwrap2_sts"
                      },
                      {
                        "$ref": "#/components/schemas/jsonwrap2_sts_raw"
                      }
                    ]
                  },
                  "labels": {
                    "description": "The labels associated with each dimension in the query.\nThis object is only available when the `group-by-labels` option is given to the query.\n",
                    "type": "object",
                    "properties": {
                      "label_key1": {
                        "description": "An array having one entry for each of the dimensions of the query.\n",
                        "type": "array",
                        "items": {
                          "description": "An array having one entry for each of the values this label key has for the given dimension.\n",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              },
              "min": {
                "description": "The minimum value of all points included in the `result`.\n",
                "type": "number"
              },
              "max": {
                "description": "The maximum value of all points included in the `result`.\n",
                "type": "number"
              }
            }
          },
          "result": {
            "$ref": "#/components/schemas/data_json_formats2"
          },
          "timings": {
            "type": "object"
          }
        }
      },
      "jsonwrap2_sts": {
        "description": "Statistical values\n",
        "type": "object",
        "properties": {
          "min": {
            "description": "The minimum value of all metrics aggregated",
            "type": "number"
          },
          "max": {
            "description": "The maximum value of all metrics aggregated",
            "type": "number"
          },
          "avg": {
            "description": "The average value of all metrics aggregated",
            "type": "number"
          },
          "arp": {
            "description": "The average anomaly rate of all metrics aggregated",
            "type": "number"
          },
          "con": {
            "description": "The contribution percentage of all the metrics aggregated",
            "type": "number"
          }
        }
      },
      "jsonwrap2_sts_raw": {
        "description": "Statistical values when `raw` option is given.\n",
        "type": "object",
        "properties": {
          "min": {
            "description": "The minimum value of all metrics aggregated",
            "type": "number"
          },
          "max": {
            "description": "The maximum value of all metrics aggregated",
            "type": "number"
          },
          "sum": {
            "description": "The sum value of all metrics aggregated",
            "type": "number"
          },
          "ars": {
            "description": "The sum anomaly rate of all metrics aggregated",
            "type": "number"
          },
          "vol": {
            "description": "The volume of all the metrics aggregated",
            "type": "number"
          },
          "cnt": {
            "description": "The count of all metrics aggregated",
            "type": "integer"
          }
        }
      },
      "jsonwrap2_items_count": {
        "description": "Depending on the placement of this object, `items` may be `nodes`, `contexts`, `instances`, `dimensions`, `label keys`, `label key-value pairs`. Furthermore, if the whole object is missing it should be assumed that all its members are zero.\n",
        "type": "object",
        "properties": {
          "sl": {
            "description": "The number of items `selected` to query. If absent it is zero.",
            "type": "integer"
          },
          "ex": {
            "description": "The number of items `excluded` from querying. If absent it is zero.",
            "type": "integer"
          },
          "qr": {
            "description": "The number of items (out of `selected`) the query successfully `queried`.  If absent it is zero.",
            "type": "integer"
          },
          "fl": {
            "description": "The number of items (from `selected`) that `failed` to be queried.  If absent it is zero.",
            "type": "integer"
          }
        }
      },
      "jsonwrap2_alerts_count": {
        "description": "Counters about alert statuses. If this object is missing, it is assumed that all its members are zero.\n",
        "type": "object",
        "properties": {
          "nm": {
            "description": "The name of the alert. Can be absent when the counters refer to more than one alert instances.",
            "type": "string"
          },
          "cl": {
            "description": "The number of CLEAR alerts. If absent, it is zero.",
            "type": "integer"
          },
          "wr": {
            "description": "The number of WARNING alerts. If absent, it is zero.",
            "type": "integer"
          },
          "cr": {
            "description": "The number of CRITICAL alerts. If absent, it is zero.",
            "type": "integer"
          },
          "ot": {
            "description": "The number of alerts that are not CLEAR, WARNING, CRITICAL (so, they are \"other\").  If absent, it is zero.\n",
            "type": "integer"
          }
        }
      },
      "api": {
        "description": "The version of the API used.",
        "type": "integer"
      },
      "agents": {
        "description": "An array of Agent definitions consulted to compose this response.\n",
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "mg": {
              "description": "The Agent machine GUID.",
              "type": "string",
              "format": "uuid"
            },
            "nd": {
              "description": "The Agent cloud node ID.",
              "type": "string",
              "format": "uuid"
            },
            "nm": {
              "description": "The Agent hostname.",
              "type": "string"
            },
            "ai": {
              "description": "The Agent index ID for this Agent, in this response.",
              "type": "integer"
            },
            "now": {
              "description": "The current unix epoch timestamp of this Agent.",
              "type": "integer"
            }
          }
        }
      },
      "versions": {
        "description": "Hashes that allow the caller to detect important database changes of Netdata Agents.\n",
        "type": "object",
        "properties": {
          "nodes_hard_hash": {
            "description": "An auto-increment value that reflects the number of changes to the number of nodes maintained by the server. Everytime a node is added or removed, this number gets incremented.\n",
            "type": "integer"
          },
          "contexts_hard_hash": {
            "description": "An auto-increment value that reflects the number of changes to the number of contexts maintained by the server. Everytime a context is added or removed, this number gets incremented.\n",
            "type": "integer"
          },
          "contexts_soft_hash": {
            "description": "An auto-increment value that reflects the number of changes to the queue that sends contexts updates to Netdata Cloud. Everytime the contents of a context are updated, this number gets incremented.\n",
            "type": "integer"
          },
          "alerts_hard_hash": {
            "description": "An auto-increment value that reflects the number of changes to the number of alerts. Everytime an alert is added or removed, this number gets incremented.\n",
            "type": "integer"
          },
          "alerts_soft_hash": {
            "description": "An auto-increment value that reflects the number of alerts transitions. Everytime an alert transitions to a new state, this number gets incremented.\n",
            "type": "integer"
          }
        }
      },
      "nodeBasic": {
        "type": "object",
        "description": "Basic information about a node.",
        "required": [
          "ni",
          "st"
        ],
        "properties": {
          "mg": {
            "description": "The machine guid of the node. May not be available if the request is served by the Netdata Cloud.",
            "type": "string",
            "format": "UUID"
          },
          "nd": {
            "description": "The node id of the node. May not be available if the node is not registered to Netdata Cloud.",
            "type": "string",
            "format": "UUID"
          },
          "nm": {
            "description": "The name (hostname) of the node.",
            "type": "string"
          },
          "ni": {
            "description": "The node index id, a number that uniquely identifies this node for this query.",
            "type": "integer"
          },
          "st": {
            "description": "Status information about the communication with this node.",
            "type": "object",
            "properties": {
              "ai": {
                "description": "The Agent index id that has been contacted for this node.",
                "type": "integer"
              },
              "code": {
                "description": "The HTTP response code of the response for this node. When working directly with an Agent, this is always 200. If the `code` is missing, it should be assumed to be 200.",
                "type": "integer"
              },
              "msg": {
                "description": "A human readable description of the error, if any. If `msg` is missing, or is the empty string `\"\"` or is `null`, there is no description associated with the current status.",
                "type": "string"
              },
              "ms": {
                "description": "The time in milliseconds this node took to respond, or if the local Agent responded for this node, the time it needed to execute the query. If `ms` is missing, the time that was required to query this node is unknown.",
                "type": "number"
              }
            }
          }
        }
      },
      "nodeWithDataStatistics": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodeBasic"
          },
          {
            "type": "object",
            "description": "`is` stands for instances, `ds` for dimensions, `al` for alerts, `sts` for statistics.\n",
            "properties": {
              "is": {
                "$ref": "#/components/schemas/jsonwrap2_items_count"
              },
              "ds": {
                "$ref": "#/components/schemas/jsonwrap2_items_count"
              },
              "al": {
                "$ref": "#/components/schemas/jsonwrap2_alerts_count"
              },
              "sts": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/jsonwrap2_sts"
                  },
                  {
                    "$ref": "#/components/schemas/jsonwrap2_sts_raw"
                  }
                ]
              }
            }
          }
        ]
      },
      "nodeFull": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodeBasic"
          },
          {
            "type": "object",
            "properties": {
              "version": {
                "description": "The version of the Netdata Agent the node runs.",
                "type": "string"
              },
              "hops": {
                "description": "How many hops away from the origin node, the queried one is. 0 means the Agent itself is the origin node.",
                "type": "integer"
              },
              "state": {
                "description": "The current state of the node on this Agent.",
                "type": "string",
                "enum": [
                  "reachable",
                  "stale",
                  "offline"
                ]
              }
            }
          }
        ]
      },
      "context2Basic": {
        "type": "object",
        "properties": {
          "family": {
            "type": "string"
          },
          "priority": {
            "type": "integer"
          },
          "first_entry": {
            "type": "integer"
          },
          "last_entry": {
            "type": "integer"
          },
          "live": {
            "type": "boolean"
          }
        }
      },
      "contexts2": {
        "description": "`/api/v2/contexts` and `/api/v2/q` response about multi-node contexts hosted by a Netdata Agent.\n",
        "type": "object",
        "properties": {
          "api": {
            "$ref": "#/components/schemas/api"
          },
          "agents": {
            "$ref": "#/components/schemas/agents"
          },
          "versions": {
            "$ref": "#/components/schemas/versions"
          },
          "contexts": {
            "additionalProperties": {
              "$ref": "#/components/schemas/context2Basic"
            }
          }
        }
      },
      "jsonwrap1": {
        "type": "object",
        "discriminator": {
          "propertyName": "format"
        },
        "description": "Response will contain the appropriate subtype, e.g. data_json depending on the requested format.",
        "properties": {
          "api": {
            "type": "number",
            "description": "The API version this conforms to."
          },
          "id": {
            "type": "string",
            "description": "The unique id of the chart."
          },
          "name": {
            "type": "string",
            "description": "The name of the chart."
          },
          "update_every": {
            "type": "number",
            "description": "The update frequency of this chart, in seconds. One value every this amount of time is kept in the round robin database (independently of the current view)."
          },
          "view_update_every": {
            "type": "number",
            "description": "The current view appropriate update frequency of this chart, in seconds. There is no point to request chart refreshes, using the same settings, more frequently than this."
          },
          "first_entry": {
            "type": "number",
            "description": "The UNIX timestamp of the first entry (the oldest) in the round robin database (independently of the current view)."
          },
          "last_entry": {
            "type": "number",
            "description": "The UNIX timestamp of the latest entry in the round robin database (independently of the current view)."
          },
          "after": {
            "type": "number",
            "description": "The UNIX timestamp of the first entry (the oldest) returned in this response."
          },
          "before": {
            "type": "number",
            "description": "The UNIX timestamp of the latest entry returned in this response."
          },
          "min": {
            "type": "number",
            "description": "The minimum value returned in the current view. This can be used to size the y-series of the chart."
          },
          "max": {
            "type": "number",
            "description": "The maximum value returned in the current view. This can be used to size the y-series of the chart."
          },
          "dimension_names": {
            "description": "The dimension names of the chart as returned in the current view.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "dimension_ids": {
            "description": "The dimension IDs of the chart as returned in the current view.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "latest_values": {
            "description": "The latest values collected for the chart (independently of the current view).",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "view_latest_values": {
            "description": "The latest values returned with this response.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "dimensions": {
            "type": "number",
            "description": "The number of dimensions returned."
          },
          "points": {
            "type": "number",
            "description": "The number of rows / points returned."
          },
          "format": {
            "type": "string",
            "description": "The format of the result returned."
          },
          "chart_variables": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/chart_variables"
            }
          },
          "result": {
            "$ref": "#/components/schemas/data_json_formats1"
          }
        }
      },
      "data_json_formats1": {
        "description": "Depending on the `format` given to a data query, any of the following may be returned.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/data_json"
          },
          {
            "$ref": "#/components/schemas/data_datatable"
          },
          {
            "$ref": "#/components/schemas/data_csvjsonarray"
          },
          {
            "$ref": "#/components/schemas/data_array"
          },
          {
            "$ref": "#/components/schemas/data_txt"
          }
        ]
      },
      "data_json_formats2": {
        "description": "Depending on the `format` given to a data query, any of the following may be returned.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/data_json2"
          },
          {
            "$ref": "#/components/schemas/data_json_formats1"
          }
        ]
      },
      "data_json2": {
        "type": "object",
        "properties": {
          "labels": {
            "description": "The IDs of the dimensions returned. The first is always `time`.\n",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "point": {
            "description": "The format of each point returned.\n",
            "type": "object",
            "properties": {
              "value": {
                "description": "The index of the value in each point.\n",
                "type": "integer"
              },
              "arp": {
                "description": "The index of the anomaly rate in each point.\n",
                "type": "integer"
              },
              "pa": {
                "description": "The index of the point annotations in each point.\nThis is a bitmap. `EMPTY = 1`, `RESET = 2`, `PARTIAL = 4`.\n`EMPTY` means the point has no value.\n`RESET` means that at least one metric aggregated experienced an overflow (a counter that wrapped).\n`PARTIAL` means that this point should have more metrics aggregated into it, but not all metrics had data.\n",
                "type": "integer"
              },
              "count": {
                "description": "The number of metrics aggregated into this point.\nThis exists only when the option `raw` is given to the query and the final aggregation point is NOT `percentage`.\n",
                "type": "integer"
              },
              "hidden": {
                "description": "The sum of the non-selected dimensions aggregated for this group item point.\nThis exists only when the option `raw` is given to the query and the final aggregation method is `percentage`.\n"
              }
            }
          },
          "data": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              ]
            }
          }
        }
      },
      "data_json": {
        "description": "Data response in `json` format.",
        "type": "object",
        "properties": {
          "labels": {
            "description": "The dimensions retrieved from the chart.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "data": {
            "description": "The data requested, one element per sample with each element containing the values of the dimensions described in the labels value.\n",
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        }
      },
      "data_txt": {
        "description": "Data response in `csv`, `tsv`, `tsv-excel`, `ssv`, `ssv-comma`, `markdown`, `html` formats.\n",
        "type": "string"
      },
      "data_array": {
        "description": "Data response in `array` format.",
        "type": "array",
        "items": {
          "type": "number"
        }
      },
      "data_csvjsonarray": {
        "description": "The first inner array contains strings showing the labels of each column, each subsequent array contains the values for each point in time.\n",
        "type": "array",
        "items": {
          "type": "array",
          "items": {}
        }
      },
      "data_datatable": {
        "description": "Data response in datatable / datasource formats (suitable for Google Charts).\n",
        "type": "object",
        "properties": {
          "cols": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "description": "Always empty - for future use."
                },
                "label": {
                  "description": "The dimension returned from the chart."
                },
                "pattern": {
                  "description": "Always empty - for future use."
                },
                "type": {
                  "description": "The type of data in the column / chart-dimension."
                },
                "p": {
                  "description": "Contains any annotations for the column."
                }
              },
              "required": [
                "id",
                "label",
                "pattern",
                "type"
              ]
            }
          },
          "rows": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "c": {
                  "type": "array",
                  "items": {
                    "properties": {
                      "v": {
                        "description": "Each value in the row is represented by an object named `c` with five v fields: data, null, null, 0, the value. This format is fixed by the Google Charts API.\"\n"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "alarms": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string"
          },
          "latest_alarm_log_unique_id": {
            "type": "integer",
            "format": "int32"
          },
          "status": {
            "type": "boolean"
          },
          "now": {
            "type": "integer",
            "format": "int32"
          },
          "alarms": {
            "type": "object",
            "properties": {
              "chart-name.alarm-name": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "name": {
                    "type": "string",
                    "description": "Full alarm name."
                  },
                  "chart": {
                    "type": "string"
                  },
                  "family": {
                    "type": "string"
                  },
                  "active": {
                    "type": "boolean",
                    "description": "Will be false only if the alarm is disabled in the configuration."
                  },
                  "disabled": {
                    "type": "boolean",
                    "description": "Whether the health check for this alarm has been disabled via a health command API DISABLE command."
                  },
                  "silenced": {
                    "type": "boolean",
                    "description": "Whether notifications for this alarm have been silenced via a health command API SILENCE command."
                  },
                  "exec": {
                    "type": "string"
                  },
                  "recipient": {
                    "type": "string"
                  },
                  "source": {
                    "type": "string"
                  },
                  "units": {
                    "type": "string"
                  },
                  "info": {
                    "type": "string"
                  },
                  "status": {
                    "type": "string"
                  },
                  "last_status_change": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "last_updated": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "next_update": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "update_every": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "delay_up_duration": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "delay_down_duration": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "delay_max_duration": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "delay_multiplier": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "delay": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "delay_up_to_timestamp": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "value_string": {
                    "type": "string"
                  },
                  "no_clear_notification": {
                    "type": "boolean"
                  },
                  "lookup_dimensions": {
                    "type": "string"
                  },
                  "db_after": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "db_before": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "lookup_method": {
                    "type": "string"
                  },
                  "lookup_after": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "lookup_before": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "lookup_options": {
                    "type": "string"
                  },
                  "calc": {
                    "type": "string"
                  },
                  "calc_parsed": {
                    "type": "string"
                  },
                  "warn": {
                    "type": "string"
                  },
                  "warn_parsed": {
                    "type": "string"
                  },
                  "crit": {
                    "type": "string"
                  },
                  "crit_parsed": {
                    "type": "string"
                  },
                  "warn_repeat_every": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "crit_repeat_every": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "green": {
                    "type": "string",
                    "format": "nullable"
                  },
                  "red": {
                    "type": "string",
                    "format": "nullable"
                  },
                  "value": {
                    "type": "number"
                  }
                }
              }
            }
          }
        }
      },
      "alarm_log_entry": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string"
          },
          "unique_id": {
            "type": "integer",
            "format": "int32"
          },
          "alarm_id": {
            "type": "integer",
            "format": "int32"
          },
          "alarm_event_id": {
            "type": "integer",
            "format": "int32"
          },
          "name": {
            "type": "string"
          },
          "chart": {
            "type": "string"
          },
          "family": {
            "type": "string"
          },
          "processed": {
            "type": "boolean"
          },
          "updated": {
            "type": "boolean"
          },
          "exec_run": {
            "type": "integer",
            "format": "int32"
          },
          "exec_failed": {
            "type": "boolean"
          },
          "exec": {
            "type": "string"
          },
          "recipient": {
            "type": "string"
          },
          "exec_code": {
            "type": "integer",
            "format": "int32"
          },
          "source": {
            "type": "string"
          },
          "units": {
            "type": "string"
          },
          "when": {
            "type": "integer",
            "format": "int32"
          },
          "duration": {
            "type": "integer",
            "format": "int32"
          },
          "non_clear_duration": {
            "type": "integer",
            "format": "int32"
          },
          "status": {
            "type": "string"
          },
          "old_status": {
            "type": "string"
          },
          "delay": {
            "type": "integer",
            "format": "int32"
          },
          "delay_up_to_timestamp": {
            "type": "integer",
            "format": "int32"
          },
          "updated_by_id": {
            "type": "integer",
            "format": "int32"
          },
          "updates_id": {
            "type": "integer",
            "format": "int32"
          },
          "value_string": {
            "type": "string"
          },
          "old_value_string": {
            "type": "string"
          },
          "silenced": {
            "type": "string"
          },
          "info": {
            "type": "string"
          },
          "value": {
            "type": "number",
            "nullable": true
          },
          "old_value": {
            "type": "number",
            "nullable": true
          }
        }
      },
      "alarms_values": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string"
          },
          "alarms": {
            "type": "object",
            "description": "HashMap with keys being alarm names",
            "additionalProperties": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "integer"
                },
                "value": {
                  "type": "integer"
                },
                "last_updated": {
                  "type": "integer",
                  "format": "int32"
                },
                "status": {
                  "type": "string",
                  "enum": [
                    "REMOVED",
                    "UNDEFINED",
                    "UNINITIALIZED",
                    "CLEAR",
                    "RAISED",
                    "WARNING",
                    "CRITICAL",
                    "UNKNOWN"
                  ]
                }
              }
            }
          }
        }
      },
      "aclk_state": {
        "type": "object",
        "properties": {
          "aclk-available": {
            "type": "string",
            "description": "Describes whether this Agent is capable of connection to the Cloud. False means Agent has been built without ACLK component either on purpose (user choice) or due to missing dependency.\n"
          },
          "aclk-version": {
            "type": "integer",
            "description": "Describes which ACLK version is currently used."
          },
          "protocols-supported": {
            "type": "array",
            "description": "List of supported protocols for communication with Cloud.",
            "items": {
              "type": "string"
            }
          },
          "Agent-claimed": {
            "type": "boolean",
            "description": "Informs whether this Agent has been added to a space in the cloud (User has to perform claiming). If false (user didn't perform claiming) Agent will never attempt any cloud connection."
          },
          "claimed_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique ID this Agent uses to identify when connecting to cloud"
          },
          "online": {
            "type": "boolean",
            "description": "Informs if this Agent was connected to the cloud at the time this request has been processed."
          },
          "used-cloud-protocol": {
            "type": "string",
            "description": "Informs which protocol is used to communicate with cloud",
            "enum": [
              "Old",
              "New"
            ]
          }
        }
      },
      "metric_correlations": {
        "type": "object",
        "properties": {
          "after": {
            "description": "the start time of the highlighted window",
            "type": "integer"
          },
          "before": {
            "description": "the end time of the highlighted window",
            "type": "integer"
          },
          "duration": {
            "description": "the duration of the highlighted window",
            "type": "integer"
          },
          "points": {
            "description": "the points of the highlighted window",
            "type": "integer"
          },
          "baseline_after": {
            "description": "the start time of the baseline window",
            "type": "integer"
          },
          "baseline_before": {
            "description": "the end time of the baseline window",
            "type": "integer"
          },
          "baseline_duration": {
            "description": "the duration of the baseline window",
            "type": "integer"
          },
          "baseline_points": {
            "description": "the points of the baseline window",
            "type": "integer"
          },
          "group": {
            "description": "the grouping method across time",
            "type": "string"
          },
          "method": {
            "description": "the correlation method used",
            "type": "string"
          },
          "options": {
            "description": "a comma separated list of the query options set",
            "type": "string"
          },
          "correlated_dimensions": {
            "description": "the number of dimensions returned in the result"
          },
          "total_dimensions_count": {
            "description": "the total number of dimensions evaluated",
            "type": "integer"
          },
          "statistics": {
            "type": "object",
            "properties": {
              "query_time_ms": {
                "type": "number"
              },
              "db_queries": {
                "type": "integer"
              },
              "db_points_read": {
                "type": "integer"
              },
              "query_result_points": {
                "type": "integer"
              },
              "binary_searches": {
                "type": "integer"
              }
            }
          },
          "correlated_charts": {
            "type": "object",
            "description": "An object containing chart objects with their metrics correlations.",
            "properties": {
              "chart-id1": {
                "type": "object",
                "properties": {
                  "context": {
                    "type": "string"
                  },
                  "dimensions": {
                    "type": "object",
                    "properties": {
                      "dimension1-name": {
                        "type": "number"
                      },
                      "dimension2-name": {
                        "type": "number"
                      }
                    }
                  }
                }
              },
              "chart-id2": {
                "type": "object",
                "properties": {
                  "context": {
                    "type": "string"
                  },
                  "dimensions": {
                    "type": "object",
                    "properties": {
                      "dimension1-name": {
                        "type": "number"
                      },
                      "dimension2-name": {
                        "type": "number"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "weights2": {
        "type": "object"
      },
      "weights": {
        "type": "object",
        "properties": {
          "after": {
            "description": "the start time of the highlighted window",
            "type": "integer"
          },
          "before": {
            "description": "the end time of the highlighted window",
            "type": "integer"
          },
          "duration": {
            "description": "the duration of the highlighted window",
            "type": "integer"
          },
          "points": {
            "description": "the points of the highlighted window",
            "type": "integer"
          },
          "baseline_after": {
            "description": "the start time of the baseline window",
            "type": "integer"
          },
          "baseline_before": {
            "description": "the end time of the baseline window",
            "type": "integer"
          },
          "baseline_duration": {
            "description": "the duration of the baseline window",
            "type": "integer"
          },
          "baseline_points": {
            "description": "the points of the baseline window",
            "type": "integer"
          },
          "group": {
            "description": "the grouping method across time",
            "type": "string"
          },
          "method": {
            "description": "the correlation method used",
            "type": "string"
          },
          "options": {
            "description": "a comma separated list of the query options set",
            "type": "string"
          },
          "correlated_dimensions": {
            "description": "the number of dimensions returned in the result"
          },
          "total_dimensions_count": {
            "description": "the total number of dimensions evaluated",
            "type": "integer"
          },
          "statistics": {
            "type": "object",
            "properties": {
              "query_time_ms": {
                "type": "number"
              },
              "db_queries": {
                "type": "integer"
              },
              "db_points_read": {
                "type": "integer"
              },
              "query_result_points": {
                "type": "integer"
              },
              "binary_searches": {
                "type": "integer"
              }
            }
          },
          "contexts": {
            "description": "A dictionary of weighted context objects.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/weighted_context"
            }
          }
        }
      },
      "weighted_context": {
        "type": "object",
        "properties": {
          "weight": {
            "description": "The average weight of the context.",
            "type": "number"
          },
          "charts": {
            "description": "A dictionary of weighted chart objects.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/weighted_chart"
            }
          }
        }
      },
      "weighted_chart": {
        "type": "object",
        "properties": {
          "weight": {
            "description": "The average weight of the context.",
            "type": "number"
          },
          "dimensions": {
            "description": "A dictionary of weighted dimensions.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/weighted_dimension"
            }
          }
        }
      },
      "weighted_dimension": {
        "type": "number"
      },
      "config_schema": {
        "type": "object",
        "properties": {
          "jsonSchema": {
            "type": "object",
            "description": "Standard JSON Schema object describing the schema of each configurable entity."
          },
          "uiSchema": {
            "type": "object",
            "description": "Schema for react-json-schema-form to drive the UI. Provides additional UI-specific configuration."
          }
        }
      },
      "config_tree": {
        "type": "object",
        "properties": {
          "version": {
            "type": "integer",
            "description": "The version of dynamic configuration supported by the Netdata Agent."
          },
          "tree": {
            "type": "object",
            "description": "A map of configuration entity paths, each containing one or more configurable entities.",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/config_entity"
              }
            }
          },
          "attention": {
            "$ref": "#/components/schemas/config_attention"
          }
        }
      },
      "config_entity": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "Can be 'single' for entities appearing once, 'template' for entities supporting multiple instances, or 'job' for jobs belonging to a template."
          },
          "status": {
            "type": "string",
            "description": "The current status of the entity. Values include 'accepted', 'running', 'failed', 'disabled', 'incomplete', or 'orphan'."
          },
          "cmds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "An array of the possible actions supported by this entity."
          },
          "source_type": {
            "type": "string",
            "description": "The source type of the configuration (e.g., 'internal', 'stock', 'user', 'discovered', 'dyncfg')."
          },
          "source": {
            "type": "string",
            "description": "Additional information about the source, formatted as comma-separated name-value pairs."
          },
          "sync": {
            "type": "boolean",
            "description": "Indicates if this is an internal module (true) or an external plugin (false)."
          },
          "user_disabled": {
            "type": "boolean",
            "description": "True if the entity is disabled by the user."
          },
          "restart_required": {
            "type": "boolean",
            "description": "True if the entity requires a restart after addition or update."
          },
          "plugin_rejected": {
            "type": "boolean",
            "description": "True if a previously saved configuration failed to apply after a restart."
          },
          "payload": {
            "type": "object",
            "description": "Object containing at least an 'available' boolean indicating if there's a saved configuration for this entity.",
            "properties": {
              "available": {
                "type": "boolean"
              }
            }
          },
          "saves": {
            "type": "integer",
            "description": "The number of times this configuration has been saved to disk by the dynamic configuration manager."
          },
          "created_ut": {
            "type": "integer",
            "format": "int64",
            "description": "The timestamp in microseconds when this dynamic configuration was first created."
          },
          "modified_ut": {
            "type": "integer",
            "format": "int64",
            "description": "The timestamp in microseconds when this dynamic configuration was last modified."
          },
          "template": {
            "type": "string",
            "description": "Shows the template the job belongs to, applicable when type is 'job'."
          }
        }
      },
      "config_attention": {
        "type": "object",
        "properties": {
          "degraded": {
            "type": "boolean"
          },
          "restart_required": {
            "type": "integer"
          },
          "plugin_rejected": {
            "type": "integer"
          },
          "status_failed": {
            "type": "integer"
          },
          "status_incomplete": {
            "type": "integer"
          }
        }
      },
      "config_default_response": {
        "type": "object",
        "properties": {
          "status": {
            "type": "integer",
            "description": "The HTTP status code of the response."
          },
          "message": {
            "type": "string",
            "description": "A descriptive message about the response or the action taken."
          },
          "data": {
            "type": "object",
            "description": "The data payload of the response, contents vary depending on the specific request and action.",
            "additionalProperties": true
          }
        }
      }
    }
  }
}
