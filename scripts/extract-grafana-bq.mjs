#!/usr/bin/env node
/**
 * Extract BigQuery queries from a Grafana dashboard JSON and emit markdown.
 * Optionally updates bigquery.ai by replacing content between autogenerated markers.
 *
 * Usage:
 *   node scripts/extract-grafana-bq.mjs /path/to/dashboard.json [--out docs/grafana-bq-queries.md] [--update-bigquery-ai]
 */

import fs from 'node:fs/promises';
import path from 'node:path';

const MARKER_BEGIN = '<!-- BEGIN: GRAFANA-BQ-QUERIES (auto-generated) -->';
const MARKER_END = '<!-- END: GRAFANA-BQ-QUERIES -->';

function isObject(v) {
  return v !== null && typeof v === 'object' && !Array.isArray(v);
}

function uniq(arr) {
  return Array.from(new Set(arr));
}

function extractBacktickedTables(sql) {
  if (!sql) return [];
  const re = /`([\w-]+\.[\w-]+\.[\w-]+)`/g; // project.dataset.table
  const results = [];
  let m;
  // eslint-disable-next-line no-cond-assign
  while ((m = re.exec(sql)) !== null) {
    results.push(m[1]);
  }
  return uniq(results);
}

function summarizeQuery(sql) {
  if (!sql) return 'Interpretation: UNKNOWN';
  // Try to identify selected columns (first SELECT ... FROM)
  const selectMatch = /select\s+([\s\S]*?)\s+from\s+/i.exec(sql);
  const cols = selectMatch ? selectMatch[1].replace(/\s+/g, ' ').slice(0, 120) : null;
  const tables = extractBacktickedTables(sql);
  const tableList = tables.length > 0 ? tables.join(', ') : 'UNKNOWN SOURCES';
  if (cols) {
    return `Computes ${cols} from ${tableList}.`;
  }
  return `Aggregates data from ${tableList}.`;
}

function* walk(obj) {
  if (Array.isArray(obj)) {
    for (const v of obj) yield* walk(v);
  } else if (isObject(obj)) {
    yield obj;
    for (const v of Object.values(obj)) yield* walk(v);
  }
}

async function main() {
  const args = process.argv.slice(2);
  if (args.length === 0) {
    console.error('Usage: extract-grafana-bq.mjs <dashboard.json> [--out <file>] [--update-bigquery-ai]');
    process.exit(2);
  }
  const inPath = args[0];
  const outIdx = args.indexOf('--out');
  const outPath = outIdx !== -1 ? args[outIdx + 1] : 'docs/grafana-bq-queries.md';
  const updateBigQueryAi = args.includes('--update-bigquery-ai');

  const raw = await fs.readFile(inPath, 'utf8');
  let json;
  try {
    json = JSON.parse(raw);
  } catch (err) {
    console.error(`Failed to parse JSON from ${inPath}:`, err.message);
    process.exit(1);
  }

  const entries = [];
  for (const node of walk(json)) {
    if (!node || !Array.isArray(node.targets)) continue;
    const ds = node.datasource || node.dataSource || {};
    const dsType = ds.type || '';
    // Only consider Grafana BigQuery panels
    if (!/bigquery/i.test(dsType)) continue;

    const panelTitle = node.title || ''; 
    const panelDesc = node.description || '';
    const panelType = node.type || '';
    const panelId = typeof node.id === 'number' ? node.id : undefined;
    const datasourceUid = ds.uid || ds.uidRef || '';

    for (const t of node.targets) {
      if (!t || typeof t !== 'object') continue;
      const rawSql = t.rawSql || t.query || (t.formattedQuery && t.formattedQuery.query) || '';
      if (!rawSql) continue; // skip non-SQL targets
      const refId = t.refId || '';
      const project = t.project || '';
      entries.push({
        panelTitle,
        panelDesc,
        panelType,
        panelId,
        datasourceUid,
        refId,
        project,
        rawSql,
        tables: extractBacktickedTables(rawSql),
      });
    }
  }

  if (entries.length === 0) {
    console.error('No BigQuery SQL entries found.');
  }

  const lines = [];
  lines.push('## Grafana Dashboard BigQuery Queries (auto-generated)');
  lines.push('');
  lines.push(`Source file: ${path.basename(inPath)}`);
  lines.push(`Extracted at: ${new Date().toISOString()}`);
  lines.push('');
  for (const e of entries) {
    const title = e.panelTitle || '(untitled panel)';
    const interpretation = e.panelDesc?.trim() ? e.panelDesc.trim() : summarizeQuery(e.rawSql);
    lines.push(`### ${title}${typeof e.panelId === 'number' ? ` (panel ${e.panelId})` : ''}`);
    lines.push(`- Type: ${e.panelType || 'unknown'}`);
    lines.push(`- Datasource UID: ${e.datasourceUid || 'unknown'}`);
    lines.push(`- Project: ${e.project || 'unknown'}`);
    lines.push(`- Ref: ${e.refId || 'N/A'}`);
    lines.push(`- Tables: ${e.tables.length > 0 ? e.tables.join(', ') : 'UNKNOWN'}`);
    lines.push(`- Interpretation: ${interpretation}`);
    lines.push('');
    lines.push('```sql');
    lines.push(e.rawSql.trim());
    lines.push('```');
    lines.push('');
  }

  const markdown = lines.join('\n');

  // Ensure output directory
  await fs.mkdir(path.dirname(outPath), { recursive: true });
  await fs.writeFile(outPath, markdown, 'utf8');
  console.log(`Wrote ${entries.length} queries to ${outPath}`);

  if (updateBigQueryAi) {
    const bigQueryAiPath = path.resolve('bigquery.ai');
    let agent = await fs.readFile(bigQueryAiPath, 'utf8');
    const block = [MARKER_BEGIN, '', markdown, '', MARKER_END].join('\n');
    if (agent.includes(MARKER_BEGIN) && agent.includes(MARKER_END)) {
      agent = agent.replace(
        new RegExp(`${MARKER_BEGIN}[\s\S]*?${MARKER_END}`, 'm'),
        block,
      );
    } else {
      agent = `${agent}\n\n${block}\n`;
    }
    await fs.writeFile(bigQueryAiPath, agent, 'utf8');
    console.log(`Updated ${bigQueryAiPath} with extracted queries.`);
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

