#!/usr/bin/env node
import { Command } from 'commander';
import fs from 'fs';
import { AIAgent } from './ai-agent.js';
import { AIAgentOptions, AIAgentRunOptions, AIAgentCallbacks, AccountingEntry } from './types.js';
import { loadConfiguration } from './config.js';

const program = new Command();

program
  .name('ai-agent')
  .description('Universal LLM Tool Calling Interface with MCP support')
  .version('1.0.0')
  .argument('<providers>', 'Comma-separated list of LLM providers')
  .argument('<models>', 'Comma-separated list of model names')
  .argument('<mcp-tools>', 'Comma-separated list of MCP tools')
  .argument('<system-prompt>', 'System prompt (string, @filename, or - for stdin)')
  .argument('<user-prompt>', 'User prompt (string, @filename, or - for stdin)')
  .option('--llm-timeout <ms>', 'Timeout for LLM responses (ms)', '30000')
  .option('--tool-timeout <ms>', 'Timeout for tool execution (ms)', '10000')
  .option('--temperature <n>', 'LLM temperature (0.0-2.0)', '0.7')
  .option('--top-p <n>', 'LLM top-p sampling (0.0-1.0)', '1.0')
  .option('--save <filename>', 'Save conversation to JSON file')
  .option('--load <filename>', 'Load conversation from JSON file')
  .option('--config <filename>', 'Configuration file path')
  .option('--accounting <filename>', 'Override accounting file from config')
  .option('--dry-run', 'Validate config and MCP only, no LLM requests')
  .option('--verbose', 'Enable debug logging to stderr')
  .option('--quiet', 'Only print errors to stderr')
  .option('--trace-llm', 'Log LLM HTTP requests and responses (redacted)')
  .option('--trace-mcp', 'Log MCP requests, responses, and server stderr')
  .option('--parallel-tool-calls', 'Enable parallel tool calls')
  .option('--no-parallel-tool-calls', 'Disable parallel tool calls')
  .action(async (providers, models, mcpTools, systemPrompt, userPrompt, options) => {
    try {
      if (systemPrompt === '-' && userPrompt === '-') {
        console.error('Error: cannot use stdin ("-") for both system and user prompts');
        process.exit(4);
      }
      const providerList = providers.split(',').map((s: string) => s.trim()).filter(Boolean);
      const modelList = models.split(',').map((s: string) => s.trim()).filter(Boolean);
      const toolList = mcpTools.split(',').map((s: string) => s.trim()).filter(Boolean);

      if (!providerList.length || !modelList.length || !toolList.length) {
        console.error('Error: providers, models, and mcp-tools are required');
        process.exit(4);
      }

      const llmTimeout = parseInt(options.llmTimeout);
      const toolTimeout = parseInt(options.toolTimeout);
      const temperature = parseFloat(options.temperature);
      const topP = parseFloat(options.topP);

      if (Number.isNaN(llmTimeout) || llmTimeout <= 0) { console.error('Error: --llm-timeout must be positive'); process.exit(4); }
      if (Number.isNaN(toolTimeout) || toolTimeout <= 0) { console.error('Error: --tool-timeout must be positive'); process.exit(4); }
      if (Number.isNaN(temperature) || temperature < 0 || temperature > 2) { console.error('Error: --temperature must be between 0 and 2'); process.exit(4); }
      if (Number.isNaN(topP) || topP < 0 || topP > 1) { console.error('Error: --top-p must be between 0 and 1'); process.exit(4); }

      const config = loadConfiguration(options.config);

      const agentOptions: AIAgentOptions = {
        configPath: options.config,
        llmTimeout,
        toolTimeout,
        temperature,
        topP,
        traceLLM: !!options.traceLlm,
        traceMCP: !!options.traceMcp,
        parallelToolCalls: typeof options.parallelToolCalls === 'boolean' ? !!options.parallelToolCalls : undefined,
      };

      // Resolve prompts
      async function readPrompt(value: string): Promise<string> {
        if (value === '-') {
          const chunks: Buffer[] = [];
          await new Promise<void>((resolve, reject) => {
            process.stdin.on('data', (d) => chunks.push(Buffer.from(d)));
            process.stdin.on('end', () => resolve());
            process.stdin.on('error', reject);
          });
          return Buffer.concat(chunks).toString('utf8');
        }
        if (value.startsWith('@')) return fs.readFileSync(value.slice(1), 'utf8');
        return value;
      }

      const resolvedSystem = await readPrompt(systemPrompt);
      const resolvedUser = await readPrompt(userPrompt);

      let conversationHistory = undefined;
      if (options.load) {
        try {
          const content = fs.readFileSync(options.load, 'utf-8');
          conversationHistory = JSON.parse(content);
        } catch (e) {
          console.error(`Error loading conversation from ${options.load}: ${e}`);
          process.exit(1);
        }
      }

      const runOptions: AIAgentRunOptions = {
        providers: providerList,
        models: modelList,
        tools: toolList,
        systemPrompt: resolvedSystem,
        userPrompt: resolvedUser,
        conversationHistory,
        dryRun: !!options.dryRun,
      };

      const accountingFile = options.accounting ?? config.accounting?.file;
      type Level = 'debug' | 'info' | 'warn' | 'error';
      const threshold: Level = options.quiet ? 'error' : options.verbose ? 'debug' : 'info';
      const order: Record<Level, number> = { debug: 10, info: 20, warn: 30, error: 40 };
      const callbacks: AIAgentCallbacks = {
        onLog: (level, message) => {
          if (order[level as Level] >= order[threshold]) process.stderr.write(`[${level}] ${message}\n`);
        },
        onOutput: (text) => process.stdout.write(text),
        onAccounting: (entry: AccountingEntry) => {
          if (!accountingFile) return;
          try {
            fs.appendFileSync(accountingFile, JSON.stringify(entry) + '\n', 'utf-8');
          } catch (e) {
            process.stderr.write(`[warn] Failed to write accounting entry: ${String(e)}\n`);
          }
        },
      };

      const agent = new AIAgent({ ...agentOptions, callbacks });
      const result = await agent.run(runOptions);
      if (!result.success) {
        console.error(`Error: ${result.error}`);
        if (String(result.error).includes('Configuration')) process.exit(1);
        else if (String(result.error).includes('tool')) process.exit(3);
        else process.exit(2);
      }
      if (options.save) {
        try {
          fs.writeFileSync(options.save, JSON.stringify(result.conversation, null, 2), 'utf-8');
        } catch (e) {
          console.error(`Error saving conversation to ${options.save}: ${e}`);
          process.exit(1);
        }
      }
      process.exit(0);
    } catch (error) {
      const msg = error instanceof Error ? error.message : 'Unknown error';
      console.error(`Fatal error: ${msg}`);
      if (msg.includes('config')) process.exit(1);
      else if (msg.includes('argument')) process.exit(4);
      else if (msg.includes('tool')) process.exit(3);
      else process.exit(1);
    }
  });

process.on('uncaughtException', (e) => { console.error(`Uncaught exception: ${e instanceof Error ? e.message : String(e)}`); process.exit(1); });
process.on('unhandledRejection', (r) => { console.error(`Unhandled rejection: ${String(r)}`); process.exit(1); });

program.parse();
